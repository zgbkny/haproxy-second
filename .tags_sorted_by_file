!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
-format	Makefile	/^	git archive --format=tar --prefix="haproxy-$(VERSION)\/" HEAD | gzip -9 > haproxy-$(VERSION)$(SUBVERS).tar.gz$/;"	m
ADDINC	Makefile	/^ADDINC =$/;"	m
ADDLIB	Makefile	/^ADDLIB =$/;"	m
ARCH	Makefile	/^ARCH =$/;"	m
ARCH_FLAGS	Makefile	/^ARCH_FLAGS        = $(ARCH_FLAGS.$(ARCH))$/;"	m
ARCH_FLAGS.32	Makefile	/^ARCH_FLAGS.32     = -m32$/;"	m
ARCH_FLAGS.64	Makefile	/^ARCH_FLAGS.64     = -m64$/;"	m
ARCH_FLAGS.i386	Makefile	/^ARCH_FLAGS.i386   = -m32 -march=i386$/;"	m
ARCH_FLAGS.i486	Makefile	/^ARCH_FLAGS.i486   = -m32 -march=i486$/;"	m
ARCH_FLAGS.i586	Makefile	/^ARCH_FLAGS.i586   = -m32 -march=i586$/;"	m
ARCH_FLAGS.i686	Makefile	/^ARCH_FLAGS.i686   = -m32 -march=i686$/;"	m
ARCH_FLAGS.x86_64	Makefile	/^ARCH_FLAGS.x86_64 = -m64 -march=x86-64$/;"	m
BUILD_OPTIONS	Makefile	/^BUILD_OPTIONS =$/;"	m
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = $(ARCH_FLAGS) $(CPU_CFLAGS) $(DEBUG_CFLAGS) $(SPEC_CFLAGS)$/;"	m
COPTS	Makefile	/^COPTS  = -Iinclude -I$(EBTREE_DIR) -Iinclude -I hash -Wall$/;"	m
CPU	Makefile	/^CPU = generic$/;"	m
CPU_CFLAGS	Makefile	/^CPU_CFLAGS            = $(CPU_CFLAGS.$(CPU))$/;"	m
CPU_CFLAGS.generic	Makefile	/^CPU_CFLAGS.generic    = -O2$/;"	m
CPU_CFLAGS.i586	Makefile	/^CPU_CFLAGS.i586       = -O2 -march=i586$/;"	m
CPU_CFLAGS.i686	Makefile	/^CPU_CFLAGS.i686       = -O2 -march=i686$/;"	m
CPU_CFLAGS.native	Makefile	/^CPU_CFLAGS.native     = -O2 -march=native$/;"	m
CPU_CFLAGS.ultrasparc	Makefile	/^CPU_CFLAGS.ultrasparc = -O6 -mcpu=v9 -mtune=ultrasparc$/;"	m
DEBUG	Makefile	/^DEBUG =$/;"	m
DEBUG_CFLAGS	Makefile	/^DEBUG_CFLAGS = -g$/;"	m
DEFINE	Makefile	/^DEFINE =$/;"	m
DESTDIR	Makefile	/^DESTDIR =$/;"	m
DLMALLOC_SRC	Makefile	/^DLMALLOC_SRC=src\/dlmalloc.c$/;"	m
DLMALLOC_THRES	Makefile	/^DLMALLOC_THRES = 4096$/;"	m
DOCDIR	Makefile	/^DOCDIR = $(PREFIX)\/doc\/haproxy$/;"	m
EBTREE_DIR	Makefile	/^EBTREE_DIR := ebtree$/;"	m
EBTREE_OBJS	Makefile	/^EBTREE_OBJS = $(EBTREE_DIR)\/ebtree.o \\$/;"	m
LD	Makefile	/^LD = $(CC)$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = $(ARCH_FLAGS) -g$/;"	m
LDOPTS	Makefile	/^LDOPTS = $(TARGET_LDFLAGS) $(OPTIONS_LDFLAGS) $(ADDLIB)$/;"	m
LIB_EBTREE	Makefile	/^LIB_EBTREE = $(EBTREE_DIR)\/libebtree.a$/;"	m
MANDIR	Makefile	/^MANDIR = $(PREFIX)\/share\/man$/;"	m
OBJS	Makefile	/^OBJS = src\/haproxy.o src\/sessionhash.o src\/base64.o src\/protocols.o \\$/;"	m
OPTIONS_CFLAGS	Makefile	/^OPTIONS_CFLAGS  =$/;"	m
OPTIONS_LDFLAGS	Makefile	/^OPTIONS_LDFLAGS =$/;"	m
OPTIONS_OBJS	Makefile	/^OPTIONS_OBJS    =$/;"	m
PCREDIR	Makefile	/^PCREDIR	        := $(shell pcre-config --prefix 2>\/dev\/null || echo \/usr\/local)$/;"	m
PCREDIR	Makefile	/^PCREDIR         := $(shell pcre-config --prefix 2>\/dev\/null || echo \/usr\/local)$/;"	m
PREFIX	Makefile	/^PREFIX = \/usr\/local$/;"	m
REGEX	Makefile	/^REGEX = libc$/;"	m
SBINDIR	Makefile	/^SBINDIR = $(PREFIX)\/sbin$/;"	m
SILENT_DEFINE	Makefile	/^SILENT_DEFINE =$/;"	m
SMALL_OPTS	Makefile	/^SMALL_OPTS =$/;"	m
SPEC_CFLAGS	Makefile	/^SPEC_CFLAGS = -fno-strict-aliasing$/;"	m
SUBVERS	Makefile	/^SUBVERS := $(shell cat SUBVERS 2>\/dev\/null || touch SUBVERS)$/;"	m
SUBVERS	Makefile	/^SUBVERS := $(shell comms=`git log --no-merges v$(VERSION).. 2>\/dev\/null |grep -c ^commit `; [ $$comms -gt 0 ] && echo "-$$comms" )$/;"	m
TARGET	Makefile	/^TARGET =$/;"	m
TARGET_CFLAGS	Makefile	/^  TARGET_CFLAGS  = $(if $(filter 1.5.%, $(shell uname -r)), -DUSE_IPV6 -DAF_INET6=23 -DINET6_ADDRSTRLEN=46, )$/;"	m
TARGET_CFLAGS	Makefile	/^  TARGET_CFLAGS  = -fomit-frame-pointer -DFD_SETSIZE=65536 -D_REENTRANT$/;"	m
TARGET_LDFLAGS	Makefile	/^  TARGET_LDFLAGS = -lnsl -lsocket$/;"	m
TRACE	Makefile	/^TRACE =$/;"	m
TRACE_COPTS	Makefile	/^TRACE_COPTS := $(filter-out -O0 -O1 -O2 -pg -finstrument-functions,$(COPTS)) -O3 -fomit-frame-pointer$/;"	m
USE_CRYPT_H	Makefile	/^  USE_CRYPT_H     = implicit$/;"	m
USE_EPOLL	Makefile	/^  USE_EPOLL       = implicit$/;"	m
USE_GETADDRINFO	Makefile	/^  USE_GETADDRINFO = implicit$/;"	m
USE_GETSOCKNAME	Makefile	/^  USE_GETSOCKNAME = implicit$/;"	m
USE_KQUEUE	Makefile	/^  USE_KQUEUE     = implicit$/;"	m
USE_LIBCRYPT	Makefile	/^  USE_LIBCRYPT    = implicit$/;"	m
USE_LIBCRYPT	Makefile	/^  USE_LIBCRYPT   = implicit$/;"	m
USE_LINUX_SPLICE	Makefile	/^  USE_LINUX_SPLICE= implicit$/;"	m
USE_LINUX_TPROXY	Makefile	/^  USE_LINUX_TPROXY= implicit$/;"	m
USE_MY_EPOLL	Makefile	/^  USE_MY_EPOLL    = implicit$/;"	m
USE_NETFILTER	Makefile	/^  USE_NETFILTER   = implicit$/;"	m
USE_PCRE	Makefile	/^USE_PCRE = 1$/;"	m
USE_POLL	Makefile	/^  USE_POLL        = implicit$/;"	m
USE_POLL	Makefile	/^  USE_POLL       = implicit$/;"	m
USE_POLL	Makefile	/^  USE_POLL   = implicit$/;"	m
USE_SEPOLL	Makefile	/^  USE_SEPOLL      = implicit$/;"	m
USE_STATIC_PCRE	Makefile	/^USE_STATIC_PCRE = 1$/;"	m
USE_TPROXY	Makefile	/^  USE_TPROXY      = implicit$/;"	m
USE_TPROXY	Makefile	/^  USE_TPROXY     = implicit$/;"	m
USE_TPROXY	Makefile	/^  USE_TPROXY = implicit$/;"	m
USE_TPROXY	Makefile	/^USE_TPROXY = 1$/;"	m
VERBOSE_CFLAGS	Makefile	/^VERBOSE_CFLAGS = $(CFLAGS) $(TARGET_CFLAGS) $(SMALL_OPTS) $(DEFINE)$/;"	m
VERDATE	Makefile	/^VERDATE := $(shell cat VERDATE 2>\/dev\/null || touch VERDATE)$/;"	m
VERDATE	Makefile	/^VERDATE := $(shell date +%Y\/%m\/%d -d "`git log --pretty=fuller HEAD^.. 2>\/dev\/null | sed -ne '\/^CommitDate:\/{s\/\\(^[^ ]*:\\)\\|\\( [-+].*\\)\/\/gp;q}'`" )$/;"	m
VERSION	Makefile	/^VERSION := $(shell [ -d .git\/. ] && ref=`(git describe --tags --match 'v*') 2>\/dev\/null` && ref=$${ref%-g*} && echo "$${ref\\#v}")$/;"	m
VERSION	Makefile	/^VERSION := $(shell cat VERSION 2>\/dev\/null || touch VERSION)$/;"	m
ignore_implicit	Makefile	/^ignore_implicit = $(patsubst %=implicit,,$(1)=$($(1)))$/;"	m
B64MAX	contrib/base64/base64rev-gen.c	19;"	d	file:
B64PADV	contrib/base64/base64rev-gen.c	20;"	d	file:
base	contrib/base64/base64rev-gen.c	18;"	d	file:
base64rev	contrib/base64/base64rev-gen.c	/^char base64rev[128];$/;"	v
base64tab	contrib/base64/base64rev-gen.c	/^const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v
main	contrib/base64/base64rev-gen.c	/^int main() {$/;"	f
CC	contrib/halog/Makefile	/^CC       = gcc$/;"	m
EBTREE_DIR	contrib/halog/Makefile	/^EBTREE_DIR = ..\/..\/ebtree$/;"	m
INCLUDE	contrib/halog/Makefile	/^INCLUDE  = -I..\/..\/include -I$(EBTREE_DIR)$/;"	m
OBJS	contrib/halog/Makefile	/^OBJS     = halog halog64$/;"	m
OPTIMIZE	contrib/halog/Makefile	/^OPTIMIZE = -O3$/;"	m
FGETS2_BUFSIZE	contrib/halog/fgets2-64.c	58;"	d	file:
fgets2	contrib/halog/fgets2-64.c	/^const char *fgets2(FILE *stream)$/;"	f
has_zero	contrib/halog/fgets2-64.c	/^static inline unsigned int has_zero(unsigned int x)$/;"	f	file:
has_zero64	contrib/halog/fgets2-64.c	/^static inline unsigned long long has_zero64(unsigned long long x)$/;"	f	file:
main	contrib/halog/fgets2-64.c	/^int main() {$/;"	f
FGETS2_BUFSIZE	contrib/halog/fgets2.c	47;"	d	file:
fgets2	contrib/halog/fgets2.c	/^const char *fgets2(FILE *stream)$/;"	f
has_zero	contrib/halog/fgets2.c	/^static inline unsigned int has_zero(unsigned int x)$/;"	f	file:
main	contrib/halog/fgets2.c	/^int main() {$/;"	f
ACCEPT_FIELD	contrib/halog/halog.c	28;"	d	file:
CONN_FIELD	contrib/halog/halog.c	33;"	d	file:
FILT_ACC_COUNT	contrib/halog/halog.c	78;"	d	file:
FILT_ACC_DELAY	contrib/halog/halog.c	77;"	d	file:
FILT_COUNT_ONLY	contrib/halog/halog.c	73;"	d	file:
FILT_COUNT_SRV_STATUS	contrib/halog/halog.c	87;"	d	file:
FILT_COUNT_STATUS	contrib/halog/halog.c	86;"	d	file:
FILT_COUNT_TERM_CODES	contrib/halog/halog.c	88;"	d	file:
FILT_COUNT_URL_ANY	contrib/halog/halog.c	97;"	d	file:
FILT_COUNT_URL_COUNT	contrib/halog/halog.c	91;"	d	file:
FILT_COUNT_URL_ERR	contrib/halog/halog.c	92;"	d	file:
FILT_COUNT_URL_ONLY	contrib/halog/halog.c	90;"	d	file:
FILT_COUNT_URL_TAVG	contrib/halog/halog.c	94;"	d	file:
FILT_COUNT_URL_TAVGO	contrib/halog/halog.c	96;"	d	file:
FILT_COUNT_URL_TTOT	contrib/halog/halog.c	93;"	d	file:
FILT_COUNT_URL_TTOTO	contrib/halog/halog.c	95;"	d	file:
FILT_ERRORS_ONLY	contrib/halog/halog.c	76;"	d	file:
FILT_GRAPH_TIMERS	contrib/halog/halog.c	79;"	d	file:
FILT_HTTP_ONLY	contrib/halog/halog.c	100;"	d	file:
FILT_HTTP_STATUS	contrib/halog/halog.c	104;"	d	file:
FILT_INVERT	contrib/halog/halog.c	74;"	d	file:
FILT_INVERT_ERRORS	contrib/halog/halog.c	83;"	d	file:
FILT_INVERT_HTTP_STATUS	contrib/halog/halog.c	105;"	d	file:
FILT_INVERT_TERM_CODE_NAME	contrib/halog/halog.c	102;"	d	file:
FILT_INVERT_TIME_RESP	contrib/halog/halog.c	84;"	d	file:
FILT_PERCENTILE	contrib/halog/halog.c	80;"	d	file:
FILT_QUEUE_ONLY	contrib/halog/halog.c	106;"	d	file:
FILT_QUEUE_SRV_ONLY	contrib/halog/halog.c	107;"	d	file:
FILT_QUIET	contrib/halog/halog.c	75;"	d	file:
FILT_TERM_CODE_NAME	contrib/halog/halog.c	101;"	d	file:
FILT_TIME_RESP	contrib/halog/halog.c	81;"	d	file:
MAXLINE	contrib/halog/halog.c	37;"	d	file:
METH_FIELD	contrib/halog/halog.c	35;"	d	file:
QBITS	contrib/halog/halog.c	38;"	d	file:
QUEUE_LEN_FIELD	contrib/halog/halog.c	34;"	d	file:
SEP	contrib/halog/halog.c	40;"	d	file:
SERVER_FIELD	contrib/halog/halog.c	29;"	d	file:
SKIP_CHAR	contrib/halog/halog.c	41;"	d	file:
SOURCE_FIELD	contrib/halog/halog.c	27;"	d	file:
STATUS_FIELD	contrib/halog/halog.c	31;"	d	file:
TERM_CODES_FIELD	contrib/halog/halog.c	32;"	d	file:
TIME_FIELD	contrib/halog/halog.c	30;"	d	file:
URL_FIELD	contrib/halog/halog.c	36;"	d	file:
__strl2ui	contrib/halog/halog.c	/^static inline unsigned int __strl2ui(const char *s, int len)$/;"	f	file:
convert_date	contrib/halog/halog.c	/^int convert_date(const char *field)$/;"	f
count	contrib/halog/halog.c	/^	unsigned int count;$/;"	m	struct:timer	file:
cum_ct	contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:
cum_rt	contrib/halog/halog.c	/^	unsigned long long cum_ct, cum_rt;$/;"	m	struct:srv_st	file:
die	contrib/halog/halog.c	/^void die(const char *msg)$/;"	f
field_start	contrib/halog/halog.c	/^const char *field_start(const char *p, int field)$/;"	f
field_stop	contrib/halog/halog.c	/^const char *field_stop(const char *p)$/;"	f
field_stop	contrib/halog/halog.c	/^static inline const char *field_stop(const char *p)$/;"	f	file:
filter	contrib/halog/halog.c	/^unsigned int filter = 0;$/;"	v
filter_accept_holes	contrib/halog/halog.c	/^void filter_accept_holes(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_srv_status	contrib/halog/halog.c	/^void filter_count_srv_status(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_status	contrib/halog/halog.c	/^void filter_count_status(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_term_codes	contrib/halog/halog.c	/^void filter_count_term_codes(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_count_url	contrib/halog/halog.c	/^void filter_count_url(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_graphs	contrib/halog/halog.c	/^void filter_graphs(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
filter_invert	contrib/halog/halog.c	/^unsigned int filter_invert = 0;$/;"	v
filter_output_line	contrib/halog/halog.c	/^void filter_output_line(const char *accept_field, const char *time_field, struct timer **tptr)$/;"	f
help	contrib/halog/halog.c	/^void help()$/;"	f
insert_timer	contrib/halog/halog.c	/^struct timer *insert_timer(struct eb_root *r, struct timer **alloc, int v)$/;"	f
insert_value	contrib/halog/halog.c	/^struct timer *insert_value(struct eb_root *r, struct timer **alloc, int v)$/;"	f
line	contrib/halog/halog.c	/^const char *line;$/;"	v
linenum	contrib/halog/halog.c	/^int linenum = 0;$/;"	v
lines_out	contrib/halog/halog.c	/^int lines_out = 0;$/;"	v
main	contrib/halog/halog.c	/^int main(int argc, char **argv)$/;"	f
nb_ct	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:
nb_err	contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:
nb_ok	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:
nb_req	contrib/halog/halog.c	/^	unsigned int nb_err, nb_req;$/;"	m	struct:url_stat	file:
nb_rt	contrib/halog/halog.c	/^	unsigned int nb_ct, nb_rt, nb_ok;$/;"	m	struct:srv_st	file:
node	contrib/halog/halog.c	/^	struct eb32_node node;$/;"	m	struct:timer	typeref:struct:timer::eb32_node	file:
node	contrib/halog/halog.c	/^	struct ebmb_node node;$/;"	m	struct:srv_st	typeref:struct:srv_st::ebmb_node	file:
node	contrib/halog/halog.c	/^	} node;$/;"	m	struct:url_stat	typeref:union:url_stat::__anon5	file:
parse_err	contrib/halog/halog.c	/^int parse_err = 0;$/;"	v
quantify	contrib/halog/halog.c	/^static inline int quantify(int i, int bits)$/;"	f	file:
quantify_u32	contrib/halog/halog.c	/^static inline unsigned int quantify_u32(unsigned int i, int bits)$/;"	f	file:
srv_st	contrib/halog/halog.c	/^struct srv_st {$/;"	s	file:
st_cnt	contrib/halog/halog.c	/^	unsigned int st_cnt[6]; \/* 0xx to 5xx *\/$/;"	m	struct:srv_st	file:
str2ic	contrib/halog/halog.c	/^int str2ic(const char *s)$/;"	f
strl2ui	contrib/halog/halog.c	/^unsigned int strl2ui(const char *s, int len)$/;"	f
timer	contrib/halog/halog.c	/^struct timer {$/;"	s	file:
timers	contrib/halog/halog.c	/^static struct eb_root timers[5] = {$/;"	v	typeref:struct:eb_root	file:
total_time	contrib/halog/halog.c	/^	unsigned long long total_time;    \/* sum(all reqs' times) *\/$/;"	m	struct:url_stat	file:
total_time_ok	contrib/halog/halog.c	/^	unsigned long long total_time_ok; \/* sum(all OK reqs' times) *\/$/;"	m	struct:url_stat	file:
truncated_line	contrib/halog/halog.c	/^void truncated_line(int linenum, const char *line)$/;"	f
url	contrib/halog/halog.c	/^		struct ebpt_node url;$/;"	m	union:url_stat::__anon5	typeref:struct:url_stat::__anon5::ebpt_node	file:
url	contrib/halog/halog.c	/^	char *url;$/;"	m	struct:url_stat	file:
url_stat	contrib/halog/halog.c	/^struct url_stat {$/;"	s	file:
usage	contrib/halog/halog.c	/^void usage(FILE *output, const char *msg)$/;"	f
val	contrib/halog/halog.c	/^		struct eb64_node val;$/;"	m	union:url_stat::__anon5	typeref:struct:url_stat::__anon5::eb64_node	file:
CC	contrib/iprange/Makefile	/^CC       = gcc$/;"	m
LDFLAGS	contrib/iprange/Makefile	/^LDFLAGS  = -s$/;"	m
OBJS	contrib/iprange/Makefile	/^OBJS     = iprange$/;"	m
OPTIMIZE	contrib/iprange/Makefile	/^OPTIMIZE = -O3$/;"	m
MAXLINE	contrib/iprange/iprange.c	27;"	d	file:
convert_range	contrib/iprange/iprange.c	/^static void convert_range(unsigned int low, unsigned int high, const char *eol)$/;"	f	file:
get_ipv4_addr	contrib/iprange/iprange.c	/^static const char *get_ipv4_addr(unsigned int addr)$/;"	f	file:
main	contrib/iprange/iprange.c	/^main(int argc, char **argv)$/;"	f
usage	contrib/iprange/iprange.c	/^static void usage(const char *argv0)$/;"	f	file:
FIELD_INDEX	contrib/netsnmp-perl/haproxy.pl	/^use constant FIELD_INDEX => 10001;$/;"	c
FIELD_NAME	contrib/netsnmp-perl/haproxy.pl	/^use constant FIELD_NAME => 10002;$/;"	c
OID_HAPROXY	contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY => '1.3.6.1.4.1.29385.106';$/;"	c
OID_HAPROXY_INFO	contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY_INFO => OID_HAPROXY . '.2';$/;"	c
OID_HAPROXY_STATS	contrib/netsnmp-perl/haproxy.pl	/^use constant OID_HAPROXY_STATS => OID_HAPROXY . '.1';$/;"	c
STATS_IID	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_IID => 27;$/;"	c
STATS_PXNAME	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_PXNAME => 0;$/;"	c
STATS_SID	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_SID => 28;$/;"	c
STATS_SVNAME	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_SVNAME => 1;$/;"	c
STATS_TYPE	contrib/netsnmp-perl/haproxy.pl	/^use constant STATS_TYPE => 32;$/;"	c
find_next_stat_id	contrib/netsnmp-perl/haproxy.pl	/^sub find_next_stat_id {$/;"	s
haproxy_info	contrib/netsnmp-perl/haproxy.pl	/^sub haproxy_info {$/;"	s
haproxy_stat	contrib/netsnmp-perl/haproxy.pl	/^sub haproxy_stat {$/;"	s
getptr	contrib/trace/trace.awk	/^function getptr(ptr)$/;"	f
eb32_insert	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_insert(struct eb_root *root, struct eb32_node *new)$/;"	f
eb32_lookup	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup(struct eb_root *root, u32 x)$/;"	f
eb32_lookup_ge	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup_ge(struct eb_root *root, u32 x)$/;"	f
eb32_lookup_le	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32_lookup_le(struct eb_root *root, u32 x)$/;"	f
eb32i_insert	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32i_insert(struct eb_root *root, struct eb32_node *new)$/;"	f
eb32i_lookup	ebtree/eb32tree.c	/^REGPRM2 struct eb32_node *eb32i_lookup(struct eb_root *root, s32 x)$/;"	f
EB32_ROOT	ebtree/eb32tree.h	30;"	d
EB32_TREE_HEAD	ebtree/eb32tree.h	31;"	d
_EB32TREE_H	ebtree/eb32tree.h	22;"	d
__eb32_delete	ebtree/eb32tree.h	/^static forceinline void __eb32_delete(struct eb32_node *eb32)$/;"	f
__eb32_insert	ebtree/eb32tree.h	/^__eb32_insert(struct eb_root *root, struct eb32_node *new) {$/;"	f
__eb32_lookup	ebtree/eb32tree.h	/^static forceinline struct eb32_node *__eb32_lookup(struct eb_root *root, u32 x)$/;"	f
__eb32i_insert	ebtree/eb32tree.h	/^__eb32i_insert(struct eb_root *root, struct eb32_node *new) {$/;"	f
__eb32i_lookup	ebtree/eb32tree.h	/^static forceinline struct eb32_node *__eb32i_lookup(struct eb_root *root, s32 x)$/;"	f
eb32_delete	ebtree/eb32tree.h	/^static inline void eb32_delete(struct eb32_node *eb32)$/;"	f
eb32_entry	ebtree/eb32tree.h	28;"	d
eb32_first	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_first(struct eb_root *root)$/;"	f
eb32_last	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_last(struct eb_root *root)$/;"	f
eb32_next	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next(struct eb32_node *eb32)$/;"	f
eb32_next_unique	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_next_unique(struct eb32_node *eb32)$/;"	f
eb32_node	ebtree/eb32tree.h	/^struct eb32_node {$/;"	s
eb32_prev	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev(struct eb32_node *eb32)$/;"	f
eb32_prev_unique	ebtree/eb32tree.h	/^static inline struct eb32_node *eb32_prev_unique(struct eb32_node *eb32)$/;"	f
key	ebtree/eb32tree.h	/^	u32 key;$/;"	m	struct:eb32_node
node	ebtree/eb32tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb32_node	typeref:struct:eb32_node::eb_node
s32	ebtree/eb32tree.h	/^typedef   signed int s32;$/;"	t
u32	ebtree/eb32tree.h	/^typedef unsigned int u32;$/;"	t
eb64_insert	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_insert(struct eb_root *root, struct eb64_node *new)$/;"	f
eb64_lookup	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup(struct eb_root *root, u64 x)$/;"	f
eb64_lookup_ge	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup_ge(struct eb_root *root, u64 x)$/;"	f
eb64_lookup_le	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64_lookup_le(struct eb_root *root, u64 x)$/;"	f
eb64i_insert	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64i_insert(struct eb_root *root, struct eb64_node *new)$/;"	f
eb64i_lookup	ebtree/eb64tree.c	/^REGPRM2 struct eb64_node *eb64i_lookup(struct eb_root *root, s64 x)$/;"	f
EB64_ROOT	ebtree/eb64tree.h	30;"	d
EB64_TREE_HEAD	ebtree/eb64tree.h	31;"	d
_EB64TREE_H	ebtree/eb64tree.h	22;"	d
__eb64_delete	ebtree/eb64tree.h	/^static forceinline void __eb64_delete(struct eb64_node *eb64)$/;"	f
__eb64_insert	ebtree/eb64tree.h	/^__eb64_insert(struct eb_root *root, struct eb64_node *new) {$/;"	f
__eb64_lookup	ebtree/eb64tree.h	/^static forceinline struct eb64_node *__eb64_lookup(struct eb_root *root, u64 x)$/;"	f
__eb64i_insert	ebtree/eb64tree.h	/^__eb64i_insert(struct eb_root *root, struct eb64_node *new) {$/;"	f
__eb64i_lookup	ebtree/eb64tree.h	/^static forceinline struct eb64_node *__eb64i_lookup(struct eb_root *root, s64 x)$/;"	f
eb64_delete	ebtree/eb64tree.h	/^static inline void eb64_delete(struct eb64_node *eb64)$/;"	f
eb64_entry	ebtree/eb64tree.h	28;"	d
eb64_first	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_first(struct eb_root *root)$/;"	f
eb64_last	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_last(struct eb_root *root)$/;"	f
eb64_next	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next(struct eb64_node *eb64)$/;"	f
eb64_next_unique	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_next_unique(struct eb64_node *eb64)$/;"	f
eb64_node	ebtree/eb64tree.h	/^struct eb64_node {$/;"	s
eb64_prev	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev(struct eb64_node *eb64)$/;"	f
eb64_prev_unique	ebtree/eb64tree.h	/^static inline struct eb64_node *eb64_prev_unique(struct eb64_node *eb64)$/;"	f
key	ebtree/eb64tree.h	/^	u64 key;$/;"	m	struct:eb64_node
node	ebtree/eb64tree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:eb64_node	typeref:struct:eb64_node::eb_node
s64	ebtree/eb64tree.h	/^typedef   signed long long s64;$/;"	t
u64	ebtree/eb64tree.h	/^typedef unsigned long long u64;$/;"	t
ebim_insert	ebtree/ebimtree.c	/^ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)$/;"	f
ebim_lookup	ebtree/ebimtree.c	/^ebim_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
__ebim_insert	ebtree/ebimtree.h	/^__ebim_insert(struct eb_root *root, struct ebpt_node *new, unsigned int len)$/;"	f
__ebim_lookup	ebtree/ebimtree.h	/^__ebim_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
ebis_insert	ebtree/ebistree.c	/^REGPRM2 struct ebpt_node *ebis_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
ebis_lookup	ebtree/ebistree.c	/^REGPRM2 struct ebpt_node *ebis_lookup(struct eb_root *root, const char *x)$/;"	f
__ebis_insert	ebtree/ebistree.h	/^__ebis_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
__ebis_lookup	ebtree/ebistree.h	/^static forceinline struct ebpt_node *__ebis_lookup(struct eb_root *root, const void *x)$/;"	f
ebis_lookup_len	ebtree/ebistree.h	/^ebis_lookup_len(struct eb_root *root, const char *x, unsigned int len)$/;"	f
ebmb_insert	ebtree/ebmbtree.c	/^ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
ebmb_insert_prefix	ebtree/ebmbtree.c	/^ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
ebmb_lookup	ebtree/ebmbtree.c	/^ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
ebmb_lookup_longest	ebtree/ebmbtree.c	/^ebmb_lookup_longest(struct eb_root *root, const void *x)$/;"	f
ebmb_lookup_prefix	ebtree/ebmbtree.c	/^ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)$/;"	f
EBMB_ROOT	ebtree/ebmbtree.h	30;"	d
EBMB_TREE_HEAD	ebtree/ebmbtree.h	31;"	d
_EBMBTREE_H	ebtree/ebmbtree.h	22;"	d
__ebmb_delete	ebtree/ebmbtree.h	/^static forceinline void __ebmb_delete(struct ebmb_node *ebmb)$/;"	f
__ebmb_insert	ebtree/ebmbtree.h	/^__ebmb_insert(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
__ebmb_insert_prefix	ebtree/ebmbtree.h	/^__ebmb_insert_prefix(struct eb_root *root, struct ebmb_node *new, unsigned int len)$/;"	f
__ebmb_lookup	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup(struct eb_root *root, const void *x, unsigned int len)$/;"	f
__ebmb_lookup_longest	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup_longest(struct eb_root *root, const void *x)$/;"	f
__ebmb_lookup_prefix	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *__ebmb_lookup_prefix(struct eb_root *root, const void *x, unsigned int pfx)$/;"	f
ebmb_delete	ebtree/ebmbtree.h	/^static forceinline void ebmb_delete(struct ebmb_node *ebmb)$/;"	f
ebmb_entry	ebtree/ebmbtree.h	28;"	d
ebmb_first	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_first(struct eb_root *root)$/;"	f
ebmb_last	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_last(struct eb_root *root)$/;"	f
ebmb_next	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_next(struct ebmb_node *ebmb)$/;"	f
ebmb_next_unique	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_next_unique(struct ebmb_node *ebmb)$/;"	f
ebmb_node	ebtree/ebmbtree.h	/^struct ebmb_node {$/;"	s
ebmb_prev	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_prev(struct ebmb_node *ebmb)$/;"	f
ebmb_prev_unique	ebtree/ebmbtree.h	/^static forceinline struct ebmb_node *ebmb_prev_unique(struct ebmb_node *ebmb)$/;"	f
key	ebtree/ebmbtree.h	/^	unsigned char key[0]; \/* the key, its size depends on the application *\/$/;"	m	struct:ebmb_node
node	ebtree/ebmbtree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebmb_node	typeref:struct:ebmb_node::eb_node
ebpt_insert	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
ebpt_lookup	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_ge	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_le	ebtree/ebpttree.c	/^REGPRM2 struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)$/;"	f
EBPT_ROOT	ebtree/ebpttree.h	32;"	d
EBPT_TREE_HEAD	ebtree/ebpttree.h	33;"	d
PTR_INT_TYPE	ebtree/ebpttree.h	37;"	d
_EBPTTREE_H	ebtree/ebpttree.h	22;"	d
__ebpt_delete	ebtree/ebpttree.h	/^static forceinline void __ebpt_delete(struct ebpt_node *ebpt)$/;"	f
__ebpt_insert	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *__ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
__ebpt_lookup	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *__ebpt_lookup(struct eb_root *root, void *x)$/;"	f
ebpt_delete	ebtree/ebpttree.h	/^static forceinline void ebpt_delete(struct ebpt_node *ebpt)$/;"	f
ebpt_entry	ebtree/ebpttree.h	30;"	d
ebpt_first	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_first(struct eb_root *root)$/;"	f
ebpt_insert	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_insert(struct eb_root *root, struct ebpt_node *new)$/;"	f
ebpt_last	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_last(struct eb_root *root)$/;"	f
ebpt_lookup	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_ge	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup_ge(struct eb_root *root, void *x)$/;"	f
ebpt_lookup_le	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_lookup_le(struct eb_root *root, void *x)$/;"	f
ebpt_next	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_next(struct ebpt_node *ebpt)$/;"	f
ebpt_next_unique	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_next_unique(struct ebpt_node *ebpt)$/;"	f
ebpt_node	ebtree/ebpttree.h	/^struct ebpt_node {$/;"	s
ebpt_prev	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_prev(struct ebpt_node *ebpt)$/;"	f
ebpt_prev_unique	ebtree/ebpttree.h	/^static forceinline struct ebpt_node *ebpt_prev_unique(struct ebpt_node *ebpt)$/;"	f
key	ebtree/ebpttree.h	/^	void *key;$/;"	m	struct:ebpt_node
node	ebtree/ebpttree.h	/^	struct eb_node node; \/* the tree node, must be at the beginning *\/$/;"	m	struct:ebpt_node	typeref:struct:ebpt_node::eb_node
ptr_t	ebtree/ebpttree.h	/^typedef PTR_INT_TYPE ptr_t;$/;"	t
ebst_insert	ebtree/ebsttree.c	/^REGPRM2 struct ebmb_node *ebst_insert(struct eb_root *root, struct ebmb_node *new)$/;"	f
ebst_lookup	ebtree/ebsttree.c	/^REGPRM2 struct ebmb_node *ebst_lookup(struct eb_root *root, const char *x)$/;"	f
_EBSTTREE_H	ebtree/ebsttree.h	24;"	d
__ebst_insert	ebtree/ebsttree.h	/^__ebst_insert(struct eb_root *root, struct ebmb_node *new)$/;"	f
__ebst_lookup	ebtree/ebsttree.h	/^static forceinline struct ebmb_node *__ebst_lookup(struct eb_root *root, const void *x)$/;"	f
ebst_lookup_len	ebtree/ebsttree.h	/^ebst_lookup_len(struct eb_root *root, const char *x, unsigned int len)$/;"	f
eb_delete	ebtree/ebtree.c	/^void eb_delete(struct eb_node *node)$/;"	f
eb_insert_dup	ebtree/ebtree.c	/^REGPRM1 struct eb_node *eb_insert_dup(struct eb_node *sub, struct eb_node *new)$/;"	f
EB_LEAF	ebtree/ebtree.h	334;"	d
EB_LEFT	ebtree/ebtree.h	332;"	d
EB_NODE	ebtree/ebtree.h	335;"	d
EB_NODE_BITS	ebtree/ebtree.h	325;"	d
EB_NODE_BRANCHES	ebtree/ebtree.h	326;"	d
EB_NODE_BRANCH_MASK	ebtree/ebtree.h	327;"	d
EB_NORMAL	ebtree/ebtree.h	341;"	d
EB_RGHT	ebtree/ebtree.h	333;"	d
EB_ROOT	ebtree/ebtree.h	379;"	d
EB_ROOT_UNIQUE	ebtree/ebtree.h	384;"	d
EB_TREE_HEAD	ebtree/ebtree.h	389;"	d
EB_UNIQUE	ebtree/ebtree.h	342;"	d
_EBTREE_H	ebtree/ebtree.h	247;"	d
__eb_delete	ebtree/ebtree.h	/^static forceinline void __eb_delete(struct eb_node *node)$/;"	f
__eb_insert_dup	ebtree/ebtree.h	/^__eb_insert_dup(struct eb_node *sub, struct eb_node *new)$/;"	f
b	ebtree/ebtree.h	/^	eb_troot_t    *b[EB_NODE_BRANCHES]; \/* left and right branches *\/$/;"	m	struct:eb_root
bit	ebtree/ebtree.h	/^	short int      bit;     \/* link's bit position. *\/$/;"	m	struct:eb_node
branches	ebtree/ebtree.h	/^	struct eb_root branches; \/* branches, must be at the beginning *\/$/;"	m	struct:eb_node	typeref:struct:eb_node::eb_root
check_bits	ebtree/ebtree.h	/^static forceinline int check_bits(const unsigned char *a,$/;"	f
cmp_bits	ebtree/ebtree.h	/^static forceinline int cmp_bits(const unsigned char *a, const unsigned char *b, unsigned int pos)$/;"	f
container_of	ebtree/ebtree.h	321;"	d
eb_clrtag	ebtree/ebtree.h	/^static inline struct eb_root *eb_clrtag(const eb_troot_t *troot)$/;"	f
eb_dotag	ebtree/ebtree.h	/^static inline eb_troot_t *eb_dotag(const struct eb_root *root, const int tag)$/;"	f
eb_entry	ebtree/ebtree.h	373;"	d
eb_first	ebtree/ebtree.h	/^static inline struct eb_node *eb_first(struct eb_root *root)$/;"	f
eb_gettag	ebtree/ebtree.h	/^static inline int eb_gettag(eb_troot_t *troot)$/;"	f
eb_is_empty	ebtree/ebtree.h	/^static inline int eb_is_empty(struct eb_root *root)$/;"	f
eb_last	ebtree/ebtree.h	/^static inline struct eb_node *eb_last(struct eb_root *root)$/;"	f
eb_next	ebtree/ebtree.h	/^static inline struct eb_node *eb_next(struct eb_node *node)$/;"	f
eb_next_unique	ebtree/ebtree.h	/^static inline struct eb_node *eb_next_unique(struct eb_node *node)$/;"	f
eb_node	ebtree/ebtree.h	/^struct eb_node {$/;"	s
eb_prev	ebtree/ebtree.h	/^static inline struct eb_node *eb_prev(struct eb_node *node)$/;"	f
eb_prev_unique	ebtree/ebtree.h	/^static inline struct eb_node *eb_prev_unique(struct eb_node *node)$/;"	f
eb_root	ebtree/ebtree.h	/^struct eb_root {$/;"	s
eb_root_to_node	ebtree/ebtree.h	/^static inline struct eb_node *eb_root_to_node(struct eb_root *root)$/;"	f
eb_troot_t	ebtree/ebtree.h	/^typedef void eb_troot_t;$/;"	t
eb_untag	ebtree/ebtree.h	/^static inline struct eb_root *eb_untag(const eb_troot_t *troot, const int tag)$/;"	f
eb_walk_down	ebtree/ebtree.h	/^static inline struct eb_node *eb_walk_down(eb_troot_t *start, unsigned int side)$/;"	f
equal_bits	ebtree/ebtree.h	/^static forceinline int equal_bits(const unsigned char *a,$/;"	f
fls64	ebtree/ebtree.h	/^static inline int fls64(unsigned long long x)$/;"	f
fls_auto	ebtree/ebtree.h	315;"	d
flsnz	ebtree/ebtree.h	/^static inline int flsnz(int x)$/;"	f
flsnz	ebtree/ebtree.h	283;"	d
flsnz8	ebtree/ebtree.h	/^static inline int flsnz8(unsigned char x)$/;"	f
flsnz8	ebtree/ebtree.h	/^static inline int flsnz8(unsigned int x)$/;"	f
flsnz8_generic	ebtree/ebtree.h	/^static inline int flsnz8_generic(unsigned int x)$/;"	f
get_bit	ebtree/ebtree.h	/^static forceinline int get_bit(const unsigned char *a, unsigned int pos)$/;"	f
leaf_p	ebtree/ebtree.h	/^	eb_troot_t    *leaf_p;  \/* leaf node's parent *\/$/;"	m	struct:eb_node
node_p	ebtree/ebtree.h	/^	eb_troot_t    *node_p;  \/* link node's parent *\/$/;"	m	struct:eb_node
pfx	ebtree/ebtree.h	/^	short unsigned int pfx; \/* data prefix length, always related to leaf *\/$/;"	m	struct:eb_node
string_equal_bits	ebtree/ebtree.h	/^static forceinline int string_equal_bits(const unsigned char *a,$/;"	f
do_compile_only	examples/build.cfg	/^function do_compile_only {$/;"	f
do_prepack	examples/build.cfg	/^function do_prepack {$/;"	f
MyPackage	examples/check	/^package MyPackage;$/;"	p
TCP	examples/check	/^sub TCP$/;"	s
get	examples/check	/^sub get$/;"	s
parse_conf	examples/check	/^sub parse_conf$/;"	s
process_request	examples/check	/^sub process_request$/;"	s
regex	examples/check	/^sub regex$/;"	s
check	examples/haproxy.init	/^check() {$/;"	f
condrestart	examples/haproxy.init	/^condrestart() {$/;"	f
reload	examples/haproxy.init	/^reload() {$/;"	f
restart	examples/haproxy.init	/^restart() {$/;"	f
rhstatus	examples/haproxy.init	/^rhstatus() {$/;"	f
start	examples/haproxy.init	/^start() {$/;"	f
stop	examples/haproxy.init	/^stop() {$/;"	f
HiLink	examples/haproxy.vim	/^	command -nargs=+ HiLink hi def link <args>$/;"	c
HiLink	examples/haproxy.vim	/^	command -nargs=+ HiLink hi link <args>$/;"	c
b:current_syntax	examples/haproxy.vim	/^let b:current_syntax = "haproxy"$/;"	v
do_status	examples/init.haproxy	/^function do_status {$/;"	f
do_stop	examples/init.haproxy	/^function do_stop {$/;"	f
do_conf	examples/init.haproxy.flx0	/^function do_conf {$/;"	f
do_help	examples/init.haproxy.flx0	/^function do_help {$/;"	f
fct_begin_section	examples/init.haproxy.flx0	/^function fct_begin_section {$/;"	f
getRawStat	examples/stats_haproxy.sh	/^getRawStat ()$/;"	f
getStat	examples/stats_haproxy.sh	/^getStat ()$/;"	f
printUsage	examples/stats_haproxy.sh	/^printUsage ()$/;"	f
showList	examples/stats_haproxy.sh	/^showList ()$/;"	f
hap_cacheline_size	hash/hash.c	/^unsigned int hap_cacheline_size = 32;$/;"	v
hap_hash_find	hash/hash.c	/^void hap_hash_find(hash_t *hash, unsigned int key, u_char *name, size_t len)$/;"	f
hap_hash_init	hash/hash.c	/^hash_t *hap_hash_init(hash_key_t *names, int nelts)$/;"	f
hap_hash_key	hash/hash.c	/^unsigned int hap_hash_key(u_char *data, size_t len)$/;"	f
hap_hash_key_lc	hash/hash.c	/^unsigned int hap_hash_key_lc(u_char *data, size_t len)$/;"	f
hap_hash_strlow	hash/hash.c	/^unsigned int hap_hash_strlow(u_char *dst, u_char *src, size_t n)$/;"	f
hap_strlow	hash/hash.c	/^void hap_strlow(u_char *dst, u_char *src, size_t n)$/;"	f
HASH_MAX_SIZE	hash/hash.h	6;"	d
_HAPROXY_HASH_H	hash/hash.h	2;"	d
buckets	hash/hash.h	/^	hash_elt_t     **buckets;$/;"	m	struct:__anon3
data	hash/hash.h	/^	u_char *data;$/;"	m	struct:__anon1
hap_align	hash/hash.h	8;"	d
hap_align_ptr	hash/hash.h	9;"	d
hap_hash	hash/hash.h	35;"	d
hap_tolower	hash/hash.h	36;"	d
hap_toupper	hash/hash.h	37;"	d
hash_elt_t	hash/hash.h	/^} hash_elt_t;$/;"	t	typeref:struct:__anon2
hash_key_t	hash/hash.h	/^} hash_key_t;$/;"	t	typeref:struct:__anon4
hash_t	hash/hash.h	/^} hash_t;$/;"	t	typeref:struct:__anon3
key	hash/hash.h	/^	str_t			 	 key;$/;"	m	struct:__anon4
key_hash	hash/hash.h	/^	unsigned int	     key_hash;$/;"	m	struct:__anon4
len	hash/hash.h	/^	size_t len;$/;"	m	struct:__anon1
len	hash/hash.h	/^	u_short		 len;$/;"	m	struct:__anon2
name	hash/hash.h	/^	u_char		 name[1];$/;"	m	struct:__anon2
size	hash/hash.h	/^	unsigned int	 size;$/;"	m	struct:__anon3
str_t	hash/hash.h	/^} str_t;$/;"	t	typeref:struct:__anon1
value	hash/hash.h	/^	void 				*value;$/;"	m	struct:__anon4
value	hash/hash.h	/^	void 		*value;$/;"	m	struct:__anon2
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
TBLCHKINT	include/common/appsession.h	7;"	d
_COMMON_APPSESS_H	include/common/appsession.h	2;"	d
app_pool	include/common/appsession.h	/^struct app_pool {$/;"	s
appsess	include/common/appsession.h	/^} appsess;$/;"	t	typeref:struct:appsessions
appsessions	include/common/appsession.h	/^typedef struct appsessions {$/;"	s
expire	include/common/appsession.h	/^	int   expire;		\/* next expiration time for this application session (in tick) *\/$/;"	m	struct:appsessions
hash_list	include/common/appsession.h	/^	struct list hash_list;$/;"	m	struct:appsessions	typeref:struct:appsessions::list
request_count	include/common/appsession.h	/^	unsigned long int request_count;$/;"	m	struct:appsessions
serverid	include/common/appsession.h	/^	char *serverid;$/;"	m	struct:appsessions
serverid	include/common/appsession.h	/^	struct pool_head *serverid;$/;"	m	struct:app_pool	typeref:struct:app_pool::pool_head
sessid	include/common/appsession.h	/^	char *sessid;$/;"	m	struct:appsessions
sessid	include/common/appsession.h	/^	struct pool_head *sessid;$/;"	m	struct:app_pool	typeref:struct:app_pool::pool_head
_COMMON_BASE64_H	include/common/base64.h	15;"	d
CFG_GLOBAL	include/common/cfgparse.h	33;"	d
CFG_LISTEN	include/common/cfgparse.h	34;"	d
CFG_NONE	include/common/cfgparse.h	32;"	d
CFG_PEERS	include/common/cfgparse.h	36;"	d
CFG_USERLIST	include/common/cfgparse.h	35;"	d
_COMMON_CFGPARSE_H	include/common/cfgparse.h	23;"	d
cfg_keyword	include/common/cfgparse.h	/^struct cfg_keyword {$/;"	s
cfg_kw_list	include/common/cfgparse.h	/^struct cfg_kw_list {$/;"	s
kw	include/common/cfgparse.h	/^	const char *kw;                         \/* the keyword itself *\/$/;"	m	struct:cfg_keyword
kw	include/common/cfgparse.h	/^	struct cfg_keyword kw[VAR_ARRAY];$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::cfg_keyword
list	include/common/cfgparse.h	/^	struct list list;$/;"	m	struct:cfg_kw_list	typeref:struct:cfg_kw_list::list
parse	include/common/cfgparse.h	/^	int (*parse)(                           \/* 0=OK, <0=Alert, >0=Warning *\/$/;"	m	struct:cfg_keyword
section	include/common/cfgparse.h	/^	int section;                            \/* section type for this keyword *\/$/;"	m	struct:cfg_keyword
BITS_PER_INT	include/common/compat.h	34;"	d
F_SETPIPE_SZ	include/common/compat.h	74;"	d
IP_FREEBIND	include/common/compat.h	86;"	d
IP_TRANSPARENT	include/common/compat.h	89;"	d
MAXPATHLEN	include/common/compat.h	69;"	d
MSG_DONTWAIT	include/common/compat.h	59;"	d
MSG_MORE	include/common/compat.h	64;"	d
MSG_NOSIGNAL	include/common/compat.h	52;"	d
SHUT_RD	include/common/compat.h	43;"	d
SHUT_WR	include/common/compat.h	47;"	d
SO_REUSEPORT	include/common/compat.h	100;"	d
SO_REUSEPORT	include/common/compat.h	102;"	d
TCP_NODELAY	include/common/compat.h	39;"	d
_COMMON_COMPAT_H	include/common/compat.h	23;"	d
REGPRM1	include/common/compiler.h	46;"	d
REGPRM1	include/common/compiler.h	48;"	d
REGPRM2	include/common/compiler.h	54;"	d
REGPRM2	include/common/compiler.h	56;"	d
REGPRM3	include/common/compiler.h	62;"	d
REGPRM3	include/common/compiler.h	64;"	d
VAR_ARRAY	include/common/compiler.h	31;"	d
VAR_ARRAY	include/common/compiler.h	33;"	d
_COMMON_COMPILER_H	include/common/compiler.h	23;"	d
__builtin_expect	include/common/compiler.h	89;"	d
forceinline	include/common/compiler.h	74;"	d
forceinline	include/common/compiler.h	76;"	d
likely	include/common/compiler.h	101;"	d
likely	include/common/compiler.h	90;"	d
likely	include/common/compiler.h	94;"	d
unlikely	include/common/compiler.h	102;"	d
unlikely	include/common/compiler.h	91;"	d
unlikely	include/common/compiler.h	95;"	d
CALLOC	include/common/config.h	53;"	d
CALLOC	include/common/config.h	55;"	d
CONFIG_HAP_MEM_OPTIM	include/common/config.h	40;"	d
FREE	include/common/config.h	59;"	d
FREE	include/common/config.h	61;"	d
MALLOC	include/common/config.h	47;"	d
MALLOC	include/common/config.h	49;"	d
SCHEDULER_RESOLUTION	include/common/config.h	33;"	d
_COMMON_CONFIG_H	include/common/config.h	23;"	d
ABORT_NOW	include/common/debug.h	42;"	d
DPRINTF	include/common/debug.h	28;"	d
DPRINTF	include/common/debug.h	30;"	d
FSM_PRINTF	include/common/debug.h	34;"	d
FSM_PRINTF	include/common/debug.h	36;"	d
TRACE	include/common/debug.h	48;"	d
_COMMON_DEBUG_H	include/common/debug.h	23;"	d
BUFSIZE	include/common/defaults.h	35;"	d
CAPTURE_LEN	include/common/defaults.h	44;"	d
CHK_CONNTIME	include/common/defaults.h	127;"	d
CONN_RETRIES	include/common/defaults.h	125;"	d
COOKIE_DELIM	include/common/defaults.h	116;"	d
COOKIE_DELIM_DATE	include/common/defaults.h	122;"	d
DEFAULT_MAXCONN	include/common/defaults.h	156;"	d
DEFAULT_MAXCONN	include/common/defaults.h	159;"	d
DEFAULT_MAXCONN	include/common/defaults.h	160;"	d
DEF_CHECK_REQ	include/common/defaults.h	131;"	d
DEF_CHKINTR	include/common/defaults.h	128;"	d
DEF_FALLTIME	include/common/defaults.h	129;"	d
DEF_HANA_ERRLIMIT	include/common/defaults.h	137;"	d
DEF_HANA_ONERR	include/common/defaults.h	136;"	d
DEF_LDAP_CHECK_REQ	include/common/defaults.h	133;"	d
DEF_REDIS_CHECK_REQ	include/common/defaults.h	134;"	d
DEF_RISETIME	include/common/defaults.h	130;"	d
DEF_SMTP_CHECK_REQ	include/common/defaults.h	132;"	d
DEF_XFORWARDFOR_HDR	include/common/defaults.h	140;"	d
DEF_XORIGINALTO_HDR	include/common/defaults.h	143;"	d
HCHK_DESC_LEN	include/common/defaults.h	195;"	d
LINESIZE	include/common/defaults.h	48;"	d
MAXREWRITE	include/common/defaults.h	40;"	d
MAX_HDR_HISTORY	include/common/defaults.h	68;"	d
MAX_HOSTNAME_LEN	include/common/defaults.h	190;"	d
MAX_HTTP_HDR	include/common/defaults.h	63;"	d
MAX_LINE_ARGS	include/common/defaults.h	52;"	d
MAX_MATCH	include/common/defaults.h	58;"	d
MAX_POLL_EVENTS	include/common/defaults.h	109;"	d
MAX_READ_POLL_LOOPS	include/common/defaults.h	74;"	d
MAX_SIGNAL	include/common/defaults.h	185;"	d
MAX_STATS_ARGS	include/common/defaults.h	55;"	d
MAX_WRITE_POLL_LOOPS	include/common/defaults.h	90;"	d
MIN_RECV_AT_ONCE_ENOUGH	include/common/defaults.h	83;"	d
MIN_RET_FOR_READ_LOOP	include/common/defaults.h	97;"	d
MIN_SPLICE_FORWARD	include/common/defaults.h	103;"	d
REQURI_LEN	include/common/defaults.h	43;"	d
SRV_CHK_INTER_THRES	include/common/defaults.h	170;"	d
STATS_VERSION_STRING	include/common/defaults.h	178;"	d
_COMMON_DEFAULTS_H	include/common/defaults.h	23;"	d
EPOLLERR	include/common/epoll.h	57;"	d
EPOLLET	include/common/epoll.h	60;"	d
EPOLLHUP	include/common/epoll.h	58;"	d
EPOLLIN	include/common/epoll.h	54;"	d
EPOLLONESHOT	include/common/epoll.h	59;"	d
EPOLLOUT	include/common/epoll.h	56;"	d
EPOLLPRI	include/common/epoll.h	55;"	d
EPOLL_CTL_ADD	include/common/epoll.h	47;"	d
EPOLL_CTL_DEL	include/common/epoll.h	48;"	d
EPOLL_CTL_MOD	include/common/epoll.h	49;"	d
_COMMON_EPOLL_H	include/common/epoll.h	30;"	d
__NR_epoll_create	include/common/epoll.h	85;"	d
__NR_epoll_ctl	include/common/epoll.h	86;"	d
__NR_epoll_wait	include/common/epoll.h	87;"	d
data	include/common/epoll.h	/^	} data;$/;"	m	struct:epoll_event	typeref:union:epoll_event::__anon100
epoll_event	include/common/epoll.h	/^struct epoll_event {$/;"	s
events	include/common/epoll.h	/^	uint32_t events;$/;"	m	struct:epoll_event
fd	include/common/epoll.h	/^		int fd;$/;"	m	union:epoll_event::__anon100
ptr	include/common/epoll.h	/^		void *ptr;$/;"	m	union:epoll_event::__anon100
u32	include/common/epoll.h	/^		uint32_t u32;$/;"	m	union:epoll_event::__anon100
u64	include/common/epoll.h	/^		uint64_t u64;$/;"	m	union:epoll_event::__anon100
ERR_ABORT	include/common/errors.h	34;"	d
ERR_ALERT	include/common/errors.h	36;"	d
ERR_CODE	include/common/errors.h	38;"	d
ERR_FATAL	include/common/errors.h	33;"	d
ERR_NONE	include/common/errors.h	31;"	d
ERR_RETRYABLE	include/common/errors.h	32;"	d
ERR_WARN	include/common/errors.h	35;"	d
PE_ARG_INVC	include/common/errors.h	/^	PE_ARG_INVC,      \/* invalid char in argument (pointer not provided) *\/$/;"	e	enum:__anon97
PE_ARG_INVC_PTR	include/common/errors.h	/^	PE_ARG_INVC_PTR,  \/* invalid char in argument (pointer provided) *\/$/;"	e	enum:__anon97
PE_ARG_MISSING	include/common/errors.h	/^	PE_ARG_MISSING,   \/* mandatory argument not provided *\/$/;"	e	enum:__anon97
PE_ARG_NOT_FOUND	include/common/errors.h	/^	PE_ARG_NOT_FOUND, \/* argument references something not found *\/$/;"	e	enum:__anon97
PE_ARG_NOT_USED	include/common/errors.h	/^	PE_ARG_NOT_USED,  \/* argument provided cannot be used *\/$/;"	e	enum:__anon97
PE_ENUM_OOR	include/common/errors.h	/^	PE_ENUM_OOR,      \/* enum data out of allowed range *\/$/;"	e	enum:__anon97
PE_EXIST	include/common/errors.h	/^	PE_EXIST,         \/* trying to create something which already exists *\/$/;"	e	enum:__anon97
PE_NONE	include/common/errors.h	/^	PE_NONE = 0,      \/* no error *\/$/;"	e	enum:__anon97
_COMMON_ERRORS_H	include/common/errors.h	23;"	d
DEBUG	include/common/logging.h	/^	DEBUG,$/;"	e	enum:__anon99
ERROR	include/common/logging.h	/^	ERROR,$/;"	e	enum:__anon99
FATAL	include/common/logging.h	/^	FATAL$/;"	e	enum:__anon99
INFO	include/common/logging.h	/^	INFO,$/;"	e	enum:__anon99
TRACE	include/common/logging.h	/^	TRACE = 0,$/;"	e	enum:__anon99
WARN	include/common/logging.h	/^	WARN,$/;"	e	enum:__anon99
_COMMON_LOGGING_H	include/common/logging.h	2;"	d
MEM_F_SHARED	include/common/memory.h	117;"	d
_COMMON_MEMORY_H	include/common/memory.h	23;"	d
allocated	include/common/memory.h	/^	unsigned int allocated;	\/* how many chunks have been allocated *\/$/;"	m	struct:pool_head
flags	include/common/memory.h	/^	unsigned int flags;	\/* MEM_F_* *\/$/;"	m	struct:pool_head
free_list	include/common/memory.h	/^	void **free_list;$/;"	m	struct:pool_head
limit	include/common/memory.h	/^	unsigned int limit;	\/* hard limit on the number of chunks *\/$/;"	m	struct:pool_head
list	include/common/memory.h	/^	struct list list;	\/* list of all known pools *\/$/;"	m	struct:pool_head	typeref:struct:pool_head::list
minavail	include/common/memory.h	/^	unsigned int minavail;	\/* how many chunks are expected to be used *\/$/;"	m	struct:pool_head
name	include/common/memory.h	/^	char name[12];		\/* name of the pool *\/$/;"	m	struct:pool_head
pool_alloc	include/common/memory.h	69;"	d
pool_alloc	include/common/memory.h	95;"	d
pool_alloc2	include/common/memory.h	173;"	d
pool_alloc_from	include/common/memory.h	35;"	d
pool_destroy	include/common/memory.h	/^static inline void pool_destroy(void **pool)$/;"	f
pool_free	include/common/memory.h	88;"	d
pool_free	include/common/memory.h	96;"	d
pool_free2	include/common/memory.h	194;"	d
pool_free_to	include/common/memory.h	55;"	d
pool_head	include/common/memory.h	/^struct pool_head {$/;"	s
size	include/common/memory.h	/^	unsigned int size;	\/* chunk size *\/$/;"	m	struct:pool_head
used	include/common/memory.h	/^	unsigned int used;	\/* how many chunks are currently in use *\/$/;"	m	struct:pool_head
users	include/common/memory.h	/^	unsigned int users;	\/* number of pools sharing this zone *\/$/;"	m	struct:pool_head
DLIST_ADD	include/common/mini-clist.h	71;"	d
DLIST_DEL	include/common/mini-clist.h	74;"	d
FOREACH_ITEM	include/common/mini-clist.h	154;"	d
FOREACH_ITEM_SAFE	include/common/mini-clist.h	166;"	d
LIST_ADD	include/common/mini-clist.h	111;"	d
LIST_ADDQ	include/common/mini-clist.h	114;"	d
LIST_DEL	include/common/mini-clist.h	117;"	d
LIST_ELEM	include/common/mini-clist.h	124;"	d
LIST_HEAD	include/common/mini-clist.h	52;"	d
LIST_HEAD	include/common/mini-clist.h	56;"	d
LIST_HEAD_INIT	include/common/mini-clist.h	60;"	d
LIST_INIT	include/common/mini-clist.h	53;"	d
LIST_INIT	include/common/mini-clist.h	58;"	d
LIST_ISEMPTY	include/common/mini-clist.h	127;"	d
LIST_NEXT	include/common/mini-clist.h	134;"	d
LIST_NEXT	include/common/mini-clist.h	54;"	d
LIST_PREV	include/common/mini-clist.h	141;"	d
_COMMON_MINI_CLIST_H	include/common/mini-clist.h	8;"	d
bref	include/common/mini-clist.h	/^struct bref {$/;"	s
cond	include/common/mini-clist.h	/^	void *cond;$/;"	m	struct:cond_wordlist
cond_wordlist	include/common/mini-clist.h	/^struct cond_wordlist {$/;"	s
foreach_dlist_item	include/common/mini-clist.h	94;"	d
foreach_dlist_item_cst	include/common/mini-clist.h	88;"	d
list	include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:cond_wordlist	typeref:struct:cond_wordlist::list
list	include/common/mini-clist.h	/^	struct list list;$/;"	m	struct:wordlist	typeref:struct:wordlist::list
list	include/common/mini-clist.h	/^struct list {$/;"	s
list_for_each_entry	include/common/mini-clist.h	182;"	d
list_for_each_entry_safe	include/common/mini-clist.h	195;"	d
n	include/common/mini-clist.h	/^    struct list *n;	\/* next *\/$/;"	m	struct:list	typeref:struct:list::list
p	include/common/mini-clist.h	/^    struct list *p;	\/* prev *\/$/;"	m	struct:list	typeref:struct:list::list
ref	include/common/mini-clist.h	/^	struct list *ref; \/* pointer to the target's list entry *\/$/;"	m	struct:bref	typeref:struct:bref::list
s	include/common/mini-clist.h	/^	char *s;$/;"	m	struct:cond_wordlist
s	include/common/mini-clist.h	/^	char *s;$/;"	m	struct:wordlist
users	include/common/mini-clist.h	/^	struct list users;$/;"	m	struct:bref	typeref:struct:bref::list
while_dlist_item	include/common/mini-clist.h	103;"	d
wordlist	include/common/mini-clist.h	/^struct wordlist {$/;"	s
RB_BLACK	include/common/rbtree.h	107;"	d
RB_RED	include/common/rbtree.h	106;"	d
RB_ROOT	include/common/rbtree.h	124;"	d
_LINUX_RBTREE_H	include/common/rbtree.h	95;"	d
container_of	include/common/rbtree.h	118;"	d
offsetof	include/common/rbtree.h	121;"	d
rb_color	include/common/rbtree.h	/^	int rb_color;$/;"	m	struct:rb_node
rb_entry	include/common/rbtree.h	125;"	d
rb_left	include/common/rbtree.h	/^	struct rb_node *rb_left;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node
rb_link_node	include/common/rbtree.h	/^static inline void rb_link_node(struct rb_node * node, struct rb_node * parent,$/;"	f
rb_node	include/common/rbtree.h	/^	struct rb_node *rb_node;$/;"	m	struct:rb_root	typeref:struct:rb_root::rb_node
rb_node	include/common/rbtree.h	/^struct rb_node$/;"	s
rb_parent	include/common/rbtree.h	/^	struct rb_node *rb_parent;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node
rb_right	include/common/rbtree.h	/^	struct rb_node *rb_right;$/;"	m	struct:rb_node	typeref:struct:rb_node::rb_node
rb_root	include/common/rbtree.h	/^struct rb_root$/;"	s
ACT_ALLOW	include/common/regex.h	35;"	d
ACT_DENY	include/common/regex.h	38;"	d
ACT_PASS	include/common/regex.h	39;"	d
ACT_REMOVE	include/common/regex.h	37;"	d
ACT_REPLACE	include/common/regex.h	36;"	d
ACT_SETBE	include/common/regex.h	41;"	d
ACT_TARPIT	include/common/regex.h	40;"	d
_COMMON_REGEX_H	include/common/regex.h	23;"	d
action	include/common/regex.h	/^    int action;				\/* ACT_ALLOW, ACT_REPLACE, ACT_REMOVE, ACT_DENY *\/$/;"	m	struct:hdr_exp
cond	include/common/regex.h	/^    void *cond;				\/* a possible condition or NULL *\/$/;"	m	struct:hdr_exp
hdr_exp	include/common/regex.h	/^struct hdr_exp {$/;"	s
next	include/common/regex.h	/^    struct hdr_exp *next;$/;"	m	struct:hdr_exp	typeref:struct:hdr_exp::hdr_exp
preg	include/common/regex.h	/^    const regex_t *preg;		\/* expression to look for *\/$/;"	m	struct:hdr_exp
replace	include/common/regex.h	/^    const char *replace;		\/* expression to set instead *\/$/;"	m	struct:hdr_exp
SESSION_HASH_H	include/common/sessionhash.h	2;"	d
TABLEMASK	include/common/sessionhash.h	21;"	d
TABLESHIFT	include/common/sessionhash.h	18;"	d
TABLESIZE	include/common/sessionhash.h	20;"	d
appsession_hash	include/common/sessionhash.h	/^struct appsession_hash$/;"	s
as_hash_for_each_entry_safe	include/common/sessionhash.h	58;"	d
destroy	include/common/sessionhash.h	/^	void (*destroy)(appsess *);$/;"	m	struct:appsession_hash
table	include/common/sessionhash.h	/^	struct list *table;$/;"	m	struct:appsession_hash	typeref:struct:appsession_hash::list
SPLICE_F_MORE	include/common/splice.h	47;"	d
SPLICE_F_MOVE	include/common/splice.h	39;"	d
SPLICE_F_NONBLOCK	include/common/splice.h	43;"	d
_COMMON_SPLICE_H	include/common/splice.h	24;"	d
__NR_splice	include/common/splice.h	62;"	d
DAY	include/common/standard.h	483;"	d
HOUR	include/common/standard.h	482;"	d
LBOUND	include/common/standard.h	49;"	d
LIM2A0	include/common/standard.h	164;"	d
LIM2A1	include/common/standard.h	165;"	d
LIM2A2	include/common/standard.h	166;"	d
LIM2A3	include/common/standard.h	167;"	d
LIM2A4	include/common/standard.h	168;"	d
LIM2A5	include/common/standard.h	169;"	d
LIM2A6	include/common/standard.h	170;"	d
LIM2A7	include/common/standard.h	171;"	d
LIM2A8	include/common/standard.h	172;"	d
LIM2A9	include/common/standard.h	173;"	d
LLONG_MAX	include/common/standard.h	35;"	d
LLONG_MIN	include/common/standard.h	36;"	d
MINUTE	include/common/standard.h	481;"	d
POWEROF2	include/common/standard.h	53;"	d
SEC	include/common/standard.h	480;"	d
STD_OP_EQ	include/common/standard.h	/^	STD_OP_EQ = 2, STD_OP_NE = 3,$/;"	e	enum:__anon98
STD_OP_GE	include/common/standard.h	/^	STD_OP_GE = 4, STD_OP_LT = 5,$/;"	e	enum:__anon98
STD_OP_GT	include/common/standard.h	/^	STD_OP_LE = 0, STD_OP_GT = 1,$/;"	e	enum:__anon98
STD_OP_LE	include/common/standard.h	/^	STD_OP_LE = 0, STD_OP_GT = 1,$/;"	e	enum:__anon98
STD_OP_LT	include/common/standard.h	/^	STD_OP_GE = 4, STD_OP_LT = 5,$/;"	e	enum:__anon98
STD_OP_NE	include/common/standard.h	/^	STD_OP_EQ = 2, STD_OP_NE = 3,$/;"	e	enum:__anon98
TIME_UNIT_DAY	include/common/standard.h	477;"	d
TIME_UNIT_HOUR	include/common/standard.h	476;"	d
TIME_UNIT_MASK	include/common/standard.h	478;"	d
TIME_UNIT_MIN	include/common/standard.h	475;"	d
TIME_UNIT_MS	include/common/standard.h	473;"	d
TIME_UNIT_S	include/common/standard.h	474;"	d
TIME_UNIT_US	include/common/standard.h	472;"	d
U2A0	include/common/standard.h	128;"	d
U2A1	include/common/standard.h	129;"	d
U2A2	include/common/standard.h	130;"	d
U2A3	include/common/standard.h	131;"	d
U2A4	include/common/standard.h	132;"	d
U2A5	include/common/standard.h	133;"	d
U2A6	include/common/standard.h	134;"	d
U2A7	include/common/standard.h	135;"	d
U2A8	include/common/standard.h	136;"	d
U2A9	include/common/standard.h	137;"	d
U2H0	include/common/standard.h	140;"	d
U2H1	include/common/standard.h	141;"	d
U2H2	include/common/standard.h	142;"	d
U2H3	include/common/standard.h	143;"	d
U2H4	include/common/standard.h	144;"	d
U2H5	include/common/standard.h	145;"	d
U2H6	include/common/standard.h	146;"	d
U2H7	include/common/standard.h	147;"	d
U2H8	include/common/standard.h	148;"	d
U2H9	include/common/standard.h	149;"	d
UBOUND	include/common/standard.h	46;"	d
ULLONG_MAX	include/common/standard.h	40;"	d
_COMMON_STANDARD_H	include/common/standard.h	23;"	d
__full_hash	include/common/standard.h	/^static inline unsigned int __full_hash(unsigned int a)$/;"	f
__read_uint	include/common/standard.h	/^static inline unsigned int __read_uint(const char **s, const char *end)$/;"	f
__str2ui	include/common/standard.h	/^static inline unsigned int __str2ui(const char *s)$/;"	f
__str2uic	include/common/standard.h	/^static inline unsigned int __str2uic(const char *s)$/;"	f
__strl2ui	include/common/standard.h	/^static inline unsigned int __strl2ui(const char *s, int len)$/;"	f
__strl2uic	include/common/standard.h	/^static inline unsigned int __strl2uic(const char *s, int len)$/;"	f
alltrim	include/common/standard.h	/^static inline char *alltrim(char *s, char c) {$/;"	f
cut_crlf	include/common/standard.h	/^static inline char *cut_crlf(char *s) {$/;"	f
div64_32	include/common/standard.h	/^static inline unsigned int div64_32(unsigned long long o1, unsigned int o2)$/;"	f
fddebug	include/common/standard.h	712;"	d
get_addr_len	include/common/standard.h	/^static inline int get_addr_len(const struct sockaddr_storage *addr)$/;"	f
get_gmtime	include/common/standard.h	/^static inline void get_gmtime(const time_t now, struct tm *tm)$/;"	f
get_host_port	include/common/standard.h	/^static inline int get_host_port(struct sockaddr_storage *addr)$/;"	f
get_localtime	include/common/standard.h	/^static inline void get_localtime(const time_t now, struct tm *tm)$/;"	f
get_net_port	include/common/standard.h	/^static inline int get_net_port(struct sockaddr_storage *addr)$/;"	f
is_addr	include/common/standard.h	/^static inline int is_addr(struct sockaddr_storage *addr)$/;"	f
ltrim	include/common/standard.h	/^static inline char *ltrim(char *s, char c) {$/;"	f
mul32hi	include/common/standard.h	/^static inline unsigned int mul32hi(unsigned int a, unsigned int b)$/;"	f
rtrim	include/common/standard.h	/^static inline char *rtrim(char *s, char c) {$/;"	f
set_host_port	include/common/standard.h	/^static inline int set_host_port(struct sockaddr_storage *addr, int port)$/;"	f
set_net_port	include/common/standard.h	/^static inline int set_net_port(struct sockaddr_storage *addr, int port)$/;"	f
ultoa	include/common/standard.h	/^static inline const char *ultoa(unsigned long n)$/;"	f
_COMMON_SYSCALL_H	include/common/syscall.h	25;"	d
__NR_epoll_create	include/common/syscall.h	100;"	d
__NR_epoll_create	include/common/syscall.h	104;"	d
__NR_epoll_create	include/common/syscall.h	88;"	d
__NR_epoll_create	include/common/syscall.h	92;"	d
__NR_epoll_create	include/common/syscall.h	96;"	d
__NR_epoll_ctl	include/common/syscall.h	101;"	d
__NR_epoll_ctl	include/common/syscall.h	105;"	d
__NR_epoll_ctl	include/common/syscall.h	89;"	d
__NR_epoll_ctl	include/common/syscall.h	93;"	d
__NR_epoll_ctl	include/common/syscall.h	97;"	d
__NR_epoll_wait	include/common/syscall.h	102;"	d
__NR_epoll_wait	include/common/syscall.h	106;"	d
__NR_epoll_wait	include/common/syscall.h	90;"	d
__NR_epoll_wait	include/common/syscall.h	94;"	d
__NR_epoll_wait	include/common/syscall.h	98;"	d
__NR_splice	include/common/syscall.h	115;"	d
__NR_splice	include/common/syscall.h	117;"	d
__NR_splice	include/common/syscall.h	119;"	d
__NR_splice	include/common/syscall.h	121;"	d
__NR_splice	include/common/syscall.h	123;"	d
_syscall1	include/common/syscall.h	39;"	d
_syscall2	include/common/syscall.h	46;"	d
_syscall3	include/common/syscall.h	53;"	d
_syscall4	include/common/syscall.h	60;"	d
_syscall5	include/common/syscall.h	67;"	d
_syscall6	include/common/syscall.h	74;"	d
_COMMON_TEMPLATE_H	include/common/template.h	23;"	d
MS_TO_TICKS	include/common/ticks.h	63;"	d
TICKS_TO_MS	include/common/ticks.h	64;"	d
TICK_ETERNITY	include/common/ticks.h	58;"	d
_COMMON_TICKS_H	include/common/ticks.h	53;"	d
tick_add	include/common/ticks.h	/^static inline int tick_add(int now, int timeout)$/;"	f
tick_add_ifset	include/common/ticks.h	/^static inline int tick_add_ifset(int now, int timeout)$/;"	f
tick_first	include/common/ticks.h	/^static inline int tick_first(int t1, int t2)$/;"	f
tick_first_2nz	include/common/ticks.h	/^static inline int tick_first_2nz(int t1, int t2)$/;"	f
tick_is_expired	include/common/ticks.h	/^static inline int tick_is_expired(int timer, int now)$/;"	f
tick_is_le	include/common/ticks.h	/^static inline int tick_is_le(int t1, int t2)$/;"	f
tick_is_lt	include/common/ticks.h	/^static inline int tick_is_lt(int t1, int t2)$/;"	f
tick_isset	include/common/ticks.h	/^static inline int tick_isset(int expire)$/;"	f
tick_remain	include/common/ticks.h	/^static inline int tick_remain(int now, int exp)$/;"	f
MAX_DELAY_MS	include/common/time.h	45;"	d
MINTIME	include/common/time.h	49;"	d
SETNOW	include/common/time.h	50;"	d
TIME_ETERNITY	include/common/time.h	40;"	d
TV_ETERNITY	include/common/time.h	32;"	d
TV_ETERNITY_MS	include/common/time.h	37;"	d
_COMMON_TIME_H	include/common/time.h	23;"	d
__tv_add	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
__tv_add2	include/common/time.h	/^REGPRM2 static inline struct timeval *__tv_add2(struct timeval *tv, const struct timeval *inc)$/;"	f
__tv_add_ifset	include/common/time.h	/^REGPRM3 static inline int __tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
__tv_cmp	include/common/time.h	/^REGPRM2 static inline int __tv_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_from_ms	include/common/time.h	/^REGPRM2 static inline struct timeval * __tv_from_ms(struct timeval *tv, unsigned long ms)$/;"	f
__tv_iseq	include/common/time.h	/^REGPRM2 static inline int __tv_iseq(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_isge	include/common/time.h	/^REGPRM2 static inline int __tv_isge(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_isgt	include/common/time.h	/^REGPRM2 static inline int __tv_isgt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_isle	include/common/time.h	/^REGPRM2 static inline int __tv_isle(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_islt	include/common/time.h	/^REGPRM2 static inline int __tv_islt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_add	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)$/;"	f
__tv_ms_cmp	include/common/time.h	/^REGPRM2 static inline int __tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_cmp2	include/common/time.h	/^REGPRM2 static inline int __tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_elapsed	include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_le2	include/common/time.h	/^REGPRM2 static inline int __tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_remain	include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_ms_remain2	include/common/time.h	/^REGPRM2 static inline unsigned long __tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
__tv_remain	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
__tv_remain2	include/common/time.h	/^REGPRM3 static inline struct timeval *__tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
__tv_to_ms	include/common/time.h	/^REGPRM1 static inline unsigned long __tv_to_ms(const struct timeval *tv)$/;"	f
__usec_to_1024th	include/common/time.h	/^REGPRM1 static inline unsigned int __usec_to_1024th(unsigned int usec)$/;"	f
measure_idle	include/common/time.h	/^static inline void measure_idle()$/;"	f
tv_add	include/common/time.h	370;"	d
tv_add_ifset	include/common/time.h	388;"	d
tv_bound	include/common/time.h	509;"	d
tv_eternity	include/common/time.h	/^REGPRM1 static inline struct timeval *tv_eternity(struct timeval *tv)$/;"	f
tv_isbefore	include/common/time.h	483;"	d
tv_iseq	include/common/time.h	192;"	d
tv_iseternity	include/common/time.h	126;"	d
tv_isge	include/common/time.h	211;"	d
tv_isgt	include/common/time.h	200;"	d
tv_isle	include/common/time.h	231;"	d
tv_islt	include/common/time.h	221;"	d
tv_isset	include/common/time.h	131;"	d
tv_iszero	include/common/time.h	136;"	d
tv_min	include/common/time.h	494;"	d
tv_ms_add	include/common/time.h	462;"	d
tv_ms_cmp	include/common/time.h	245;"	d
tv_ms_cmp2	include/common/time.h	273;"	d
tv_ms_elapsed	include/common/time.h	325;"	d
tv_ms_le2	include/common/time.h	293;"	d
tv_ms_remain	include/common/time.h	342;"	d
tv_ms_remain2	include/common/time.h	357;"	d
tv_now	include/common/time.h	/^REGPRM1 static inline struct timeval *tv_now(struct timeval *tv)$/;"	f
tv_remain	include/common/time.h	422;"	d
tv_remain2	include/common/time.h	449;"	d
tv_zero	include/common/time.h	/^REGPRM1 static inline struct timeval *tv_zero(struct timeval *tv) {$/;"	f
MAX	include/common/tools.h	33;"	d
MAX_RANGE	include/common/tools.h	42;"	d
MID_RANGE	include/common/tools.h	39;"	d
MIN	include/common/tools.h	29;"	d
_COMMON_TOOLS_H	include/common/tools.h	23;"	d
STATS_DEFAULT_REALM	include/common/uri_auth.h	59;"	d
STATS_DEFAULT_REALM	include/common/uri_auth.h	61;"	d
STATS_DEFAULT_URI	include/common/uri_auth.h	52;"	d
STATS_DEFAULT_URI	include/common/uri_auth.h	54;"	d
ST_CONVDONE	include/common/uri_auth.h	33;"	d
ST_HIDEVER	include/common/uri_auth.h	29;"	d
ST_SHDESC	include/common/uri_auth.h	31;"	d
ST_SHLGNDS	include/common/uri_auth.h	32;"	d
ST_SHNODE	include/common/uri_auth.h	30;"	d
_COMMON_URI_AUTH_H	include/common/uri_auth.h	14;"	d
admin_rules	include/common/uri_auth.h	/^	struct list admin_rules;	\/* 'stats admin' rules (chained) *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list
auth_realm	include/common/uri_auth.h	/^	char *auth_realm;		\/* the realm reported to the client *\/$/;"	m	struct:uri_auth
cond	include/common/uri_auth.h	/^	struct acl_cond *cond;	\/* acl condition to meet *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::acl_cond
desc	include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth
flags	include/common/uri_auth.h	/^	int flags;			\/* some flags describing the statistics page *\/$/;"	m	struct:uri_auth
http_req_rules	include/common/uri_auth.h	/^	struct list http_req_rules;	\/* stats http-request rules : allow\/deny\/auth *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::list
list	include/common/uri_auth.h	/^	struct list list;	\/* list linked to from the proxy *\/$/;"	m	struct:stats_admin_rule	typeref:struct:stats_admin_rule::list
next	include/common/uri_auth.h	/^	struct stat_scope *next;	\/* next entry, NULL if none *\/$/;"	m	struct:stat_scope	typeref:struct:stat_scope::stat_scope
next	include/common/uri_auth.h	/^	struct uri_auth *next;		\/* Used at deinit() to build a list of unique elements *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::uri_auth
node	include/common/uri_auth.h	/^	char *node, *desc;		\/* node name & description reported in this stats *\/$/;"	m	struct:uri_auth
px_id	include/common/uri_auth.h	/^	char *px_id;			\/* proxy id *\/$/;"	m	struct:stat_scope
px_len	include/common/uri_auth.h	/^	int px_len;			\/* proxy name length *\/$/;"	m	struct:stat_scope
refresh	include/common/uri_auth.h	/^	int refresh;			\/* refresh interval for the browser (in seconds) *\/$/;"	m	struct:uri_auth
scope	include/common/uri_auth.h	/^	struct stat_scope *scope;	\/* linked list of authorized proxies *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::stat_scope
stat_scope	include/common/uri_auth.h	/^struct stat_scope {$/;"	s
stats_admin_rule	include/common/uri_auth.h	/^struct stats_admin_rule {$/;"	s
uri_auth	include/common/uri_auth.h	/^struct uri_auth {$/;"	s
uri_len	include/common/uri_auth.h	/^	int uri_len;			\/* the prefix length *\/$/;"	m	struct:uri_auth
uri_prefix	include/common/uri_auth.h	/^	char *uri_prefix;		\/* the prefix we want to match *\/$/;"	m	struct:uri_auth
userlist	include/common/uri_auth.h	/^	struct userlist *userlist;	\/* private userlist to emulate legacy "stats auth user:password" *\/$/;"	m	struct:uri_auth	typeref:struct:uri_auth::userlist
HAPROXY_DATE	include/common/version.h	64;"	d
HAPROXY_VERSION	include/common/version.h	58;"	d
PRODUCT_BRANCH	include/common/version.h	34;"	d
PRODUCT_BRANCH	include/common/version.h	36;"	d
PRODUCT_NAME	include/common/version.h	28;"	d
PRODUCT_NAME	include/common/version.h	30;"	d
PRODUCT_URL	include/common/version.h	40;"	d
PRODUCT_URL	include/common/version.h	42;"	d
PRODUCT_URL_DOC	include/common/version.h	52;"	d
PRODUCT_URL_DOC	include/common/version.h	54;"	d
PRODUCT_URL_UPD	include/common/version.h	46;"	d
PRODUCT_URL_UPD	include/common/version.h	48;"	d
_COMMON_VERSION_H	include/common/version.h	23;"	d
IP_ORIGADDRS	include/import/ip_tproxy.h	23;"	d
IP_RECVORIGADDRS	include/import/ip_tproxy.h	22;"	d
IP_TPROXY	include/import/ip_tproxy.h	38;"	d
ITP_APPLIED	include/import/ip_tproxy.h	58;"	d
ITP_CONNECT	include/import/ip_tproxy.h	52;"	d
ITP_ESTABLISHED	include/import/ip_tproxy.h	54;"	d
ITP_LISTEN	include/import/ip_tproxy.h	53;"	d
ITP_MARK	include/import/ip_tproxy.h	57;"	d
ITP_ONCE	include/import/ip_tproxy.h	56;"	d
ITP_UNIDIR	include/import/ip_tproxy.h	59;"	d
TPROXY_ALLOC	include/import/ip_tproxy.h	/^	TPROXY_ALLOC,$/;"	e	enum:__anon101
TPROXY_ASSIGN	include/import/ip_tproxy.h	/^	TPROXY_ASSIGN,$/;"	e	enum:__anon101
TPROXY_CONNECT	include/import/ip_tproxy.h	/^	TPROXY_CONNECT$/;"	e	enum:__anon101
TPROXY_FLAGS	include/import/ip_tproxy.h	/^	TPROXY_FLAGS,$/;"	e	enum:__anon101
TPROXY_QUERY	include/import/ip_tproxy.h	/^	TPROXY_QUERY,$/;"	e	enum:__anon101
TPROXY_UNASSIGN	include/import/ip_tproxy.h	/^	TPROXY_UNASSIGN,$/;"	e	enum:__anon101
TPROXY_VERSION	include/import/ip_tproxy.h	/^	TPROXY_VERSION = 0,$/;"	e	enum:__anon101
_IP_TPROXY_H	include/import/ip_tproxy.h	14;"	d
_in_args	include/import/ip_tproxy.h	/^	union _in_args {$/;"	u	struct:in_tproxy
addr	include/import/ip_tproxy.h	/^		struct in_tproxy_addr	addr;$/;"	m	union:in_tproxy::_in_args	typeref:struct:in_tproxy::_in_args::in_tproxy_addr
faddr	include/import/ip_tproxy.h	/^	struct in_addr	faddr;$/;"	m	struct:in_tproxy_addr	typeref:struct:in_tproxy_addr::in_addr
flags	include/import/ip_tproxy.h	/^		u_int32_t		flags;$/;"	m	union:in_tproxy::_in_args
fport	include/import/ip_tproxy.h	/^	u_int16_t	fport;$/;"	m	struct:in_tproxy_addr
in_origaddrs	include/import/ip_tproxy.h	/^struct in_origaddrs {$/;"	s
in_tproxy	include/import/ip_tproxy.h	/^struct in_tproxy {$/;"	s
in_tproxy_addr	include/import/ip_tproxy.h	/^struct in_tproxy_addr{$/;"	s
ioa_dstaddr	include/import/ip_tproxy.h	/^        struct in_addr ioa_dstaddr;$/;"	m	struct:in_origaddrs	typeref:struct:in_origaddrs::in_addr
ioa_dstport	include/import/ip_tproxy.h	/^        unsigned short int ioa_dstport;$/;"	m	struct:in_origaddrs
ioa_srcaddr	include/import/ip_tproxy.h	/^        struct in_addr ioa_srcaddr;$/;"	m	struct:in_origaddrs	typeref:struct:in_origaddrs::in_addr
ioa_srcport	include/import/ip_tproxy.h	/^        unsigned short int ioa_srcport;$/;"	m	struct:in_origaddrs
op	include/import/ip_tproxy.h	/^	u_int32_t op;$/;"	m	struct:in_tproxy
v	include/import/ip_tproxy.h	/^	} v;$/;"	m	struct:in_tproxy	typeref:union:in_tproxy::_in_args
version	include/import/ip_tproxy.h	/^		u_int32_t		version;$/;"	m	union:in_tproxy::_in_args
_PROTO_ACL_H	include/proto/acl.h	23;"	d
acl_neg	include/proto/acl.h	/^static inline int acl_neg(int res)$/;"	f
acl_pass	include/proto/acl.h	/^static inline int acl_pass(int res)$/;"	f
ARG1	include/proto/arg.h	36;"	d
ARG2	include/proto/arg.h	39;"	d
ARG3	include/proto/arg.h	42;"	d
ARG4	include/proto/arg.h	45;"	d
ARG5	include/proto/arg.h	48;"	d
ARG6	include/proto/arg.h	51;"	d
ARG7	include/proto/arg.h	54;"	d
ARGM	include/proto/arg.h	33;"	d
_PROTO_ARG_H	include/proto/arg.h	23;"	d
_PROTO_AUTH_H	include/proto/auth.h	14;"	d
_PROTO_BACKEND_H	include/proto/backend.h	23;"	d
srv_is_usable	include/proto/backend.h	/^static inline int srv_is_usable(int state, int weight)$/;"	f
_PROTO_BUFFERS_H	include/proto/buffers.h	23;"	d
b_adv	include/proto/buffers.h	/^static inline void b_adv(struct buffer *b, unsigned int adv)$/;"	f
b_ptr	include/proto/buffers.h	78;"	d
b_rew	include/proto/buffers.h	/^static inline void b_rew(struct buffer *b, unsigned int adv)$/;"	f
bi_avail	include/proto/buffers.h	/^static inline int bi_avail(const struct buffer *b)$/;"	f
bi_contig_data	include/proto/buffers.h	/^static inline int bi_contig_data(const struct buffer *b)$/;"	f
bi_end	include/proto/buffers.h	/^static inline char *bi_end(const struct buffer *b)$/;"	f
bi_erase	include/proto/buffers.h	/^static inline void bi_erase(struct buffer *buf)$/;"	f
bi_fast_delete	include/proto/buffers.h	/^static inline void bi_fast_delete(struct buffer *buf, int n)$/;"	f
bi_full	include/proto/buffers.h	/^static inline int bi_full(const struct buffer *b)$/;"	f
bi_ptr	include/proto/buffers.h	/^static inline char *bi_ptr(const struct buffer *b)$/;"	f
bi_putchk	include/proto/buffers.h	/^static inline int bi_putchk(struct buffer *buf, struct chunk *chunk)$/;"	f
bi_putstr	include/proto/buffers.h	/^static inline int bi_putstr(struct buffer *buf, const char *str)$/;"	f
bo_contig_data	include/proto/buffers.h	/^static inline int bo_contig_data(const struct buffer *b)$/;"	f
bo_end	include/proto/buffers.h	/^static inline char *bo_end(const struct buffer *b)$/;"	f
bo_getchr	include/proto/buffers.h	/^static inline int bo_getchr(struct buffer *buf)$/;"	f
bo_ptr	include/proto/buffers.h	/^static inline char *bo_ptr(const struct buffer *b)$/;"	f
bo_skip	include/proto/buffers.h	/^static inline void bo_skip(struct buffer *buf, int len)$/;"	f
buffer_abort	include/proto/buffers.h	/^static inline void buffer_abort(struct buffer *buf)$/;"	f
buffer_almost_full	include/proto/buffers.h	/^static inline int buffer_almost_full(const struct buffer *buf)$/;"	f
buffer_auto_close	include/proto/buffers.h	/^static inline void buffer_auto_close(struct buffer *buf)$/;"	f
buffer_auto_connect	include/proto/buffers.h	/^static inline void buffer_auto_connect(struct buffer *buf)$/;"	f
buffer_auto_read	include/proto/buffers.h	/^static inline void buffer_auto_read(struct buffer *buf)$/;"	f
buffer_check_timeouts	include/proto/buffers.h	/^static inline void buffer_check_timeouts(struct buffer *b)$/;"	f
buffer_contig_area	include/proto/buffers.h	/^static inline int buffer_contig_area(const struct buffer *buf, const char *start, int count)$/;"	f
buffer_contig_space	include/proto/buffers.h	/^static inline int buffer_contig_space(const struct buffer *buf)$/;"	f
buffer_contig_space_res	include/proto/buffers.h	/^static inline int buffer_contig_space_res(const struct buffer *buf)$/;"	f
buffer_contig_space_with_res	include/proto/buffers.h	/^static inline int buffer_contig_space_with_res(const struct buffer *buf, int res)$/;"	f
buffer_count	include/proto/buffers.h	/^static inline int buffer_count(const struct buffer *buf, const char *from, const char *to)$/;"	f
buffer_dont_close	include/proto/buffers.h	/^static inline void buffer_dont_close(struct buffer *buf)$/;"	f
buffer_dont_connect	include/proto/buffers.h	/^static inline void buffer_dont_connect(struct buffer *buf)$/;"	f
buffer_dont_read	include/proto/buffers.h	/^static inline void buffer_dont_read(struct buffer *buf)$/;"	f
buffer_empty	include/proto/buffers.h	/^static inline int buffer_empty(const struct buffer *buf)$/;"	f
buffer_erase	include/proto/buffers.h	/^static inline void buffer_erase(struct buffer *buf)$/;"	f
buffer_flush	include/proto/buffers.h	/^static inline void buffer_flush(struct buffer *buf)$/;"	f
buffer_init	include/proto/buffers.h	/^static inline void buffer_init(struct buffer *buf)$/;"	f
buffer_input_closed	include/proto/buffers.h	/^static inline int buffer_input_closed(struct buffer *buf)$/;"	f
buffer_install_hijacker	include/proto/buffers.h	/^static inline void buffer_install_hijacker(struct session *s,$/;"	f
buffer_len	include/proto/buffers.h	/^static inline int buffer_len(const struct buffer *buf)$/;"	f
buffer_max_len	include/proto/buffers.h	/^static inline int buffer_max_len(const struct buffer *buf)$/;"	f
buffer_not_empty	include/proto/buffers.h	/^static inline int buffer_not_empty(const struct buffer *buf)$/;"	f
buffer_output_closed	include/proto/buffers.h	/^static inline int buffer_output_closed(struct buffer *buf)$/;"	f
buffer_pending	include/proto/buffers.h	/^static inline int buffer_pending(const struct buffer *buf)$/;"	f
buffer_pointer	include/proto/buffers.h	/^static inline const char *buffer_pointer(const struct buffer *buf, const char *ptr)$/;"	f
buffer_realign	include/proto/buffers.h	/^static inline int buffer_realign(struct buffer *buf)$/;"	f
buffer_replace	include/proto/buffers.h	/^static inline int buffer_replace(struct buffer *b, char *pos, char *end, const char *str)$/;"	f
buffer_reserved	include/proto/buffers.h	/^static inline int buffer_reserved(const struct buffer *buf)$/;"	f
buffer_shutr_now	include/proto/buffers.h	/^static inline void buffer_shutr_now(struct buffer *buf)$/;"	f
buffer_shutw_now	include/proto/buffers.h	/^static inline void buffer_shutw_now(struct buffer *buf)$/;"	f
buffer_stop_hijack	include/proto/buffers.h	/^static inline void buffer_stop_hijack(struct buffer *buf)$/;"	f
buffer_total_space	include/proto/buffers.h	/^static inline int buffer_total_space(const struct buffer *buf)$/;"	f
buffer_work_area	include/proto/buffers.h	/^static inline int buffer_work_area(const struct buffer *buf, const char *end)$/;"	f
buffer_wrap_add	include/proto/buffers.h	/^static inline char *buffer_wrap_add(const struct buffer *buf, char *ptr)$/;"	f
buffer_wrap_sub	include/proto/buffers.h	/^static inline char *buffer_wrap_sub(const struct buffer *buf, char *ptr)$/;"	f
chunk_destroy	include/proto/buffers.h	/^static inline void chunk_destroy(struct chunk *chk) {$/;"	f
chunk_dup	include/proto/buffers.h	/^static inline char *chunk_dup(struct chunk *dst, const struct chunk *src) {$/;"	f
chunk_init	include/proto/buffers.h	/^static inline void chunk_init(struct chunk *chk, char *str, size_t size) {$/;"	f
chunk_initlen	include/proto/buffers.h	/^static inline int chunk_initlen(struct chunk *chk, char *str, size_t size, int len) {$/;"	f
chunk_initstr	include/proto/buffers.h	/^static inline void chunk_initstr(struct chunk *chk, char *str) {$/;"	f
chunk_reset	include/proto/buffers.h	/^static inline void chunk_reset(struct chunk *chk) {$/;"	f
chunk_strcpy	include/proto/buffers.h	/^static inline int chunk_strcpy(struct chunk *chk, const char *str) {$/;"	f
_PROTO_CHECKS_H	include/proto/checks.h	23;"	d
_PROTO_CTTPROXY_H	include/proto/cttproxy.h	24;"	d
STATS_TYPE_BE	include/proto/dumpstats.h	40;"	d
STATS_TYPE_FE	include/proto/dumpstats.h	39;"	d
STATS_TYPE_SO	include/proto/dumpstats.h	42;"	d
STATS_TYPE_SV	include/proto/dumpstats.h	41;"	d
STAT_ADMIN	include/proto/dumpstats.h	36;"	d
STAT_BOUND	include/proto/dumpstats.h	37;"	d
STAT_CLI_END	include/proto/dumpstats.h	46;"	d
STAT_CLI_GETREQ	include/proto/dumpstats.h	47;"	d
STAT_CLI_INIT	include/proto/dumpstats.h	45;"	d
STAT_CLI_OUTPUT	include/proto/dumpstats.h	48;"	d
STAT_CLI_O_CLR	include/proto/dumpstats.h	56;"	d
STAT_CLI_O_ERR	include/proto/dumpstats.h	54;"	d
STAT_CLI_O_INFO	include/proto/dumpstats.h	52;"	d
STAT_CLI_O_SESS	include/proto/dumpstats.h	53;"	d
STAT_CLI_O_TAB	include/proto/dumpstats.h	55;"	d
STAT_CLI_PRINT	include/proto/dumpstats.h	50;"	d
STAT_CLI_PROMPT	include/proto/dumpstats.h	49;"	d
STAT_FMT_CSV	include/proto/dumpstats.h	31;"	d
STAT_HIDE_DOWN	include/proto/dumpstats.h	34;"	d
STAT_NO_REFRESH	include/proto/dumpstats.h	35;"	d
STAT_SHOW_INFO	include/proto/dumpstats.h	33;"	d
STAT_SHOW_STAT	include/proto/dumpstats.h	32;"	d
_PROTO_DUMPSTATS_H	include/proto/dumpstats.h	24;"	d
EV_FD_CLO	include/proto/fd.h	79;"	d
EV_FD_CLR	include/proto/fd.h	74;"	d
EV_FD_COND_C	include/proto/fd.h	77;"	d
EV_FD_COND_S	include/proto/fd.h	76;"	d
EV_FD_ISSET	include/proto/fd.h	75;"	d
EV_FD_REM	include/proto/fd.h	78;"	d
EV_FD_SET	include/proto/fd.h	73;"	d
_PROTO_FD_H	include/proto/fd.h	23;"	d
fd_insert	include/proto/fd.h	/^static inline void fd_insert(int fd)$/;"	f
_PROTO_FREQ_CTR_H	include/proto/freq_ctr.h	23;"	d
rotate_freq_ctr	include/proto/freq_ctr.h	/^static inline void rotate_freq_ctr(struct freq_ctr *ctr)$/;"	f
rotate_freq_ctr_period	include/proto/freq_ctr.h	/^static inline void rotate_freq_ctr_period(struct freq_ctr_period *ctr,$/;"	f
update_freq_ctr	include/proto/freq_ctr.h	/^static inline void update_freq_ctr(struct freq_ctr *ctr, unsigned int inc)$/;"	f
update_freq_ctr_period	include/proto/freq_ctr.h	/^static inline void update_freq_ctr_period(struct freq_ctr_period *ctr,$/;"	f
_PROTO_FRONTEND_H	include/proto/frontend.h	23;"	d
_PROTO_HDR_IDX_H	include/proto/hdr_idx.h	23;"	d
hdr_idx_first_idx	include/proto/hdr_idx.h	/^static inline int hdr_idx_first_idx(struct hdr_idx *list)$/;"	f
hdr_idx_first_pos	include/proto/hdr_idx.h	/^static inline int hdr_idx_first_pos(struct hdr_idx *list)$/;"	f
hdr_idx_init	include/proto/hdr_idx.h	/^static inline void hdr_idx_init(struct hdr_idx *list)$/;"	f
hdr_idx_set_start	include/proto/hdr_idx.h	/^static inline void hdr_idx_set_start(struct hdr_idx *list, int len, int cr)$/;"	f
_PROTO_LB_CHASH_H	include/proto/lb_chash.h	23;"	d
_PROTO_LB_FAS_H	include/proto/lb_fas.h	23;"	d
_PROTO_LB_FWLC_H	include/proto/lb_fwlc.h	23;"	d
_PROTO_LB_FWRR_H	include/proto/lb_fwrr.h	23;"	d
_PROTO_LB_MAP_H	include/proto/lb_map.h	23;"	d
_PROTO_LOG_H	include/proto/log.h	24;"	d
_PROTO_PEERS_H	include/proto/peers.h	23;"	d
_PROTO_PIPE_H	include/proto/pipe.h	23;"	d
_PROTO_PORT_RANGE_H	include/proto/port_range.h	23;"	d
port_range_alloc_port	include/proto/port_range.h	/^static inline int port_range_alloc_port(struct port_range *range)$/;"	f
port_range_alloc_range	include/proto/port_range.h	/^static inline struct port_range *port_range_alloc_range(int n)$/;"	f
port_range_release_port	include/proto/port_range.h	/^static inline void port_range_release_port(struct port_range *range, int port)$/;"	f
HTTP_IS_CRLF	include/proto/proto_http.h	62;"	d
HTTP_IS_CTL	include/proto/proto_http.h	58;"	d
HTTP_IS_LWS	include/proto/proto_http.h	60;"	d
HTTP_IS_SEP	include/proto/proto_http.h	59;"	d
HTTP_IS_SPHT	include/proto/proto_http.h	61;"	d
HTTP_IS_TOKEN	include/proto/proto_http.h	63;"	d
HTTP_IS_VER_TOKEN	include/proto/proto_http.h	64;"	d
_PROTO_PROTO_HTTP_H	include/proto/proto_http.h	23;"	d
http_msg_move_end	include/proto/proto_http.h	115;"	d
_PROTO_PROTO_TCP_H	include/proto/proto_tcp.h	23;"	d
tcp_src_to_stktable_key	include/proto/proto_tcp.h	/^static inline struct stktable_key *tcp_src_to_stktable_key(struct session *s)$/;"	f
_PROTO_PROTO_UXST_H	include/proto/proto_uxst.h	23;"	d
_PROTO_PROTOCOLS_H	include/proto/protocols.h	23;"	d
_PROTO_PROXY_H	include/proto/proxy.h	23;"	d
proxy_inc_be_ctr	include/proto/proxy.h	/^static void inline proxy_inc_be_ctr(struct proxy *be)$/;"	f
proxy_inc_fe_conn_ctr	include/proto/proxy.h	/^static void inline proxy_inc_fe_conn_ctr(struct listener *l, struct proxy *fe)$/;"	f
proxy_inc_fe_req_ctr	include/proto/proxy.h	/^static void inline proxy_inc_fe_req_ctr(struct proxy *fe)$/;"	f
proxy_inc_fe_sess_ctr	include/proto/proxy.h	/^static void inline proxy_inc_fe_sess_ctr(struct listener *l, struct proxy *fe)$/;"	f
proxy_reset_timeouts	include/proto/proxy.h	/^static inline void proxy_reset_timeouts(struct proxy *proxy)$/;"	f
proxy_type_str	include/proto/proxy.h	/^static inline const char *proxy_type_str(struct proxy *proxy)$/;"	f
_PROTO_QUEUE_H	include/proto/queue.h	23;"	d
may_dequeue_tasks	include/proto/queue.h	/^static inline int may_dequeue_tasks(const struct server *s, const struct proxy *p) {$/;"	f
pendconn_from_px	include/proto/queue.h	/^static inline struct pendconn *pendconn_from_px(const struct proxy *px) {$/;"	f
pendconn_from_srv	include/proto/queue.h	/^static inline struct pendconn *pendconn_from_srv(const struct server *s) {$/;"	f
_PROTO_SAMPLE_H	include/proto/sample.h	24;"	d
_PROTO_SERVER_H	include/proto/server.h	23;"	d
srv_inc_sess_ctr	include/proto/server.h	/^static void inline srv_inc_sess_ctr(struct server *s)$/;"	f
_PROTO_SESSION_H	include/proto/session.h	23;"	d
session_add_srv_conn	include/proto/session.h	/^static void inline session_add_srv_conn(struct session *sess, struct server *srv)$/;"	f
session_del_srv_conn	include/proto/session.h	/^static void inline session_del_srv_conn(struct session *sess)$/;"	f
session_inc_http_err_ctr	include/proto/session.h	/^static void inline session_inc_http_err_ctr(struct session *s)$/;"	f
session_inc_http_req_ctr	include/proto/session.h	/^static void inline session_inc_http_req_ctr(struct session *s)$/;"	f
session_init_srv_conn	include/proto/session.h	/^static void inline session_init_srv_conn(struct session *sess)$/;"	f
session_start_counters	include/proto/session.h	/^static inline void session_start_counters(struct stktable *t, struct stksess *ts)$/;"	f
session_stop_backend_counters	include/proto/session.h	/^static inline void session_stop_backend_counters(struct session *s)$/;"	f
session_store_counters	include/proto/session.h	/^static inline void session_store_counters(struct session *s)$/;"	f
session_track_stkctr1	include/proto/session.h	/^static inline void session_track_stkctr1(struct session *s, struct stktable *t, struct stksess *ts)$/;"	f
session_track_stkctr2	include/proto/session.h	/^static inline void session_track_stkctr2(struct session *s, struct stktable *t, struct stksess *ts)$/;"	f
trace_term	include/proto/session.h	/^static void inline trace_term(struct session *s, unsigned int code)$/;"	f
signal_process_queue	include/proto/signal.h	/^static inline void signal_process_queue()$/;"	f
_PROTO_SOCK_RAW_H	include/proto/sock_raw.h	23;"	d
_PROTO_STICK_TABLE_H	include/proto/stick_table.h	24;"	d
stksess_kill_if_expired	include/proto/stick_table.h	/^static inline void stksess_kill_if_expired(struct stktable *t, struct stksess *ts)$/;"	f
stktable_alloc_data_type	include/proto/stick_table.h	/^static inline int stktable_alloc_data_type(struct stktable *t, int type, const char *sa)$/;"	f
stktable_data_cast	include/proto/stick_table.h	32;"	d
stktable_data_ptr	include/proto/stick_table.h	/^static inline void *stktable_data_ptr(struct stktable *t, struct stksess *ts, int type)$/;"	f
stktable_data_size	include/proto/stick_table.h	31;"	d
stktable_type_size	include/proto/stick_table.h	/^static inline int stktable_type_size(int type)$/;"	f
_PROTO_STREAM_INTERFACE_H	include/proto/stream_interface.h	23;"	d
clear_target	include/proto/stream_interface.h	/^static inline void clear_target(struct target *dest)$/;"	f
copy_target	include/proto/stream_interface.h	/^static inline struct target *copy_target(struct target *dest, struct target *src)$/;"	f
set_target_applet	include/proto/stream_interface.h	/^static inline void set_target_applet(struct target *dest, struct si_applet *a)$/;"	f
set_target_client	include/proto/stream_interface.h	/^static inline void set_target_client(struct target *dest, struct listener *l)$/;"	f
set_target_proxy	include/proto/stream_interface.h	/^static inline void set_target_proxy(struct target *dest, struct proxy *p)$/;"	f
set_target_server	include/proto/stream_interface.h	/^static inline void set_target_server(struct target *dest, struct server *s)$/;"	f
set_target_task	include/proto/stream_interface.h	/^static inline void set_target_task(struct target *dest, struct task *t)$/;"	f
si_chk_rcv	include/proto/stream_interface.h	/^static inline void si_chk_rcv(struct stream_interface *si)$/;"	f
si_chk_snd	include/proto/stream_interface.h	/^static inline void si_chk_snd(struct stream_interface *si)$/;"	f
si_connect	include/proto/stream_interface.h	/^static inline int si_connect(struct stream_interface *si)$/;"	f
si_ctrl	include/proto/stream_interface.h	/^static inline const struct protocol *si_ctrl(struct stream_interface *si)$/;"	f
si_data	include/proto/stream_interface.h	/^static inline const struct sock_ops *si_data(struct stream_interface *si)$/;"	f
si_data_close	include/proto/stream_interface.h	/^static inline void si_data_close(struct stream_interface *si)$/;"	f
si_fd	include/proto/stream_interface.h	/^static inline int si_fd(struct stream_interface *si)$/;"	f
si_get_from_addr	include/proto/stream_interface.h	/^static inline void si_get_from_addr(struct stream_interface *si)$/;"	f
si_get_to_addr	include/proto/stream_interface.h	/^static inline void si_get_to_addr(struct stream_interface *si)$/;"	f
si_shutr	include/proto/stream_interface.h	/^static inline void si_shutr(struct stream_interface *si)$/;"	f
si_shutw	include/proto/stream_interface.h	/^static inline void si_shutw(struct stream_interface *si)$/;"	f
si_update	include/proto/stream_interface.h	/^static inline void si_update(struct stream_interface *si)$/;"	f
stream_interface_prepare	include/proto/stream_interface.h	/^static inline void stream_interface_prepare(struct stream_interface *si, const struct sock_ops *ops)$/;"	f
target_client	include/proto/stream_interface.h	/^static inline struct listener *target_client(struct target *t)$/;"	f
target_match	include/proto/stream_interface.h	/^static inline int target_match(struct target *a, struct target *b)$/;"	f
target_srv	include/proto/stream_interface.h	/^static inline struct server *target_srv(struct target *t)$/;"	f
TIMER_LOOK_BACK	include/proto/task.h	78;"	d
_PROTO_TASK_H	include/proto/task.h	23;"	d
__task_unlink_rq	include/proto/task.h	/^static inline struct task *__task_unlink_rq(struct task *t)$/;"	f
__task_unlink_wq	include/proto/task.h	/^static inline struct task *__task_unlink_wq(struct task *t)$/;"	f
task_delete	include/proto/task.h	/^static inline struct task *task_delete(struct task *t)$/;"	f
task_free	include/proto/task.h	/^static inline void task_free(struct task *t)$/;"	f
task_in_rq	include/proto/task.h	/^static inline int task_in_rq(struct task *t)$/;"	f
task_in_wq	include/proto/task.h	/^static inline int task_in_wq(struct task *t)$/;"	f
task_init	include/proto/task.h	/^static inline struct task *task_init(struct task *t)$/;"	f
task_new	include/proto/task.h	/^static inline struct task *task_new(void)$/;"	f
task_queue	include/proto/task.h	/^static inline void task_queue(struct task *task)$/;"	f
task_schedule	include/proto/task.h	/^static inline void task_schedule(struct task *task, int when)$/;"	f
task_unlink_rq	include/proto/task.h	/^static inline struct task *task_unlink_rq(struct task *t)$/;"	f
task_unlink_wq	include/proto/task.h	/^static inline struct task *task_unlink_wq(struct task *t)$/;"	f
task_wakeup	include/proto/task.h	/^static inline struct task *task_wakeup(struct task *t, unsigned int f)$/;"	f
_PROTO_TEMPLATE_H	include/proto/template.h	23;"	d
ACL_COND_IF	include/types/acl.h	/^	ACL_COND_IF,		\/* positive condition (after 'if') *\/$/;"	e	enum:__anon83
ACL_COND_NONE	include/types/acl.h	/^	ACL_COND_NONE,		\/* no polarity set yet *\/$/;"	e	enum:__anon83
ACL_COND_UNLESS	include/types/acl.h	/^	ACL_COND_UNLESS,	\/* negative condition (after 'unless') *\/$/;"	e	enum:__anon83
ACL_HOOK_REQ_BE_HTTP_IN	include/types/acl.h	/^	ACL_HOOK_REQ_BE_HTTP_IN,$/;"	e	enum:__anon86
ACL_HOOK_REQ_BE_HTTP_OUT	include/types/acl.h	/^	ACL_HOOK_REQ_BE_HTTP_OUT,$/;"	e	enum:__anon86
ACL_HOOK_REQ_BE_SWITCH	include/types/acl.h	/^	ACL_HOOK_REQ_BE_SWITCH,$/;"	e	enum:__anon86
ACL_HOOK_REQ_BE_TCP_CONTENT	include/types/acl.h	/^	ACL_HOOK_REQ_BE_TCP_CONTENT,$/;"	e	enum:__anon86
ACL_HOOK_REQ_FE_HTTP_IN	include/types/acl.h	/^	ACL_HOOK_REQ_FE_HTTP_IN,$/;"	e	enum:__anon86
ACL_HOOK_REQ_FE_HTTP_OUT	include/types/acl.h	/^	ACL_HOOK_REQ_FE_HTTP_OUT,$/;"	e	enum:__anon86
ACL_HOOK_REQ_FE_SWITCH	include/types/acl.h	/^	ACL_HOOK_REQ_FE_SWITCH,$/;"	e	enum:__anon86
ACL_HOOK_REQ_FE_TCP	include/types/acl.h	/^	ACL_HOOK_REQ_FE_TCP = 0,$/;"	e	enum:__anon86
ACL_HOOK_REQ_FE_TCP_CONTENT	include/types/acl.h	/^	ACL_HOOK_REQ_FE_TCP_CONTENT,$/;"	e	enum:__anon86
ACL_HOOK_RTR_BE_HTTP_IN	include/types/acl.h	/^	ACL_HOOK_RTR_BE_HTTP_IN,$/;"	e	enum:__anon86
ACL_HOOK_RTR_BE_HTTP_OUT	include/types/acl.h	/^	ACL_HOOK_RTR_BE_HTTP_OUT,$/;"	e	enum:__anon86
ACL_HOOK_RTR_BE_TCP_CONTENT	include/types/acl.h	/^	ACL_HOOK_RTR_BE_TCP_CONTENT,$/;"	e	enum:__anon86
ACL_HOOK_RTR_FE_HTTP_IN	include/types/acl.h	/^	ACL_HOOK_RTR_FE_HTTP_IN,$/;"	e	enum:__anon86
ACL_HOOK_RTR_FE_HTTP_OUT	include/types/acl.h	/^	ACL_HOOK_RTR_FE_HTTP_OUT,$/;"	e	enum:__anon86
ACL_HOOK_RTR_FE_TCP_CONTENT	include/types/acl.h	/^	ACL_HOOK_RTR_FE_TCP_CONTENT,$/;"	e	enum:__anon86
ACL_MAY_LOOKUP	include/types/acl.h	/^	ACL_MAY_LOOKUP          =  1 << 31,  \/* exact pattern lookup *\/$/;"	e	enum:__anon85
ACL_PAT_FAIL	include/types/acl.h	/^	ACL_PAT_FAIL = 0,           \/* test failed *\/$/;"	e	enum:__anon82
ACL_PAT_F_FROM_FILE	include/types/acl.h	/^	ACL_PAT_F_FROM_FILE   = 1 << 1,       \/* pattern comes from a file *\/$/;"	e	enum:__anon84
ACL_PAT_F_IGNORE_CASE	include/types/acl.h	/^	ACL_PAT_F_IGNORE_CASE = 1 << 0,       \/* ignore case *\/$/;"	e	enum:__anon84
ACL_PAT_F_TREE	include/types/acl.h	/^	ACL_PAT_F_TREE        = 1 << 3,       \/* some patterns are arranged in a tree *\/$/;"	e	enum:__anon84
ACL_PAT_F_TREE_OK	include/types/acl.h	/^	ACL_PAT_F_TREE_OK     = 1 << 2,       \/* the pattern parser is allowed to build a tree *\/$/;"	e	enum:__anon84
ACL_PAT_MISS	include/types/acl.h	/^	ACL_PAT_MISS = 1,           \/* test may pass with more info *\/$/;"	e	enum:__anon82
ACL_PAT_PASS	include/types/acl.h	/^	ACL_PAT_PASS = 3,           \/* test passed *\/$/;"	e	enum:__anon82
ACL_USE_HDR_ANY	include/types/acl.h	/^	ACL_USE_HDR_ANY = (ACL_USE_HDR_CACHEABLE | ACL_USE_HDR_VOLATILE),$/;"	e	enum:__anon85
ACL_USE_HDR_CACHEABLE	include/types/acl.h	/^	ACL_USE_HDR_CACHEABLE   = 1 << 21,      \/* cacheable request or response header (eg: content-length) *\/$/;"	e	enum:__anon85
ACL_USE_HDR_VOLATILE	include/types/acl.h	/^	ACL_USE_HDR_VOLATILE    = 1 << 22,      \/* volatile  request or response header (eg: cookie) *\/$/;"	e	enum:__anon85
ACL_USE_L6REQ_ANY	include/types/acl.h	/^	ACL_USE_L6REQ_ANY       = (ACL_USE_L6REQ_PERMANENT | ACL_USE_L6REQ_CACHEABLE | ACL_USE_L6REQ_VOLATILE),$/;"	e	enum:__anon85
ACL_USE_L6REQ_CACHEABLE	include/types/acl.h	/^	ACL_USE_L6REQ_CACHEABLE = 1 << 10,      \/* cacheable layer6 request data (eg: length) *\/$/;"	e	enum:__anon85
ACL_USE_L6REQ_PERMANENT	include/types/acl.h	/^	ACL_USE_L6REQ_PERMANENT = 1 <<  9,      \/* unchanged layer6 request data *\/$/;"	e	enum:__anon85
ACL_USE_L6REQ_VOLATILE	include/types/acl.h	/^	ACL_USE_L6REQ_VOLATILE  = 1 << 11,      \/* volatile  layer6 request data (eg: contents) *\/$/;"	e	enum:__anon85
ACL_USE_L6RTR_ANY	include/types/acl.h	/^	ACL_USE_L6RTR_ANY       = (ACL_USE_L6RTR_PERMANENT | ACL_USE_L6RTR_CACHEABLE | ACL_USE_L6RTR_VOLATILE),$/;"	e	enum:__anon85
ACL_USE_L6RTR_CACHEABLE	include/types/acl.h	/^	ACL_USE_L6RTR_CACHEABLE = 1 << 13,      \/* cacheable layer6 response data (eg: length) *\/$/;"	e	enum:__anon85
ACL_USE_L6RTR_PERMANENT	include/types/acl.h	/^	ACL_USE_L6RTR_PERMANENT = 1 << 12,      \/* unchanged layer6 response data *\/$/;"	e	enum:__anon85
ACL_USE_L6RTR_VOLATILE	include/types/acl.h	/^	ACL_USE_L6RTR_VOLATILE  = 1 << 14,      \/* volatile  layer6 response data (eg: contents) *\/$/;"	e	enum:__anon85
ACL_USE_L6_ANY	include/types/acl.h	/^	ACL_USE_L6_ANY          = (ACL_USE_L6REQ_ANY | ACL_USE_L6RTR_ANY),$/;"	e	enum:__anon85
ACL_USE_L7REQ_ANY	include/types/acl.h	/^	ACL_USE_L7REQ_ANY       = (ACL_USE_L7REQ_PERMANENT | ACL_USE_L7REQ_CACHEABLE | ACL_USE_L7REQ_VOLATILE),$/;"	e	enum:__anon85
ACL_USE_L7REQ_CACHEABLE	include/types/acl.h	/^	ACL_USE_L7REQ_CACHEABLE = 1 << 16,      \/* cacheable layer7 request data (eg: content-length) *\/$/;"	e	enum:__anon85
ACL_USE_L7REQ_PERMANENT	include/types/acl.h	/^	ACL_USE_L7REQ_PERMANENT = 1 << 15,      \/* unchanged layer7 request data (eg: method) *\/$/;"	e	enum:__anon85
ACL_USE_L7REQ_VOLATILE	include/types/acl.h	/^	ACL_USE_L7REQ_VOLATILE  = 1 << 17,      \/* volatile  layer7 request data (eg: cookie) *\/$/;"	e	enum:__anon85
ACL_USE_L7RTR_ANY	include/types/acl.h	/^	ACL_USE_L7RTR_ANY       = (ACL_USE_L7RTR_PERMANENT | ACL_USE_L7RTR_CACHEABLE | ACL_USE_L7RTR_VOLATILE),$/;"	e	enum:__anon85
ACL_USE_L7RTR_CACHEABLE	include/types/acl.h	/^	ACL_USE_L7RTR_CACHEABLE = 1 << 19,      \/* cacheable layer7 response data (eg: content-length) *\/$/;"	e	enum:__anon85
ACL_USE_L7RTR_PERMANENT	include/types/acl.h	/^	ACL_USE_L7RTR_PERMANENT = 1 << 18,      \/* unchanged layer7 response data (eg: status) *\/$/;"	e	enum:__anon85
ACL_USE_L7RTR_VOLATILE	include/types/acl.h	/^	ACL_USE_L7RTR_VOLATILE  = 1 << 20,      \/* volatile  layer7 response data (eg: cookie) *\/$/;"	e	enum:__anon85
ACL_USE_L7_ANY	include/types/acl.h	/^	ACL_USE_L7_ANY          = (ACL_USE_L7REQ_ANY | ACL_USE_L7RTR_ANY | ACL_USE_HDR_ANY),$/;"	e	enum:__anon85
ACL_USE_NOTHING	include/types/acl.h	/^	ACL_USE_NOTHING         = 0,            \/* no need for anything beyond internal information *\/$/;"	e	enum:__anon85
ACL_USE_REQ_CACHEABLE	include/types/acl.h	/^	ACL_USE_REQ_CACHEABLE   = (ACL_USE_TCP4_CACHEABLE | ACL_USE_TCP6_CACHEABLE | ACL_USE_TCP_CACHEABLE |$/;"	e	enum:__anon85
ACL_USE_REQ_PERMANENT	include/types/acl.h	/^	ACL_USE_REQ_PERMANENT   = (ACL_USE_TCP4_PERMANENT | ACL_USE_TCP6_PERMANENT | ACL_USE_TCP_PERMANENT |$/;"	e	enum:__anon85
ACL_USE_REQ_VOLATILE	include/types/acl.h	/^	ACL_USE_REQ_VOLATILE    = (ACL_USE_TCP4_VOLATILE | ACL_USE_TCP6_VOLATILE | ACL_USE_TCP_VOLATILE |$/;"	e	enum:__anon85
ACL_USE_RTR_ANY	include/types/acl.h	/^	ACL_USE_RTR_ANY         = (ACL_USE_L6RTR_ANY | ACL_USE_L7RTR_ANY | ACL_USE_RTR_INTERNAL),$/;"	e	enum:__anon85
ACL_USE_RTR_INTERNAL	include/types/acl.h	/^	ACL_USE_RTR_INTERNAL    = 1 << 23,      \/* volatile response information *\/$/;"	e	enum:__anon85
ACL_USE_TCP4_ANY	include/types/acl.h	/^	ACL_USE_TCP4_ANY        = (ACL_USE_TCP4_PERMANENT | ACL_USE_TCP4_CACHEABLE | ACL_USE_TCP4_VOLATILE),$/;"	e	enum:__anon85
ACL_USE_TCP4_CACHEABLE	include/types/acl.h	/^	ACL_USE_TCP4_CACHEABLE  = 1 <<  1,      \/* cacheable TCPv4 data (eg: src conns) *\/$/;"	e	enum:__anon85
ACL_USE_TCP4_PERMANENT	include/types/acl.h	/^	ACL_USE_TCP4_PERMANENT  = 1 <<  0,      \/* unchanged TCPv4 data (eg: source IP) *\/$/;"	e	enum:__anon85
ACL_USE_TCP4_VOLATILE	include/types/acl.h	/^	ACL_USE_TCP4_VOLATILE   = 1 <<  2,      \/* volatile  TCPv4 data (eg: RTT) *\/$/;"	e	enum:__anon85
ACL_USE_TCP6_ANY	include/types/acl.h	/^	ACL_USE_TCP6_ANY        = (ACL_USE_TCP6_PERMANENT | ACL_USE_TCP6_CACHEABLE | ACL_USE_TCP6_VOLATILE),$/;"	e	enum:__anon85
ACL_USE_TCP6_CACHEABLE	include/types/acl.h	/^	ACL_USE_TCP6_CACHEABLE  = 1 <<  4,      \/* cacheable TCPv6 data (eg: src conns) *\/$/;"	e	enum:__anon85
ACL_USE_TCP6_PERMANENT	include/types/acl.h	/^	ACL_USE_TCP6_PERMANENT  = 1 <<  3,      \/* unchanged TCPv6 data (eg: source IP) *\/$/;"	e	enum:__anon85
ACL_USE_TCP6_VOLATILE	include/types/acl.h	/^	ACL_USE_TCP6_VOLATILE   = 1 <<  5,      \/* volatile  TCPv6 data (eg: RTT) *\/$/;"	e	enum:__anon85
ACL_USE_TCP_ANY	include/types/acl.h	/^	ACL_USE_TCP_ANY         = (ACL_USE_TCP_PERMANENT | ACL_USE_TCP_CACHEABLE | ACL_USE_TCP_VOLATILE),$/;"	e	enum:__anon85
ACL_USE_TCP_CACHEABLE	include/types/acl.h	/^	ACL_USE_TCP_CACHEABLE   = 1 <<  7,      \/* cacheable TCPv4\/v6 data (eg: src conns) *\/$/;"	e	enum:__anon85
ACL_USE_TCP_PERMANENT	include/types/acl.h	/^	ACL_USE_TCP_PERMANENT   = 1 <<  6,      \/* unchanged TCPv4\/v6 data (eg: source IP) *\/$/;"	e	enum:__anon85
ACL_USE_TCP_VOLATILE	include/types/acl.h	/^	ACL_USE_TCP_VOLATILE    = 1 <<  8,      \/* volatile  TCPv4\/v6 data (eg: RTT) *\/$/;"	e	enum:__anon85
_TYPES_ACL_H	include/types/acl.h	23;"	d
acl	include/types/acl.h	/^	struct acl *acl;            \/* acl pointed to by this term *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::acl
acl	include/types/acl.h	/^struct acl {$/;"	s
acl_cond	include/types/acl.h	/^struct acl_cond {$/;"	s
acl_expr	include/types/acl.h	/^struct acl_expr {$/;"	s
acl_keyword	include/types/acl.h	/^struct acl_keyword {$/;"	s
acl_kw_list	include/types/acl.h	/^struct acl_kw_list {$/;"	s
acl_pattern	include/types/acl.h	/^struct acl_pattern {$/;"	s
acl_term	include/types/acl.h	/^struct acl_term {$/;"	s
acl_term_suite	include/types/acl.h	/^struct acl_term_suite {$/;"	s
acl_time	include/types/acl.h	/^struct acl_time {$/;"	s
addr	include/types/acl.h	/^			struct in6_addr addr;$/;"	m	struct:acl_pattern::__anon87::__anon90	typeref:struct:acl_pattern::__anon87::__anon90::in6_addr
addr	include/types/acl.h	/^			struct in_addr addr;$/;"	m	struct:acl_pattern::__anon87::__anon89	typeref:struct:acl_pattern::__anon87::__anon89::in_addr
arg_mask	include/types/acl.h	/^	int arg_mask; \/* mask describing up to 7 arg types *\/$/;"	m	struct:acl_keyword
args	include/types/acl.h	/^	struct arg *args;           \/* optional argument list (eg: header or cookie name) *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::arg
cache_idx	include/types/acl.h	/^	int cache_idx;              \/* ACL index in cache *\/$/;"	m	struct:acl
dow	include/types/acl.h	/^	int dow:7;              \/* 1 bit per day of week: 0-6 *\/$/;"	m	struct:acl_time
expr	include/types/acl.h	/^	struct list expr;	    \/* list of acl_exprs *\/$/;"	m	struct:acl	typeref:struct:acl::list
fetch	include/types/acl.h	/^	int (*fetch)(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	m	struct:acl_keyword
file	include/types/acl.h	/^	const char *file;           \/* config file where the condition is declared *\/$/;"	m	struct:acl_cond
flags	include/types/acl.h	/^	int flags;                      \/* expr or pattern flags. *\/$/;"	m	struct:acl_pattern
freeptrbuf	include/types/acl.h	/^	void(*freeptrbuf)(void *ptr);	\/* a destructor able to free objects from the ptr *\/$/;"	m	struct:acl_pattern
group_mask	include/types/acl.h	/^		unsigned int group_mask;$/;"	m	union:acl_pattern::__anon87
h1	include/types/acl.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:acl_time
h2	include/types/acl.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:acl_time
i	include/types/acl.h	/^		int i;                          \/* integer value *\/$/;"	m	union:acl_pattern::__anon87
ipv4	include/types/acl.h	/^		} ipv4;                         \/* IPv4 address *\/$/;"	m	union:acl_pattern::__anon87	typeref:struct:acl_pattern::__anon87::__anon89
ipv6	include/types/acl.h	/^		} ipv6;                         \/* IPv6 address\/mask *\/$/;"	m	union:acl_pattern::__anon87	typeref:struct:acl_pattern::__anon87::__anon90
kw	include/types/acl.h	/^	const char *kw;$/;"	m	struct:acl_keyword
kw	include/types/acl.h	/^	struct acl_keyword *kw;     \/* back-reference to the keyword *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::acl_keyword
kw	include/types/acl.h	/^	struct acl_keyword kw[VAR_ARRAY];$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::acl_keyword
len	include/types/acl.h	/^	int len;                        \/* data length when required  *\/$/;"	m	struct:acl_pattern
line	include/types/acl.h	/^	int line;                   \/* line in the config file where the condition is declared *\/$/;"	m	struct:acl_cond
list	include/types/acl.h	/^	struct list list;                       \/* chaining *\/$/;"	m	struct:acl_pattern	typeref:struct:acl_pattern::list
list	include/types/acl.h	/^	struct list list;           \/* Some specific tests may use multiple conditions *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list
list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl	typeref:struct:acl::list
list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::list
list	include/types/acl.h	/^	struct list list;           \/* chaining *\/$/;"	m	struct:acl_term	typeref:struct:acl_term::list
list	include/types/acl.h	/^	struct list list;           \/* chaining of term suites *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list
list	include/types/acl.h	/^	struct list list;$/;"	m	struct:acl_kw_list	typeref:struct:acl_kw_list::list
m1	include/types/acl.h	/^	int h1:5, m1:6;         \/* 0..24:0..60. Use 0:0 for all day. *\/$/;"	m	struct:acl_time
m2	include/types/acl.h	/^	int h2:5, m2:6;         \/* 0..24:0..60. Use 24:0 for all day. *\/$/;"	m	struct:acl_time
mask	include/types/acl.h	/^			struct in_addr mask;$/;"	m	struct:acl_pattern::__anon87::__anon89	typeref:struct:acl_pattern::__anon87::__anon89::in_addr
mask	include/types/acl.h	/^			unsigned char mask;     \/* number of bits *\/$/;"	m	struct:acl_pattern::__anon87::__anon90
match	include/types/acl.h	/^	int (*match)(struct sample *smp, struct acl_pattern *pattern);$/;"	m	struct:acl_keyword
max	include/types/acl.h	/^			signed long long min, max;$/;"	m	struct:acl_pattern::__anon87::__anon88
max_set	include/types/acl.h	/^			int max_set :1;$/;"	m	struct:acl_pattern::__anon87::__anon88
min	include/types/acl.h	/^			signed long long min, max;$/;"	m	struct:acl_pattern::__anon87::__anon88
min_set	include/types/acl.h	/^			int min_set :1;$/;"	m	struct:acl_pattern::__anon87::__anon88
name	include/types/acl.h	/^	char *name;		    \/* acl name *\/$/;"	m	struct:acl
neg	include/types/acl.h	/^	int neg;                    \/* 1 if the ACL result must be negated *\/$/;"	m	struct:acl_term
parse	include/types/acl.h	/^	int (*parse)(const char **text, struct acl_pattern *pattern, int *opaque, char **err);$/;"	m	struct:acl_keyword
pattern_tree	include/types/acl.h	/^	struct eb_root pattern_tree;  \/* may be used for lookup in large datasets *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::eb_root
patterns	include/types/acl.h	/^	struct list patterns;       \/* list of acl_patterns *\/$/;"	m	struct:acl_expr	typeref:struct:acl_expr::list
pol	include/types/acl.h	/^	int pol;                    \/* polarity: ACL_COND_IF \/ ACL_COND_UNLESS *\/$/;"	m	struct:acl_cond
ptr	include/types/acl.h	/^		void *ptr;              \/* any data *\/$/;"	m	union:acl_pattern::__anon91
ptr	include/types/acl.h	/^	} ptr;                          \/* indirect values, allocated *\/$/;"	m	struct:acl_pattern	typeref:union:acl_pattern::__anon91
range	include/types/acl.h	/^		} range; \/* integer range *\/$/;"	m	union:acl_pattern::__anon87	typeref:struct:acl_pattern::__anon87::__anon88
reg	include/types/acl.h	/^		regex_t *reg;           \/* a compiled regex *\/$/;"	m	union:acl_pattern::__anon91
requires	include/types/acl.h	/^	unsigned int requires;      \/* or'ed bit mask of all acl's ACL_USE_* *\/$/;"	m	struct:acl_cond
requires	include/types/acl.h	/^	unsigned int requires;      \/* or'ed bit mask of all acl_expr's ACL_USE_* *\/$/;"	m	struct:acl
requires	include/types/acl.h	/^	unsigned int requires;   \/* bit mask of all ACL_USE_* required to evaluate this keyword *\/$/;"	m	struct:acl_keyword
str	include/types/acl.h	/^		char *str;              \/* any string  *\/$/;"	m	union:acl_pattern::__anon91
suites	include/types/acl.h	/^	struct list suites;         \/* list of acl_term_suites *\/$/;"	m	struct:acl_cond	typeref:struct:acl_cond::list
terms	include/types/acl.h	/^	struct list terms;          \/* list of acl_terms *\/$/;"	m	struct:acl_term_suite	typeref:struct:acl_term_suite::list
time	include/types/acl.h	/^		struct acl_time time;           \/* valid hours and days *\/$/;"	m	union:acl_pattern::__anon87	typeref:struct:acl_pattern::__anon87::acl_time
tree	include/types/acl.h	/^		struct eb_root *tree;           \/* tree storing all values if any *\/$/;"	m	union:acl_pattern::__anon87	typeref:struct:acl_pattern::__anon87::eb_root
type	include/types/acl.h	/^	int type;                               \/* type of the ACL pattern (SMP_T_*) *\/$/;"	m	struct:acl_pattern
use_cnt	include/types/acl.h	/^	int use_cnt;$/;"	m	struct:acl_keyword
val	include/types/acl.h	/^	} val;                                  \/* direct value *\/$/;"	m	struct:acl_pattern	typeref:union:acl_pattern::__anon87
val_args	include/types/acl.h	/^	int (*val_args)(struct arg *arg_p, char **err_msg);  \/* argument validation function *\/$/;"	m	struct:acl_keyword
ARGT_BE	include/types/arg.h	/^	ARGT_BE,       \/* a pointer to a backend only *\/$/;"	e	enum:__anon19
ARGT_FE	include/types/arg.h	/^	ARGT_FE,       \/* a pointer to a frontend only *\/$/;"	e	enum:__anon19
ARGT_IPV4	include/types/arg.h	/^	ARGT_IPV4,     \/* an IPv4 address *\/$/;"	e	enum:__anon19
ARGT_IPV6	include/types/arg.h	/^	ARGT_IPV6,     \/* an IPv6 address *\/$/;"	e	enum:__anon19
ARGT_MSK4	include/types/arg.h	/^	ARGT_MSK4,     \/* an IPv4 address mask (integer or dotted), stored as ARGT_IPV4 *\/$/;"	e	enum:__anon19
ARGT_MSK6	include/types/arg.h	/^	ARGT_MSK6,     \/* an IPv6 address mask (integer or dotted), stored as ARGT_IPV4 *\/$/;"	e	enum:__anon19
ARGT_NBTYPES	include/types/arg.h	/^	ARGT_NBTYPES   \/* no more values past 15 *\/$/;"	e	enum:__anon19
ARGT_SINT	include/types/arg.h	/^	ARGT_SINT,     \/* signed integer, the sign (+\/-) was explicit. Falls back to UINT if no sign. *\/$/;"	e	enum:__anon19
ARGT_SIZE	include/types/arg.h	/^	ARGT_SIZE,     \/* a size in bytes by default, stored as ARGT_UINT *\/$/;"	e	enum:__anon19
ARGT_SRV	include/types/arg.h	/^	ARGT_SRV,      \/* a pointer to a server *\/$/;"	e	enum:__anon19
ARGT_STOP	include/types/arg.h	/^	ARGT_STOP = 0, \/* end of the arg list *\/$/;"	e	enum:__anon19
ARGT_STR	include/types/arg.h	/^	ARGT_STR,      \/* string *\/$/;"	e	enum:__anon19
ARGT_TAB	include/types/arg.h	/^	ARGT_TAB,      \/* a pointer to a stick table *\/$/;"	e	enum:__anon19
ARGT_TIME	include/types/arg.h	/^	ARGT_TIME,     \/* a delay in ms by default, stored as ARGT_UINT *\/$/;"	e	enum:__anon19
ARGT_UINT	include/types/arg.h	/^	ARGT_UINT,     \/* unsigned integer, which is a positive integer without any sign *\/$/;"	e	enum:__anon19
ARGT_UNASSIGNED15	include/types/arg.h	/^	ARGT_UNASSIGNED15, \/* will probably be used for variables later *\/$/;"	e	enum:__anon19
ARGT_USR	include/types/arg.h	/^	ARGT_USR,      \/* a pointer to a user list *\/$/;"	e	enum:__anon19
_TYPES_ARG_H	include/types/arg.h	23;"	d
arg	include/types/arg.h	/^struct arg {$/;"	s
arg_data	include/types/arg.h	/^union arg_data {$/;"	u
data	include/types/arg.h	/^	union arg_data data;      \/* argument data *\/$/;"	m	struct:arg	typeref:union:arg::arg_data
ipv4	include/types/arg.h	/^	struct in_addr ipv4;$/;"	m	union:arg_data	typeref:struct:arg_data::in_addr
ipv6	include/types/arg.h	/^	struct in6_addr ipv6;$/;"	m	union:arg_data	typeref:struct:arg_data::in6_addr
prx	include/types/arg.h	/^	struct proxy *prx; \/* used for fe, be, tables *\/$/;"	m	union:arg_data	typeref:struct:arg_data::proxy
sint	include/types/arg.h	/^	int sint;$/;"	m	union:arg_data
srv	include/types/arg.h	/^	struct server *srv;$/;"	m	union:arg_data	typeref:struct:arg_data::server
str	include/types/arg.h	/^	struct chunk str;$/;"	m	union:arg_data	typeref:struct:arg_data::chunk
type	include/types/arg.h	/^	unsigned char type;       \/* argument type, ARGT_* *\/$/;"	m	struct:arg
uint	include/types/arg.h	/^	unsigned int uint; \/* used for uint, time, size *\/$/;"	m	union:arg_data
unresolved	include/types/arg.h	/^	unsigned char unresolved; \/* argument contains a string in <str> that must be resolved and freed *\/$/;"	m	struct:arg
usr	include/types/arg.h	/^	struct userlist *usr;$/;"	m	union:arg_data	typeref:struct:arg_data::userlist
AU_O_INSECURE	include/types/auth.h	23;"	d
MAX_AUTH_GROUPS	include/types/auth.h	21;"	d
_TYPES_AUTH_H	include/types/auth.h	14;"	d
auth_users	include/types/auth.h	/^struct auth_users {$/;"	s
flags	include/types/auth.h	/^	unsigned int flags;$/;"	m	struct:auth_users
group_mask	include/types/auth.h	/^		unsigned int group_mask;$/;"	m	union:auth_users::__anon40
groups	include/types/auth.h	/^		char *groups;$/;"	m	union:auth_users::__anon40
groups	include/types/auth.h	/^	char *groups[MAX_AUTH_GROUPS];$/;"	m	struct:userlist
groupusers	include/types/auth.h	/^	char **groupusers;$/;"	m	struct:userlist
grpcnt	include/types/auth.h	/^	int grpcnt;$/;"	m	struct:userlist
name	include/types/auth.h	/^	char *name;$/;"	m	struct:userlist
next	include/types/auth.h	/^	struct auth_users *next;$/;"	m	struct:auth_users	typeref:struct:auth_users::auth_users
next	include/types/auth.h	/^	struct userlist *next;$/;"	m	struct:userlist	typeref:struct:userlist::userlist
pass	include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users
u	include/types/auth.h	/^	} u;$/;"	m	struct:auth_users	typeref:union:auth_users::__anon40
user	include/types/auth.h	/^	char *user, *pass;$/;"	m	struct:auth_users
userlist	include/types/auth.h	/^struct userlist {$/;"	s
users	include/types/auth.h	/^	struct auth_users *users;$/;"	m	struct:userlist	typeref:struct:userlist::auth_users
BE_LB_ALGO	include/types/backend.h	88;"	d
BE_LB_ALGO_FAS	include/types/backend.h	81;"	d
BE_LB_ALGO_HH	include/types/backend.h	86;"	d
BE_LB_ALGO_LC	include/types/backend.h	80;"	d
BE_LB_ALGO_NONE	include/types/backend.h	78;"	d
BE_LB_ALGO_PH	include/types/backend.h	85;"	d
BE_LB_ALGO_RCH	include/types/backend.h	87;"	d
BE_LB_ALGO_RR	include/types/backend.h	79;"	d
BE_LB_ALGO_SH	include/types/backend.h	83;"	d
BE_LB_ALGO_SRR	include/types/backend.h	82;"	d
BE_LB_ALGO_UH	include/types/backend.h	84;"	d
BE_LB_CB_FAS	include/types/backend.h	56;"	d
BE_LB_CB_LC	include/types/backend.h	55;"	d
BE_LB_HASH_AVAL	include/types/backend.h	108;"	d
BE_LB_HASH_CONS	include/types/backend.h	107;"	d
BE_LB_HASH_HDR	include/types/backend.h	47;"	d
BE_LB_HASH_MAP	include/types/backend.h	106;"	d
BE_LB_HASH_PRM	include/types/backend.h	46;"	d
BE_LB_HASH_RDP	include/types/backend.h	48;"	d
BE_LB_HASH_SRC	include/types/backend.h	44;"	d
BE_LB_HASH_TYPE	include/types/backend.h	109;"	d
BE_LB_HASH_URI	include/types/backend.h	45;"	d
BE_LB_KIND	include/types/backend.h	73;"	d
BE_LB_KIND_CB	include/types/backend.h	71;"	d
BE_LB_KIND_HI	include/types/backend.h	72;"	d
BE_LB_KIND_NONE	include/types/backend.h	69;"	d
BE_LB_KIND_RR	include/types/backend.h	70;"	d
BE_LB_LKUP	include/types/backend.h	100;"	d
BE_LB_LKUP_CHTREE	include/types/backend.h	98;"	d
BE_LB_LKUP_FSTREE	include/types/backend.h	99;"	d
BE_LB_LKUP_LCTREE	include/types/backend.h	97;"	d
BE_LB_LKUP_MAP	include/types/backend.h	95;"	d
BE_LB_LKUP_NONE	include/types/backend.h	94;"	d
BE_LB_LKUP_RRTREE	include/types/backend.h	96;"	d
BE_LB_NEED	include/types/backend.h	66;"	d
BE_LB_NEED_ADDR	include/types/backend.h	62;"	d
BE_LB_NEED_DATA	include/types/backend.h	63;"	d
BE_LB_NEED_HTTP	include/types/backend.h	64;"	d
BE_LB_NEED_NONE	include/types/backend.h	61;"	d
BE_LB_PARM	include/types/backend.h	58;"	d
BE_LB_PROP_DYN	include/types/backend.h	103;"	d
BE_LB_RR_DYN	include/types/backend.h	51;"	d
BE_LB_RR_STATIC	include/types/backend.h	52;"	d
BE_WEIGHT_SCALE	include/types/backend.h	121;"	d
_TYPES_BACKEND_H	include/types/backend.h	23;"	d
algo	include/types/backend.h	/^	int algo;			\/* load balancing algorithm and variants: BE_LB_* *\/$/;"	m	struct:lbprm
chash	include/types/backend.h	/^	struct lb_chash chash;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_chash
fas	include/types/backend.h	/^	struct lb_fas fas;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fas
fbck	include/types/backend.h	/^	struct server *fbck;		\/* first backup server when !PR_O_USE_ALL_BK, or NULL *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::server
fwlc	include/types/backend.h	/^	struct lb_fwlc fwlc;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwlc
fwrr	include/types/backend.h	/^	struct lb_fwrr fwrr;$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_fwrr
lbprm	include/types/backend.h	/^struct lbprm {$/;"	s
map	include/types/backend.h	/^	struct lb_map map;		\/* LB parameters for map-based algorithms *\/$/;"	m	struct:lbprm	typeref:struct:lbprm::lb_map
server_drop_conn	include/types/backend.h	/^	void (*server_drop_conn)(struct server *);       \/* to be called when connection is dropped *\/$/;"	m	struct:lbprm
server_take_conn	include/types/backend.h	/^	void (*server_take_conn)(struct server *);       \/* to be called when connection is assigned *\/$/;"	m	struct:lbprm
set_server_status_down	include/types/backend.h	/^	void (*set_server_status_down)(struct server *); \/* to be called after status changes to DOWN *\/$/;"	m	struct:lbprm
set_server_status_up	include/types/backend.h	/^	void (*set_server_status_up)(struct server *);   \/* to be called after status changes to UP *\/$/;"	m	struct:lbprm
tot_used	include/types/backend.h	/^	int tot_used;			\/* total number of servers used for LB *\/$/;"	m	struct:lbprm
tot_wact	include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm
tot_wbck	include/types/backend.h	/^	int tot_wact, tot_wbck;		\/* total effective weights of active and backup servers *\/$/;"	m	struct:lbprm
tot_weight	include/types/backend.h	/^	int tot_weight;			\/* total effective weight of servers participating to LB *\/$/;"	m	struct:lbprm
update_server_eweight	include/types/backend.h	/^	void (*update_server_eweight)(struct server *);  \/* to be called after eweight change *\/$/;"	m	struct:lbprm
wdiv	include/types/backend.h	/^	int wdiv;			\/* ratio between effective weight and user weight *\/$/;"	m	struct:lbprm
wmult	include/types/backend.h	/^	int wmult;			\/* ratio between user weight and effective weight *\/$/;"	m	struct:lbprm
AN_REQ_DECODE_PROXY	include/types/buffers.h	140;"	d
AN_REQ_HTTP_BODY	include/types/buffers.h	150;"	d
AN_REQ_HTTP_INNER	include/types/buffers.h	148;"	d
AN_REQ_HTTP_PROCESS_BE	include/types/buffers.h	146;"	d
AN_REQ_HTTP_PROCESS_FE	include/types/buffers.h	143;"	d
AN_REQ_HTTP_TARPIT	include/types/buffers.h	149;"	d
AN_REQ_HTTP_XFER_BODY	include/types/buffers.h	153;"	d
AN_REQ_INSPECT_BE	include/types/buffers.h	145;"	d
AN_REQ_INSPECT_FE	include/types/buffers.h	141;"	d
AN_REQ_PRST_RDP_COOKIE	include/types/buffers.h	152;"	d
AN_REQ_SRV_RULES	include/types/buffers.h	147;"	d
AN_REQ_STICKING_RULES	include/types/buffers.h	151;"	d
AN_REQ_SWITCHING_RULES	include/types/buffers.h	144;"	d
AN_REQ_WAIT_HTTP	include/types/buffers.h	142;"	d
AN_RES_HTTP_PROCESS_BE	include/types/buffers.h	158;"	d
AN_RES_HTTP_PROCESS_FE	include/types/buffers.h	159;"	d
AN_RES_HTTP_XFER_BODY	include/types/buffers.h	161;"	d
AN_RES_INSPECT	include/types/buffers.h	156;"	d
AN_RES_STORE_RULES	include/types/buffers.h	160;"	d
AN_RES_WAIT_HTTP	include/types/buffers.h	157;"	d
BF_ANA_TIMEOUT	include/types/buffers.h	108;"	d
BF_AUTO_CLOSE	include/types/buffers.h	74;"	d
BF_AUTO_CONNECT	include/types/buffers.h	112;"	d
BF_CLEAR_READ	include/types/buffers.h	122;"	d
BF_CLEAR_TIMEOUT	include/types/buffers.h	124;"	d
BF_CLEAR_WRITE	include/types/buffers.h	123;"	d
BF_DONT_READ	include/types/buffers.h	114;"	d
BF_EXPECT_MORE	include/types/buffers.h	115;"	d
BF_FULL	include/types/buffers.h	60;"	d
BF_HIJACK	include/types/buffers.h	107;"	d
BF_KERN_SPLICING	include/types/buffers.h	110;"	d
BF_MASK_ANALYSER	include/types/buffers.h	127;"	d
BF_MASK_STATIC	include/types/buffers.h	130;"	d
BF_NEVER_WAIT	include/types/buffers.h	117;"	d
BF_OUT_EMPTY	include/types/buffers.h	71;"	d
BF_READ_ACTIVITY	include/types/buffers.h	58;"	d
BF_READ_ATTACHED	include/types/buffers.h	109;"	d
BF_READ_DONTWAIT	include/types/buffers.h	111;"	d
BF_READ_ERROR	include/types/buffers.h	57;"	d
BF_READ_NOEXP	include/types/buffers.h	63;"	d
BF_READ_NULL	include/types/buffers.h	54;"	d
BF_READ_PARTIAL	include/types/buffers.h	55;"	d
BF_READ_TIMEOUT	include/types/buffers.h	56;"	d
BF_SEND_DONTWAIT	include/types/buffers.h	116;"	d
BF_SHUTR	include/types/buffers.h	61;"	d
BF_SHUTR_NOW	include/types/buffers.h	62;"	d
BF_SHUTW	include/types/buffers.h	72;"	d
BF_SHUTW_NOW	include/types/buffers.h	73;"	d
BF_STREAMER	include/types/buffers.h	104;"	d
BF_STREAMER_FAST	include/types/buffers.h	105;"	d
BF_WAKE_ONCE	include/types/buffers.h	119;"	d
BF_WRITE_ACTIVITY	include/types/buffers.h	69;"	d
BF_WRITE_ERROR	include/types/buffers.h	68;"	d
BF_WRITE_NULL	include/types/buffers.h	65;"	d
BF_WRITE_PARTIAL	include/types/buffers.h	66;"	d
BF_WRITE_TIMEOUT	include/types/buffers.h	67;"	d
BUF_INFINITE_FORWARD	include/types/buffers.h	165;"	d
_TYPES_BUFFERS_H	include/types/buffers.h	23;"	d
analyse_exp	include/types/buffers.h	/^	int analyse_exp;                \/* expiration date for current analysers (if set) *\/$/;"	m	struct:buffer
analysers	include/types/buffers.h	/^	unsigned int analysers;         \/* bit field indicating what to do on the buffer *\/$/;"	m	struct:buffer
buffer	include/types/buffers.h	/^struct buffer {$/;"	s
chunk	include/types/buffers.h	/^struct chunk {$/;"	s
cons	include/types/buffers.h	/^	struct stream_interface *cons;  \/* consumer attached to this buffer *\/$/;"	m	struct:buffer	typeref:struct:buffer::stream_interface
data	include/types/buffers.h	/^	char data[0];                   \/* <size> bytes *\/$/;"	m	struct:buffer
flags	include/types/buffers.h	/^	unsigned int flags;             \/* BF_* *\/$/;"	m	struct:buffer
hijacker	include/types/buffers.h	/^	void (*hijacker)(struct session *, struct buffer *); \/* alternative content producer *\/$/;"	m	struct:buffer
i	include/types/buffers.h	/^	unsigned int i;                 \/* number of input bytes pending for analysis in the buffer *\/$/;"	m	struct:buffer
len	include/types/buffers.h	/^	int len;	\/* current size of the string from first to last char. <0 = uninit. *\/$/;"	m	struct:chunk
o	include/types/buffers.h	/^	unsigned int o;                 \/* number of out bytes the sender can consume from this buffer *\/$/;"	m	struct:buffer
p	include/types/buffers.h	/^	char *p;                        \/* buffer's start pointer, separates in and out data *\/$/;"	m	struct:buffer
pipe	include/types/buffers.h	/^	struct pipe *pipe;		\/* non-NULL only when data present *\/$/;"	m	struct:buffer	typeref:struct:buffer::pipe
prod	include/types/buffers.h	/^	struct stream_interface *prod;  \/* producer attached to this buffer *\/$/;"	m	struct:buffer	typeref:struct:buffer::stream_interface
rex	include/types/buffers.h	/^	int rex;                        \/* expiration date for a read, in ticks *\/$/;"	m	struct:buffer
rto	include/types/buffers.h	/^	int rto;                        \/* read timeout, in ticks *\/$/;"	m	struct:buffer
size	include/types/buffers.h	/^	int size;	\/* total size of the buffer, 0 if the *str is read-only *\/$/;"	m	struct:chunk
size	include/types/buffers.h	/^	unsigned int size;              \/* buffer size in bytes *\/$/;"	m	struct:buffer
str	include/types/buffers.h	/^	char *str;	\/* beginning of the string itself. Might not be 0-terminated *\/$/;"	m	struct:chunk
to_forward	include/types/buffers.h	/^	unsigned int to_forward;        \/* number of bytes to forward after out without a wake-up *\/$/;"	m	struct:buffer
total	include/types/buffers.h	/^	unsigned long long total;       \/* total data read *\/$/;"	m	struct:buffer
wex	include/types/buffers.h	/^	int wex;                        \/* expiration date for a write or connect, in ticks *\/$/;"	m	struct:buffer
wto	include/types/buffers.h	/^	int wto;                        \/* write timeout, in ticks *\/$/;"	m	struct:buffer
xfer_large	include/types/buffers.h	/^	unsigned char xfer_large;       \/* number of consecutive large xfers *\/$/;"	m	struct:buffer
xfer_small	include/types/buffers.h	/^	unsigned char xfer_small;       \/* number of consecutive small xfers *\/$/;"	m	struct:buffer
CACHE_LEN	include/types/cache.h	4;"	d
FNAME_LEN	include/types/cache.h	6;"	d
SIZE_LEN	include/types/cache.h	5;"	d
_TYPES_CACHE_H	include/types/cache.h	2;"	d
cache	include/types/cache.h	/^struct cache {$/;"	s
uri	include/types/cache.h	/^	char 		uri[100];$/;"	m	struct:cache
_TYPES_CAPTURE_H	include/types/capture.h	23;"	d
cap_hdr	include/types/capture.h	/^struct cap_hdr {$/;"	s
index	include/types/capture.h	/^    int index;				\/* index in the output array *\/$/;"	m	struct:cap_hdr
len	include/types/capture.h	/^    int len;				\/* capture length, not including terminal zero *\/$/;"	m	struct:cap_hdr
name	include/types/capture.h	/^    char *name;				\/* header name, case insensitive *\/$/;"	m	struct:cap_hdr
namelen	include/types/capture.h	/^    int namelen;			\/* length of the header name, to speed-up lookups *\/$/;"	m	struct:cap_hdr
next	include/types/capture.h	/^    struct cap_hdr *next;$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::cap_hdr
pool	include/types/capture.h	/^    struct pool_head *pool;		\/* pool of pre-allocated memory area of (len+1) bytes *\/$/;"	m	struct:cap_hdr	typeref:struct:cap_hdr::pool_head
HANA_OBS_LAYER4	include/types/checks.h	/^	HANA_OBS_LAYER4,		\/* Observe L4 - for example tcp *\/$/;"	e	enum:__anon81
HANA_OBS_LAYER7	include/types/checks.h	/^	HANA_OBS_LAYER7,		\/* Observe L7 - for example http *\/$/;"	e	enum:__anon81
HANA_OBS_NONE	include/types/checks.h	/^	HANA_OBS_NONE		= 0,$/;"	e	enum:__anon81
HANA_OBS_SIZE	include/types/checks.h	/^	HANA_OBS_SIZE$/;"	e	enum:__anon81
HANA_ONERR_FAILCHK	include/types/checks.h	/^	HANA_ONERR_FAILCHK,		\/* Simulate a failed check *\/$/;"	e	enum:__anon78
HANA_ONERR_FASTINTER	include/types/checks.h	/^	HANA_ONERR_FASTINTER,		\/* Force fastinter*\/$/;"	e	enum:__anon78
HANA_ONERR_MARKDWN	include/types/checks.h	/^	HANA_ONERR_MARKDWN,		\/* Mark this server down, now! *\/$/;"	e	enum:__anon78
HANA_ONERR_SUDDTH	include/types/checks.h	/^	HANA_ONERR_SUDDTH,		\/* Enters sudden death - one more failed check will mark this server down *\/$/;"	e	enum:__anon78
HANA_ONERR_UNKNOWN	include/types/checks.h	/^	HANA_ONERR_UNKNOWN	= 0,$/;"	e	enum:__anon78
HANA_ONMARKEDDOWN_NONE	include/types/checks.h	/^	HANA_ONMARKEDDOWN_NONE	= 0,$/;"	e	enum:__anon79
HANA_ONMARKEDDOWN_SHUTDOWNSESSIONS	include/types/checks.h	/^	HANA_ONMARKEDDOWN_SHUTDOWNSESSIONS,	\/* Shutdown peer sessions *\/$/;"	e	enum:__anon79
HANA_ONMARKEDUP_NONE	include/types/checks.h	/^	HANA_ONMARKEDUP_NONE	= 0,$/;"	e	enum:__anon80
HANA_ONMARKEDUP_SHUTDOWNBACKUPSESSIONS	include/types/checks.h	/^	HANA_ONMARKEDUP_SHUTDOWNBACKUPSESSIONS,	\/* Shutdown peer sessions *\/$/;"	e	enum:__anon80
HANA_STATUS_HTTP_BROKEN_PIPE	include/types/checks.h	/^	HANA_STATUS_HTTP_BROKEN_PIPE,	\/* Unexpected close from server *\/$/;"	e	enum:__anon77
HANA_STATUS_HTTP_HDRRSP	include/types/checks.h	/^	HANA_STATUS_HTTP_HDRRSP,	\/* Invalid http response (headers) *\/$/;"	e	enum:__anon77
HANA_STATUS_HTTP_OK	include/types/checks.h	/^	HANA_STATUS_HTTP_OK,		\/* Correct http response *\/$/;"	e	enum:__anon77
HANA_STATUS_HTTP_READ_ERROR	include/types/checks.h	/^	HANA_STATUS_HTTP_READ_ERROR,	\/* Read error *\/$/;"	e	enum:__anon77
HANA_STATUS_HTTP_READ_TIMEOUT	include/types/checks.h	/^	HANA_STATUS_HTTP_READ_TIMEOUT,	\/* Read timeout *\/$/;"	e	enum:__anon77
HANA_STATUS_HTTP_RSP	include/types/checks.h	/^	HANA_STATUS_HTTP_RSP,		\/* Invalid http response *\/$/;"	e	enum:__anon77
HANA_STATUS_HTTP_STS	include/types/checks.h	/^	HANA_STATUS_HTTP_STS,		\/* Wrong http response, for example HTTP 5xx *\/$/;"	e	enum:__anon77
HANA_STATUS_L4_ERR	include/types/checks.h	/^	HANA_STATUS_L4_ERR,		\/* L4 unsuccessful connection *\/$/;"	e	enum:__anon77
HANA_STATUS_L4_OK	include/types/checks.h	/^	HANA_STATUS_L4_OK,		\/* L4 successful connection *\/$/;"	e	enum:__anon77
HANA_STATUS_SIZE	include/types/checks.h	/^	HANA_STATUS_SIZE$/;"	e	enum:__anon77
HANA_STATUS_UNKNOWN	include/types/checks.h	/^	HANA_STATUS_UNKNOWN	= 0,$/;"	e	enum:__anon77
HCHK_STATUS_CHECKED	include/types/checks.h	/^	HCHK_STATUS_CHECKED,		\/* DUMMY STATUS *\/$/;"	e	enum:__anon76
HCHK_STATUS_HANA	include/types/checks.h	/^	HCHK_STATUS_HANA,		\/* Health analyze detected enough consecutive errors *\/$/;"	e	enum:__anon76
HCHK_STATUS_INI	include/types/checks.h	/^	HCHK_STATUS_INI,		\/* Initializing *\/$/;"	e	enum:__anon76
HCHK_STATUS_L4CON	include/types/checks.h	/^	HCHK_STATUS_L4CON,		\/* L4 connection problem, for example: *\/$/;"	e	enum:__anon76
HCHK_STATUS_L4OK	include/types/checks.h	/^	HCHK_STATUS_L4OK,		\/* L4 check passed, for example tcp connect *\/$/;"	e	enum:__anon76
HCHK_STATUS_L4TOUT	include/types/checks.h	/^	HCHK_STATUS_L4TOUT,		\/* L4 timeout *\/$/;"	e	enum:__anon76
HCHK_STATUS_L57DATA	include/types/checks.h	/^	HCHK_STATUS_L57DATA,		\/* DUMMY STATUS *\/$/;"	e	enum:__anon76
HCHK_STATUS_L6OK	include/types/checks.h	/^	HCHK_STATUS_L6OK,		\/* L6 check passed *\/$/;"	e	enum:__anon76
HCHK_STATUS_L6RSP	include/types/checks.h	/^	HCHK_STATUS_L6RSP,		\/* L6 invalid response - protocol error *\/$/;"	e	enum:__anon76
HCHK_STATUS_L6TOUT	include/types/checks.h	/^	HCHK_STATUS_L6TOUT,		\/* L6 (SSL) timeout *\/$/;"	e	enum:__anon76
HCHK_STATUS_L7OKCD	include/types/checks.h	/^	HCHK_STATUS_L7OKCD,		\/* L7 check conditionally passed *\/$/;"	e	enum:__anon76
HCHK_STATUS_L7OKD	include/types/checks.h	/^	HCHK_STATUS_L7OKD,		\/* L7 check passed *\/$/;"	e	enum:__anon76
HCHK_STATUS_L7RSP	include/types/checks.h	/^	HCHK_STATUS_L7RSP,		\/* L7 invalid response - protocol error *\/$/;"	e	enum:__anon76
HCHK_STATUS_L7STS	include/types/checks.h	/^	HCHK_STATUS_L7STS,		\/* L7 response error, for example HTTP 5xx *\/$/;"	e	enum:__anon76
HCHK_STATUS_L7TOUT	include/types/checks.h	/^	HCHK_STATUS_L7TOUT,		\/* L7 (HTTP\/SMTP) timeout *\/$/;"	e	enum:__anon76
HCHK_STATUS_SIZE	include/types/checks.h	/^	HCHK_STATUS_SIZE$/;"	e	enum:__anon76
HCHK_STATUS_SOCKERR	include/types/checks.h	/^	HCHK_STATUS_SOCKERR,		\/* Socket error *\/$/;"	e	enum:__anon76
HCHK_STATUS_START	include/types/checks.h	/^	HCHK_STATUS_START,		\/* Check started - SPECIAL STATUS *\/$/;"	e	enum:__anon76
HCHK_STATUS_UNKNOWN	include/types/checks.h	/^	HCHK_STATUS_UNKNOWN	 = 0,	\/* Unknown *\/$/;"	e	enum:__anon76
analyze_status	include/types/checks.h	/^struct analyze_status {$/;"	s
check_status	include/types/checks.h	/^struct check_status {$/;"	s
desc	include/types/checks.h	/^	char *desc;				\/* description *\/$/;"	m	struct:analyze_status
desc	include/types/checks.h	/^	char *desc;			\/* long description *\/$/;"	m	struct:check_status
info	include/types/checks.h	/^	char *info;			\/* human readable short info *\/$/;"	m	struct:check_status
lr	include/types/checks.h	/^	unsigned char lr[HANA_OBS_SIZE];	\/* result for l4\/l7: 0 = ignore, 1 - error, 2 - OK *\/$/;"	m	struct:analyze_status
result	include/types/checks.h	/^	short result;			\/* one of SRV_CHK_* *\/$/;"	m	struct:check_status
_TYPES_COUNTERS_H	include/types/counters.h	24;"	d
bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:licounters
bytes_in	include/types/counters.h	/^	long long bytes_in;			\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:srvcounters
bytes_in	include/types/counters.h	/^	long long bytes_in;                     \/* number of bytes transferred from the client to the server *\/$/;"	m	struct:pxcounters
bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:licounters
bytes_out	include/types/counters.h	/^	long long bytes_out;			\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:srvcounters
bytes_out	include/types/counters.h	/^	long long bytes_out;                    \/* number of bytes transferred from the server to the client *\/$/;"	m	struct:pxcounters
cli_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters
cli_aborts	include/types/counters.h	/^	long long cli_aborts;                   \/* aborted responses during DATA phase caused by the client *\/$/;"	m	struct:pxcounters
conn_max	include/types/counters.h	/^	unsigned int conn_max;			\/* max # of active listener sessions *\/$/;"	m	struct:licounters
conn_max	include/types/counters.h	/^	unsigned int conn_max;                  \/* max # of active sessions *\/$/;"	m	struct:pxcounters
cps_max	include/types/counters.h	/^	unsigned int cps_max;                   \/* maximum of new connections received per second *\/$/;"	m	struct:pxcounters
cum_conn	include/types/counters.h	/^	long long    cum_conn;                  \/* cumulated number of received connections *\/$/;"	m	struct:pxcounters
cum_conn	include/types/counters.h	/^	long long cum_conn;			\/* cumulated number of received connections *\/$/;"	m	struct:licounters
cum_lbconn	include/types/counters.h	/^	long long  cum_lbconn;                  \/* cumulated number of sessions processed by load balancing (BE only) *\/$/;"	m	struct:pxcounters
cum_lbconn	include/types/counters.h	/^	long long cum_lbconn;			\/* cumulated number of sessions directed by load balancing *\/$/;"	m	struct:srvcounters
cum_req	include/types/counters.h	/^			long long cum_req;      \/* cumulated number of processed HTTP requests *\/$/;"	m	struct:pxcounters::__anon45::__anon46
cum_sess	include/types/counters.h	/^	long long    cum_sess;                  \/* cumulated number of accepted connections *\/$/;"	m	struct:pxcounters
cum_sess	include/types/counters.h	/^	long long cum_sess;			\/* cumulated number of accepted sessions *\/$/;"	m	struct:licounters
cum_sess	include/types/counters.h	/^	long long cum_sess;			\/* cumulated number of sessions really sent to this server *\/$/;"	m	struct:srvcounters
cur_sess_max	include/types/counters.h	/^	unsigned int cur_sess_max;		\/* max number of currently active sessions *\/$/;"	m	struct:srvcounters
denied_conn	include/types/counters.h	/^	long long denied_conn;			\/* denied connection requests (tcp-req rules) *\/$/;"	m	struct:licounters
denied_conn	include/types/counters.h	/^	long long denied_conn;                  \/* denied connection requests (tcp-req rules) *\/$/;"	m	struct:pxcounters
denied_req	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters
denied_req	include/types/counters.h	/^	long long denied_req;                   \/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters
denied_resp	include/types/counters.h	/^	long long denied_req, denied_resp;	\/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:licounters
denied_resp	include/types/counters.h	/^	long long denied_resp;                  \/* blocked requests\/responses because of security concerns *\/$/;"	m	struct:pxcounters
down_trans	include/types/counters.h	/^	long long down_trans;			\/* up->down transitions *\/$/;"	m	struct:srvcounters
failed_checks	include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters
failed_conns	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters
failed_conns	include/types/counters.h	/^	long long failed_conns;                 \/* failed connect() attempts (BE only) *\/$/;"	m	struct:pxcounters
failed_hana	include/types/counters.h	/^	long long failed_checks, failed_hana;	\/* failed health checks and health analyses *\/$/;"	m	struct:srvcounters
failed_req	include/types/counters.h	/^	long long failed_req;			\/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:licounters
failed_req	include/types/counters.h	/^	long long failed_req;                   \/* failed requests (eg: invalid or timeout) *\/$/;"	m	struct:pxcounters
failed_resp	include/types/counters.h	/^	long long failed_conns, failed_resp;	\/* failed connect() and responses *\/$/;"	m	struct:srvcounters
failed_resp	include/types/counters.h	/^	long long failed_resp;                  \/* failed responses (BE only) *\/$/;"	m	struct:pxcounters
failed_secu	include/types/counters.h	/^	long long failed_secu;			\/* blocked responses because of security concerns *\/$/;"	m	struct:srvcounters
http	include/types/counters.h	/^		} http;$/;"	m	union:pxcounters::__anon45	typeref:struct:pxcounters::__anon45::__anon46
http	include/types/counters.h	/^		} http;$/;"	m	union:srvcounters::__anon47	typeref:struct:srvcounters::__anon47::__anon48
intercepted_req	include/types/counters.h	/^	long long intercepted_req;              \/* number of monitoring or stats requests intercepted by the frontend *\/$/;"	m	struct:pxcounters
licounters	include/types/counters.h	/^struct licounters {$/;"	s
nbpend_max	include/types/counters.h	/^	unsigned int nbpend_max;		\/* max number of pending connections reached *\/$/;"	m	struct:srvcounters
nbpend_max	include/types/counters.h	/^	unsigned int nbpend_max;                \/* max number of pending connections with no server assigned yet (BE only) *\/$/;"	m	struct:pxcounters
p	include/types/counters.h	/^	} p;                                    \/* protocol-specific stats *\/$/;"	m	struct:pxcounters	typeref:union:pxcounters::__anon45
p	include/types/counters.h	/^	} p;$/;"	m	struct:srvcounters	typeref:union:srvcounters::__anon47
pxcounters	include/types/counters.h	/^struct pxcounters {$/;"	s
redispatches	include/types/counters.h	/^	long long redispatches;                 \/* retried and redispatched connections (BE only) *\/$/;"	m	struct:pxcounters
redispatches	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters
retries	include/types/counters.h	/^	long long retries, redispatches;	\/* retried and redispatched connections *\/$/;"	m	struct:srvcounters
retries	include/types/counters.h	/^	long long retries;                      \/* retried and redispatched connections (BE only) *\/$/;"	m	struct:pxcounters
rps_max	include/types/counters.h	/^			unsigned int rps_max;   \/* maximum of new HTTP requests second observed *\/$/;"	m	struct:pxcounters::__anon45::__anon46
rsp	include/types/counters.h	/^			long long rsp[6];	\/* http response codes *\/$/;"	m	struct:srvcounters::__anon47::__anon48
rsp	include/types/counters.h	/^			long long rsp[6];       \/* http response codes *\/$/;"	m	struct:pxcounters::__anon45::__anon46
sps_max	include/types/counters.h	/^	unsigned int sps_max;			\/* maximum of new sessions per second seen on this server *\/$/;"	m	struct:srvcounters
sps_max	include/types/counters.h	/^	unsigned int sps_max;                   \/* maximum of new connections accepted per second (sessions) *\/$/;"	m	struct:pxcounters
srv_aborts	include/types/counters.h	/^	long long cli_aborts, srv_aborts;	\/* aborted responses during DATA phase due to client or server *\/$/;"	m	struct:srvcounters
srv_aborts	include/types/counters.h	/^	long long srv_aborts;                   \/* aborted responses during DATA phase caused by the server *\/$/;"	m	struct:pxcounters
srvcounters	include/types/counters.h	/^struct srvcounters {$/;"	s
DIR_RD	include/types/fd.h	/^	DIR_RD=0,$/;"	e	enum:__anon20
DIR_SIZE	include/types/fd.h	/^	DIR_SIZE$/;"	e	enum:__anon20
DIR_WR	include/types/fd.h	/^	DIR_WR=1,$/;"	e	enum:__anon20
FD_FL_TCP	include/types/fd.h	64;"	d
FD_FL_TCP_NODELAY	include/types/fd.h	65;"	d
FD_FL_TCP_NOLING	include/types/fd.h	66;"	d
FD_POLL_DATA	include/types/fd.h	58;"	d
FD_POLL_ERR	include/types/fd.h	55;"	d
FD_POLL_HUP	include/types/fd.h	56;"	d
FD_POLL_IN	include/types/fd.h	52;"	d
FD_POLL_OUT	include/types/fd.h	54;"	d
FD_POLL_PRI	include/types/fd.h	53;"	d
FD_POLL_STICKY	include/types/fd.h	59;"	d
FD_STCLOSE	include/types/fd.h	35;"	d
FD_STCONN	include/types/fd.h	37;"	d
FD_STERROR	include/types/fd.h	39;"	d
FD_STLISTEN	include/types/fd.h	36;"	d
FD_STREADY	include/types/fd.h	38;"	d
MAX_POLLERS	include/types/fd.h	129;"	d
_TYPES_FD_H	include/types/fd.h	23;"	d
cb	include/types/fd.h	/^	} cb[DIR_SIZE];$/;"	m	struct:fdtab	typeref:struct:fdtab::__anon21
clo	include/types/fd.h	/^	void REGPRM1    (*clo)(const int fd);                \/* mark <fd> as closed *\/$/;"	m	struct:poller
clr	include/types/fd.h	/^	int  REGPRM2    (*clr)(const int fd, int dir);       \/* clear polling on <fd> for <dir> *\/$/;"	m	struct:poller
cond_c	include/types/fd.h	/^	int  REGPRM2 (*cond_c)(const int fd, int dir);       \/* clear polling on <fd> for <dir> if set *\/$/;"	m	struct:poller
cond_s	include/types/fd.h	/^	int  REGPRM2 (*cond_s)(const int fd, int dir);       \/* set   polling on <fd> for <dir> if unset *\/$/;"	m	struct:poller
e	include/types/fd.h	/^		unsigned char e;             \/* read and write events status. 4 bits, may be merged into flags' lower bits *\/$/;"	m	struct:fdtab::__anon22
ev	include/types/fd.h	/^	unsigned char ev;                    \/* event seen in return of poll() : FD_POLL_* *\/$/;"	m	struct:fdtab
f	include/types/fd.h	/^		int (*f)(int fd);            \/* read\/write function *\/$/;"	m	struct:fdtab::__anon21
fdinfo	include/types/fd.h	/^struct fdinfo {$/;"	s
fdtab	include/types/fd.h	/^struct fdtab {$/;"	s
flags	include/types/fd.h	/^	unsigned short flags;                \/* various flags precising the exact status of this fd *\/$/;"	m	struct:fdtab
fork	include/types/fd.h	/^	int  REGPRM1   (*fork)(struct poller *p);            \/* post-fork re-opening *\/$/;"	m	struct:poller
init	include/types/fd.h	/^	int  REGPRM1   (*init)(struct poller *p);            \/* poller initialization *\/$/;"	m	struct:poller
is_set	include/types/fd.h	/^	int  REGPRM2 (*is_set)(const int fd, int dir);       \/* check if <fd> is being polled for dir <dir> *\/$/;"	m	struct:poller
local_port	include/types/fd.h	/^	int local_port;                      \/* optional local port *\/$/;"	m	struct:fdinfo
name	include/types/fd.h	/^	const char   *name;                                  \/* poller name *\/$/;"	m	struct:poller
owner	include/types/fd.h	/^	void *owner;                         \/* the session (or proxy) associated with this fd *\/$/;"	m	struct:fdtab
peeraddr	include/types/fd.h	/^	struct sockaddr *peeraddr;   \/* pointer to peer's network address, or NULL if unset *\/$/;"	m	struct:fdinfo	typeref:struct:fdinfo::sockaddr
peerlen	include/types/fd.h	/^	socklen_t peerlen;           \/* peer's address length, or 0 if unset *\/$/;"	m	struct:fdinfo
poll	include/types/fd.h	/^    	void REGPRM2   (*poll)(struct poller *p, int exp);   \/* the poller itself *\/$/;"	m	struct:poller
poller	include/types/fd.h	/^struct poller {$/;"	s
port_range	include/types/fd.h	/^	struct port_range *port_range;       \/* optional port range to bind to *\/$/;"	m	struct:fdinfo	typeref:struct:fdinfo::port_range
pref	include/types/fd.h	/^	int    pref;                                         \/* try pollers with higher preference first *\/$/;"	m	struct:poller
rem	include/types/fd.h	/^	void REGPRM1    (*rem)(const int fd);                \/* remove any polling on <fd> *\/$/;"	m	struct:poller
s1	include/types/fd.h	/^		unsigned int s1;             \/* Position in spec list+1. 0=not in list. *\/$/;"	m	struct:fdtab::__anon22
set	include/types/fd.h	/^	int  REGPRM2    (*set)(const int fd, int dir);       \/* set   polling on <fd> for <dir> *\/$/;"	m	struct:poller
spec	include/types/fd.h	/^	} spec;$/;"	m	struct:fdtab	typeref:struct:fdtab::__anon22
state	include/types/fd.h	/^	unsigned char state;                 \/* the state of this fd *\/$/;"	m	struct:fdtab
term	include/types/fd.h	/^	void REGPRM1   (*term)(struct poller *p);            \/* termination of this poller *\/$/;"	m	struct:poller
test	include/types/fd.h	/^	int  REGPRM1   (*test)(struct poller *p);            \/* pre-init check of the poller *\/$/;"	m	struct:poller
_TYPES_FREQ_CTR_H	include/types/freq_ctr.h	23;"	d
curr_ctr	include/types/freq_ctr.h	/^	unsigned int curr_ctr;  \/* cumulated value for current period *\/$/;"	m	struct:freq_ctr_period
curr_ctr	include/types/freq_ctr.h	/^	unsigned int curr_ctr; \/* cumulated value for current period *\/$/;"	m	struct:freq_ctr
curr_sec	include/types/freq_ctr.h	/^	unsigned int curr_sec; \/* start date of current period (seconds from now.tv_sec) *\/$/;"	m	struct:freq_ctr
curr_tick	include/types/freq_ctr.h	/^	unsigned int curr_tick; \/* start date of current period (wrapping ticks) *\/$/;"	m	struct:freq_ctr_period
freq_ctr	include/types/freq_ctr.h	/^struct freq_ctr {$/;"	s
freq_ctr_period	include/types/freq_ctr.h	/^struct freq_ctr_period {$/;"	s
prev_ctr	include/types/freq_ctr.h	/^	unsigned int prev_ctr;  \/* value for last period *\/$/;"	m	struct:freq_ctr_period
prev_ctr	include/types/freq_ctr.h	/^	unsigned int prev_ctr; \/* value for last period *\/$/;"	m	struct:freq_ctr
ACCESS_LVL_ADMIN	include/types/global.h	61;"	d
ACCESS_LVL_NONE	include/types/global.h	58;"	d
ACCESS_LVL_OPER	include/types/global.h	60;"	d
ACCESS_LVL_USER	include/types/global.h	59;"	d
GTUNE_USE_EPOLL	include/types/global.h	51;"	d
GTUNE_USE_KQUEUE	include/types/global.h	52;"	d
GTUNE_USE_POLL	include/types/global.h	50;"	d
GTUNE_USE_SELECT	include/types/global.h	49;"	d
GTUNE_USE_SEPOLL	include/types/global.h	53;"	d
GTUNE_USE_SPLICE	include/types/global.h	55;"	d
LSTCHK_CAP_BIND	include/types/global.h	43;"	d
LSTCHK_CTTPROXY	include/types/global.h	44;"	d
LSTCHK_NETADM	include/types/global.h	45;"	d
MODE_CHECK	include/types/global.h	37;"	d
MODE_DAEMON	include/types/global.h	35;"	d
MODE_DEBUG	include/types/global.h	34;"	d
MODE_FOREGROUND	include/types/global.h	40;"	d
MODE_QUIET	include/types/global.h	36;"	d
MODE_STARTING	include/types/global.h	39;"	d
MODE_VERBOSE	include/types/global.h	38;"	d
_TYPES_GLOBAL_H	include/types/global.h	23;"	d
bufsize	include/types/global.h	/^		int bufsize;       \/* buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon60
chksize	include/types/global.h	/^		int chksize;       \/* check buffer size in bytes, defaults to BUFSIZE *\/$/;"	m	struct:global::__anon60
chroot	include/types/global.h	/^	char *chroot;$/;"	m	struct:global
client_rcvbuf	include/types/global.h	/^		int client_rcvbuf; \/* set client rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon60
client_sndbuf	include/types/global.h	/^		int client_sndbuf; \/* set client sndbuf to this value if not null *\/$/;"	m	struct:global::__anon60
conn_per_sec	include/types/global.h	/^	struct freq_ctr conn_per_sec;$/;"	m	struct:global	typeref:struct:global::freq_ctr
cps_lim	include/types/global.h	/^	int cps_lim, cps_max;$/;"	m	struct:global
cps_max	include/types/global.h	/^	int cps_lim, cps_max;$/;"	m	struct:global
desc	include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global
gid	include/types/global.h	/^			gid_t gid;      \/* -1 to leave unchanged *\/$/;"	m	struct:global::__anon61::__anon62
gid	include/types/global.h	/^	int gid;$/;"	m	struct:global
global	include/types/global.h	/^struct global {$/;"	s
hardmaxconn	include/types/global.h	/^	int maxconn, hardmaxconn;$/;"	m	struct:global
last_checks	include/types/global.h	/^	int last_checks;$/;"	m	struct:global
level	include/types/global.h	/^			int level;      \/* access level (ACCESS_LVL_*) *\/$/;"	m	struct:global::__anon61::__anon62
log_send_hostname	include/types/global.h	/^	char *log_send_hostname;   \/* set hostname in syslog header *\/$/;"	m	struct:global
log_tag	include/types/global.h	/^	char *log_tag;                  \/* name for syslog *\/$/;"	m	struct:global
logsrvs	include/types/global.h	/^	struct list logsrvs;$/;"	m	struct:global	typeref:struct:global::list
max_http_hdr	include/types/global.h	/^		int max_http_hdr;  \/* max number of HTTP headers, use MAX_HTTP_HDR if zero *\/$/;"	m	struct:global::__anon60
maxaccept	include/types/global.h	/^		int maxaccept;     \/* max number of consecutive accept() *\/$/;"	m	struct:global::__anon60
maxconn	include/types/global.h	/^	int maxconn, hardmaxconn;$/;"	m	struct:global
maxpipes	include/types/global.h	/^	int maxpipes;		\/* max # of pipes *\/$/;"	m	struct:global
maxpollevents	include/types/global.h	/^		int maxpollevents; \/* max number of poll events at once *\/$/;"	m	struct:global::__anon60
maxrewrite	include/types/global.h	/^		int maxrewrite;    \/* buffer max rewrite size in bytes, defaults to MAXREWRITE *\/$/;"	m	struct:global::__anon60
maxsock	include/types/global.h	/^	int maxsock;		\/* max # of sockets *\/$/;"	m	struct:global
mode	include/types/global.h	/^			mode_t mode;    \/* 0 to leave unchanged *\/$/;"	m	struct:global::__anon61::__anon62
mode	include/types/global.h	/^	int mode;$/;"	m	struct:global
nbproc	include/types/global.h	/^	int nbproc;$/;"	m	struct:global
node	include/types/global.h	/^	char *node, *desc;		\/* node name & description *\/$/;"	m	struct:global
options	include/types/global.h	/^		int options;       \/* various tuning options *\/$/;"	m	struct:global::__anon60
pidfile	include/types/global.h	/^	char *pidfile;$/;"	m	struct:global
pipesize	include/types/global.h	/^		int pipesize;      \/* pipe size in bytes, system defaults if zero *\/$/;"	m	struct:global::__anon60
prefix	include/types/global.h	/^		char *prefix;           \/* path prefix of unix bind socket *\/$/;"	m	struct:global::__anon61
recv_enough	include/types/global.h	/^		int recv_enough;   \/* how many input bytes at once are "enough" *\/$/;"	m	struct:global::__anon60
req_count	include/types/global.h	/^	unsigned int req_count; \/* HTTP request counter *\/$/;"	m	struct:global
rlimit_memmax	include/types/global.h	/^	int rlimit_memmax;	\/* default ulimit-d in megs value : 0=unset *\/$/;"	m	struct:global
rlimit_nofile	include/types/global.h	/^	int rlimit_nofile;	\/* default ulimit-n value : 0=unset *\/$/;"	m	struct:global
server_rcvbuf	include/types/global.h	/^		int server_rcvbuf; \/* set server rcvbuf to this value if not null *\/$/;"	m	struct:global::__anon60
server_sndbuf	include/types/global.h	/^		int server_sndbuf; \/* set server sndbuf to this value if not null *\/$/;"	m	struct:global::__anon60
spread_checks	include/types/global.h	/^	int spread_checks;$/;"	m	struct:global
stats_fe	include/types/global.h	/^	struct proxy *stats_fe;     \/* the frontend holding the stats settings *\/$/;"	m	struct:global	typeref:struct:global::proxy
stats_sock	include/types/global.h	/^	struct listener stats_sock; \/* unix socket listener for statistics *\/$/;"	m	struct:global	typeref:struct:global::listener
tune	include/types/global.h	/^	} tune;$/;"	m	struct:global	typeref:struct:global::__anon60
uid	include/types/global.h	/^			uid_t uid;      \/* -1 to leave unchanged *\/$/;"	m	struct:global::__anon61::__anon62
uid	include/types/global.h	/^	int uid;$/;"	m	struct:global
unix_bind	include/types/global.h	/^	} unix_bind;$/;"	m	struct:global	typeref:struct:global::__anon61
ux	include/types/global.h	/^		} ux;$/;"	m	struct:global::__anon61	typeref:struct:global::__anon61::__anon62
_TYPES_HDR_IDX_H	include/types/hdr_idx.h	42;"	d
cr	include/types/hdr_idx.h	/^        unsigned cr   : 1; \/* CR present (1=CRLF, 0=LF). Total line size=len+cr+1. *\/$/;"	m	struct:hdr_idx_elem
hdr_idx	include/types/hdr_idx.h	/^struct hdr_idx {$/;"	s
hdr_idx_elem	include/types/hdr_idx.h	/^struct hdr_idx_elem {$/;"	s
last	include/types/hdr_idx.h	/^	short last;                 \/* length of the allocated area (1..size) *\/$/;"	m	struct:hdr_idx
len	include/types/hdr_idx.h	/^        unsigned len  :16; \/* length of this header not counting CRLF. 0=unused entry. *\/$/;"	m	struct:hdr_idx_elem
next	include/types/hdr_idx.h	/^        unsigned next :15; \/* offset of next header if len>0. 0=end of list. *\/$/;"	m	struct:hdr_idx_elem
size	include/types/hdr_idx.h	/^	short size;                 \/* size of the array including the head *\/$/;"	m	struct:hdr_idx
tail	include/types/hdr_idx.h	/^	signed short tail;          \/* last used element, 0..size-1 *\/$/;"	m	struct:hdr_idx
used	include/types/hdr_idx.h	/^	short used;                 \/* # of elements really used (1..size) *\/$/;"	m	struct:hdr_idx
v	include/types/hdr_idx.h	/^	struct hdr_idx_elem *v;     \/* the array itself *\/$/;"	m	struct:hdr_idx	typeref:struct:hdr_idx::hdr_idx_elem
_TYPES_LB_CHASH_H	include/types/lb_chash.h	23;"	d
act	include/types/lb_chash.h	/^	struct eb_root act;	\/* weighted chash entries of active servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root
bck	include/types/lb_chash.h	/^	struct eb_root bck;	\/* weighted chash entries of backup servers *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb_root
last	include/types/lb_chash.h	/^	struct eb32_node *last;	\/* last node found in case of round robin (or NULL) *\/$/;"	m	struct:lb_chash	typeref:struct:lb_chash::eb32_node
lb_chash	include/types/lb_chash.h	/^struct lb_chash {$/;"	s
_TYPES_LB_FAS_H	include/types/lb_fas.h	23;"	d
act	include/types/lb_fas.h	/^	struct eb_root act;	\/* weighted least conns on the active servers *\/$/;"	m	struct:lb_fas	typeref:struct:lb_fas::eb_root
bck	include/types/lb_fas.h	/^	struct eb_root bck;	\/* weighted least conns on the backup servers *\/$/;"	m	struct:lb_fas	typeref:struct:lb_fas::eb_root
lb_fas	include/types/lb_fas.h	/^struct lb_fas {$/;"	s
_TYPES_LB_FWLC_H	include/types/lb_fwlc.h	23;"	d
act	include/types/lb_fwlc.h	/^	struct eb_root act;	\/* weighted least conns on the active servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root
bck	include/types/lb_fwlc.h	/^	struct eb_root bck;	\/* weighted least conns on the backup servers *\/$/;"	m	struct:lb_fwlc	typeref:struct:lb_fwlc::eb_root
lb_fwlc	include/types/lb_fwlc.h	/^struct lb_fwlc {$/;"	s
_TYPES_LB_FWRR_H	include/types/lb_fwrr.h	23;"	d
act	include/types/lb_fwrr.h	/^	struct fwrr_group act;	\/* weighted round robin on the active servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group
bck	include/types/lb_fwrr.h	/^	struct fwrr_group bck;	\/* weighted round robin on the backup servers *\/$/;"	m	struct:lb_fwrr	typeref:struct:lb_fwrr::fwrr_group
curr	include/types/lb_fwrr.h	/^	struct eb_root curr;    \/* tree for servers in "current" time range *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
curr_pos	include/types/lb_fwrr.h	/^	int curr_pos;           \/* current position in the tree *\/$/;"	m	struct:fwrr_group
curr_weight	include/types/lb_fwrr.h	/^	int curr_weight;        \/* total weight of the current time range *\/$/;"	m	struct:fwrr_group
fwrr_group	include/types/lb_fwrr.h	/^struct fwrr_group {$/;"	s
init	include/types/lb_fwrr.h	/^	struct eb_root *init;   \/* servers waiting to be placed *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
lb_fwrr	include/types/lb_fwrr.h	/^struct lb_fwrr {$/;"	s
next	include/types/lb_fwrr.h	/^	struct eb_root *next;   \/* servers to be placed at next run *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
next_weight	include/types/lb_fwrr.h	/^	int next_weight;        \/* total weight of the next time range *\/$/;"	m	struct:fwrr_group
t0	include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::eb_root
t1	include/types/lb_fwrr.h	/^	struct eb_root t0, t1;  \/* "init" and "next" servers *\/$/;"	m	struct:fwrr_group	typeref:struct:fwrr_group::
LB_MAP_RECALC	include/types/lb_map.h	29;"	d
_TYPES_LB_MAP_H	include/types/lb_map.h	23;"	d
lb_map	include/types/lb_map.h	/^struct lb_map {$/;"	s
rr_idx	include/types/lb_map.h	/^	int rr_idx;		\/* next server to be elected in round robin mode *\/$/;"	m	struct:lb_map
srv	include/types/lb_map.h	/^	struct server **srv;	\/* the server map used to apply weights *\/$/;"	m	struct:lb_map	typeref:struct:lb_map::server
state	include/types/lb_map.h	/^	int state;		\/* LB_MAP_RECALC *\/$/;"	m	struct:lb_map
LF_EDARG	include/types/log.h	/^	LF_EDARG, \/\/ end arg }$/;"	e	enum:__anon95
LF_SEPARATOR	include/types/log.h	/^	LF_SEPARATOR,$/;"	e	enum:__anon95
LF_STARG	include/types/log.h	/^	LF_STARG, \/\/ { and within { }$/;"	e	enum:__anon95
LF_STARTVAR	include/types/log.h	/^	LF_STARTVAR,   \/\/ %$/;"	e	enum:__anon95
LF_TEXT	include/types/log.h	/^	LF_TEXT = 0,$/;"	e	enum:__anon95
LF_VAR	include/types/log.h	/^	LF_VAR, \/\/ after %$/;"	e	enum:__anon95
LOG_FMT_ACTCONN	include/types/log.h	/^	LOG_FMT_ACTCONN,$/;"	e	enum:__anon94
LOG_FMT_BACKEND	include/types/log.h	/^	LOG_FMT_BACKEND,$/;"	e	enum:__anon94
LOG_FMT_BACKENDIP	include/types/log.h	/^	LOG_FMT_BACKENDIP,$/;"	e	enum:__anon94
LOG_FMT_BACKENDPORT	include/types/log.h	/^	LOG_FMT_BACKENDPORT,$/;"	e	enum:__anon94
LOG_FMT_BCKQUEUE	include/types/log.h	/^	LOG_FMT_BCKQUEUE,$/;"	e	enum:__anon94
LOG_FMT_BECONN	include/types/log.h	/^	LOG_FMT_BECONN,$/;"	e	enum:__anon94
LOG_FMT_BYTES	include/types/log.h	/^	LOG_FMT_BYTES,$/;"	e	enum:__anon94
LOG_FMT_CCLIENT	include/types/log.h	/^	LOG_FMT_CCLIENT,$/;"	e	enum:__anon94
LOG_FMT_CLIENTIP	include/types/log.h	/^	LOG_FMT_CLIENTIP,$/;"	e	enum:__anon94
LOG_FMT_CLIENTPORT	include/types/log.h	/^	LOG_FMT_CLIENTPORT,$/;"	e	enum:__anon94
LOG_FMT_CONN	include/types/log.h	/^	LOG_FMT_CONN,$/;"	e	enum:__anon94
LOG_FMT_COUNTER	include/types/log.h	/^	LOG_FMT_COUNTER,$/;"	e	enum:__anon94
LOG_FMT_CSERVER	include/types/log.h	/^	LOG_FMT_CSERVER,$/;"	e	enum:__anon94
LOG_FMT_DATE	include/types/log.h	/^	LOG_FMT_DATE,$/;"	e	enum:__anon94
LOG_FMT_DATEGMT	include/types/log.h	/^	LOG_FMT_DATEGMT,$/;"	e	enum:__anon94
LOG_FMT_FECONN	include/types/log.h	/^	LOG_FMT_FECONN,$/;"	e	enum:__anon94
LOG_FMT_FRONTEND	include/types/log.h	/^	LOG_FMT_FRONTEND,$/;"	e	enum:__anon94
LOG_FMT_FRONTENDIP	include/types/log.h	/^	LOG_FMT_FRONTENDIP,$/;"	e	enum:__anon94
LOG_FMT_FRONTENDPORT	include/types/log.h	/^	LOG_FMT_FRONTENDPORT,$/;"	e	enum:__anon94
LOG_FMT_GLOBAL	include/types/log.h	/^	LOG_FMT_GLOBAL,$/;"	e	enum:__anon94
LOG_FMT_HDRREQUEST	include/types/log.h	/^	LOG_FMT_HDRREQUEST,$/;"	e	enum:__anon94
LOG_FMT_HDRREQUESTLIST	include/types/log.h	/^	LOG_FMT_HDRREQUESTLIST,$/;"	e	enum:__anon94
LOG_FMT_HDRRESPONS	include/types/log.h	/^	LOG_FMT_HDRRESPONS,$/;"	e	enum:__anon94
LOG_FMT_HDRRESPONSLIST	include/types/log.h	/^	LOG_FMT_HDRRESPONSLIST,$/;"	e	enum:__anon94
LOG_FMT_HOSTNAME	include/types/log.h	/^	LOG_FMT_HOSTNAME,$/;"	e	enum:__anon94
LOG_FMT_MS	include/types/log.h	/^	LOG_FMT_MS,$/;"	e	enum:__anon94
LOG_FMT_PID	include/types/log.h	/^	LOG_FMT_PID,$/;"	e	enum:__anon94
LOG_FMT_QUEUES	include/types/log.h	/^	LOG_FMT_QUEUES,$/;"	e	enum:__anon94
LOG_FMT_REQ	include/types/log.h	/^	LOG_FMT_REQ,$/;"	e	enum:__anon94
LOG_FMT_RETRIES	include/types/log.h	/^	LOG_FMT_RETRIES,$/;"	e	enum:__anon94
LOG_FMT_SEPARATOR	include/types/log.h	/^	LOG_FMT_SEPARATOR, \/* separator replaced by one space *\/$/;"	e	enum:__anon94
LOG_FMT_SERVER	include/types/log.h	/^	LOG_FMT_SERVER,$/;"	e	enum:__anon94
LOG_FMT_SERVERIP	include/types/log.h	/^	LOG_FMT_SERVERIP,$/;"	e	enum:__anon94
LOG_FMT_SERVERPORT	include/types/log.h	/^	LOG_FMT_SERVERPORT,$/;"	e	enum:__anon94
LOG_FMT_SRVCONN	include/types/log.h	/^	LOG_FMT_SRVCONN,$/;"	e	enum:__anon94
LOG_FMT_SRVQUEUE	include/types/log.h	/^	LOG_FMT_SRVQUEUE,$/;"	e	enum:__anon94
LOG_FMT_STATUS	include/types/log.h	/^	LOG_FMT_STATUS,$/;"	e	enum:__anon94
LOG_FMT_T	include/types/log.h	/^	LOG_FMT_T,$/;"	e	enum:__anon94
LOG_FMT_TC	include/types/log.h	/^	LOG_FMT_TC,$/;"	e	enum:__anon94
LOG_FMT_TERMSTATE	include/types/log.h	/^	LOG_FMT_TERMSTATE,$/;"	e	enum:__anon94
LOG_FMT_TERMSTATE_CK	include/types/log.h	/^	LOG_FMT_TERMSTATE_CK,$/;"	e	enum:__anon94
LOG_FMT_TEXT	include/types/log.h	/^	LOG_FMT_TEXT = 0, \/* raw text *\/$/;"	e	enum:__anon94
LOG_FMT_TQ	include/types/log.h	/^	LOG_FMT_TQ,$/;"	e	enum:__anon94
LOG_FMT_TR	include/types/log.h	/^	LOG_FMT_TR,$/;"	e	enum:__anon94
LOG_FMT_TS	include/types/log.h	/^	LOG_FMT_TS,$/;"	e	enum:__anon94
LOG_FMT_TT	include/types/log.h	/^	LOG_FMT_TT,$/;"	e	enum:__anon94
LOG_FMT_TW	include/types/log.h	/^	LOG_FMT_TW,$/;"	e	enum:__anon94
LOG_FMT_UNIQUEID	include/types/log.h	/^	LOG_FMT_UNIQUEID,$/;"	e	enum:__anon94
LOG_FMT_VARIABLE	include/types/log.h	/^	LOG_FMT_VARIABLE,$/;"	e	enum:__anon94
LOG_OPT_HEXA	include/types/log.h	113;"	d
LOG_OPT_MANDATORY	include/types/log.h	114;"	d
LOG_OPT_QUOTE	include/types/log.h	115;"	d
LW_BCKIP	include/types/log.h	130;"	d
LW_BYTES	include/types/log.h	126;"	d
LW_CLIP	include/types/log.h	121;"	d
LW_COOKIE	include/types/log.h	127;"	d
LW_FRTIP	include/types/log.h	131;"	d
LW_INIT	include/types/log.h	120;"	d
LW_REQ	include/types/log.h	124;"	d
LW_REQHDR	include/types/log.h	128;"	d
LW_RESP	include/types/log.h	125;"	d
LW_RSPHDR	include/types/log.h	129;"	d
LW_SVID	include/types/log.h	123;"	d
LW_SVIP	include/types/log.h	122;"	d
MAX_SYSLOG_LEN	include/types/log.h	30;"	d
NB_LOG_FACILITIES	include/types/log.h	31;"	d
NB_LOG_LEVELS	include/types/log.h	32;"	d
SYSLOG_PORT	include/types/log.h	33;"	d
UNIQUEID_LEN	include/types/log.h	34;"	d
_TYPES_LOG_H	include/types/log.h	23;"	d
addr	include/types/log.h	/^	struct sockaddr_storage addr;$/;"	m	struct:logsrv	typeref:struct:logsrv::sockaddr_storage
arg	include/types/log.h	/^	char *arg;$/;"	m	struct:logformat_node
facility	include/types/log.h	/^	int facility;$/;"	m	struct:logsrv
level	include/types/log.h	/^	int level;$/;"	m	struct:logsrv
list	include/types/log.h	/^	struct list list;$/;"	m	struct:logformat_node	typeref:struct:logformat_node::list
list	include/types/log.h	/^	struct list list;$/;"	m	struct:logsrv	typeref:struct:logsrv::list
logformat_node	include/types/log.h	/^struct logformat_node {$/;"	s
logsrv	include/types/log.h	/^struct logsrv {$/;"	s
minlvl	include/types/log.h	/^	int minlvl;$/;"	m	struct:logsrv
options	include/types/log.h	/^	int options;$/;"	m	struct:logformat_node
type	include/types/log.h	/^	int type;$/;"	m	struct:logformat_node
_TYPES_PEERS_H	include/types/peers.h	23;"	d
addr	include/types/peers.h	/^	struct sockaddr_storage addr;  \/* peer address *\/$/;"	m	struct:peer	typeref:struct:peer::sockaddr_storage
conf	include/types/peers.h	/^	} conf;				 \/* config information *\/$/;"	m	struct:peers	typeref:struct:peers::__anon24
conf	include/types/peers.h	/^	} conf;		  	  \/* config information *\/$/;"	m	struct:peer	typeref:struct:peer::__anon23
confirm	include/types/peers.h	/^	unsigned int confirm;	      \/* confirm message counter *\/$/;"	m	struct:peer_session
count	include/types/peers.h	/^	int count;			 \/* total of peers *\/$/;"	m	struct:peers
file	include/types/peers.h	/^		const char *file;	 \/* file where the section appears *\/$/;"	m	struct:peers::__anon24
file	include/types/peers.h	/^		const char *file; \/* file where the section appears *\/$/;"	m	struct:peer::__anon23
flags	include/types/peers.h	/^	unsigned int flags;		    \/* current table resync state *\/$/;"	m	struct:shared_table
flags	include/types/peers.h	/^	unsigned int flags; 	      \/* peer session flags *\/$/;"	m	struct:peer_session
id	include/types/peers.h	/^	char *id;			 \/* peer section name *\/$/;"	m	struct:peers
id	include/types/peers.h	/^	char *id;$/;"	m	struct:peer
last_change	include/types/peers.h	/^	time_t last_change;$/;"	m	struct:peer
last_change	include/types/peers.h	/^	time_t last_change;$/;"	m	struct:peers
lastack	include/types/peers.h	/^	unsigned int lastack;	      \/* last acked update *\/$/;"	m	struct:peer_session
lastpush	include/types/peers.h	/^	unsigned int lastpush;	      \/* last pushed update *\/$/;"	m	struct:peer_session
line	include/types/peers.h	/^		int line;		 \/* line where the section appears *\/$/;"	m	struct:peers::__anon24
line	include/types/peers.h	/^		int line;	  \/* line where the section appears *\/$/;"	m	struct:peer::__anon23
local	include/types/peers.h	/^	int local;		  \/* proxy state *\/$/;"	m	struct:peer
local_session	include/types/peers.h	/^	struct peer_session *local_session; \/* local peer session *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::peer_session
next	include/types/peers.h	/^	struct peer *next;	  \/* next peer in the list *\/$/;"	m	struct:peer	typeref:struct:peer::peer
next	include/types/peers.h	/^	struct peer_session *next;$/;"	m	struct:peer_session	typeref:struct:peer_session::peer_session
next	include/types/peers.h	/^	struct peers *next;		 \/* next peer section *\/$/;"	m	struct:peers	typeref:struct:peers::peers
next	include/types/peers.h	/^	struct shared_table *next;	    \/* next shared table in list *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::shared_table
peer	include/types/peers.h	/^	struct peer *peer;	      \/* current peer *\/$/;"	m	struct:peer_session	typeref:struct:peer_session::peer
peer	include/types/peers.h	/^struct peer {$/;"	s
peer_session	include/types/peers.h	/^struct peer_session {$/;"	s
peers	include/types/peers.h	/^	struct peers *peers;$/;"	m	struct:peer	typeref:struct:peer::peers
peers	include/types/peers.h	/^struct peers {$/;"	s
peers_fe	include/types/peers.h	/^	struct proxy *peers_fe;		 \/* peer frontend *\/$/;"	m	struct:peers	typeref:struct:peers::proxy
proto	include/types/peers.h	/^	struct protocol *proto;	       \/* peer address protocol *\/$/;"	m	struct:peer	typeref:struct:peer::protocol
pushack	include/types/peers.h	/^	unsigned int pushack;	      \/* last commited update to ack *\/$/;"	m	struct:peer_session
pushed	include/types/peers.h	/^	unsigned int pushed;	      \/* equal to last pushed data or to table local update in case of total push$/;"	m	struct:peer_session
reconnect	include/types/peers.h	/^	unsigned int reconnect;	      \/* next connect timer *\/$/;"	m	struct:peer_session
remote	include/types/peers.h	/^	struct peer *remote;		 \/* remote peers list *\/$/;"	m	struct:peers	typeref:struct:peers::peer
resync_timeout	include/types/peers.h	/^	unsigned int resync_timeout;	    \/* resync timeout timer *\/$/;"	m	struct:shared_table
session	include/types/peers.h	/^	struct session *session;      \/* current transport session *\/$/;"	m	struct:peer_session	typeref:struct:peer_session::session
sessions	include/types/peers.h	/^	struct peer_session *sessions;	    \/* peer sessions list *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::peer_session
shared_table	include/types/peers.h	/^struct shared_table {$/;"	s
sock	include/types/peers.h	/^	struct sock_ops *sock;         \/* peer socket operations *\/$/;"	m	struct:peer	typeref:struct:peer::sock_ops
sock_init_arg	include/types/peers.h	/^	void *sock_init_arg;           \/* socket operations's opaque init argument if needed *\/$/;"	m	struct:peer
state	include/types/peers.h	/^	int state;			 \/* proxy state *\/$/;"	m	struct:peers
statuscode	include/types/peers.h	/^	unsigned int statuscode;      \/* current\/last session status code *\/$/;"	m	struct:peer_session
sync_task	include/types/peers.h	/^	struct task *sync_task;		    \/* main sync task *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::task
table	include/types/peers.h	/^	struct shared_table *table;   \/* shared table *\/$/;"	m	struct:peer_session	typeref:struct:peer_session::shared_table
table	include/types/peers.h	/^	struct stktable *table;		    \/* stick table to sync *\/$/;"	m	struct:shared_table	typeref:struct:shared_table::stktable
tables	include/types/peers.h	/^	struct shared_table *tables;	 \/* registered shared tables *\/$/;"	m	struct:peers	typeref:struct:peers::shared_table
teaching_origin	include/types/peers.h	/^	unsigned int teaching_origin; \/* resync teaching origine update *\/$/;"	m	struct:peer_session
update	include/types/peers.h	/^	unsigned int update;	      \/* current peer acked update *\/$/;"	m	struct:peer_session
_TYPES_PIPE_H	include/types/pipe.h	23;"	d
cons	include/types/pipe.h	/^	int cons;	\/* FD the consumer must read from ; -1 if none *\/$/;"	m	struct:pipe
data	include/types/pipe.h	/^	int data;	\/* number of bytes present in the pipe  *\/$/;"	m	struct:pipe
next	include/types/pipe.h	/^	struct pipe *next;$/;"	m	struct:pipe	typeref:struct:pipe::pipe
pipe	include/types/pipe.h	/^struct pipe {$/;"	s
prod	include/types/pipe.h	/^	int prod;	\/* FD the producer must write to ; -1 if none *\/$/;"	m	struct:pipe
_TYPES_PORT_RANGE_H	include/types/port_range.h	23;"	d
avail	include/types/port_range.h	/^	int avail;			\/* number of available ports left *\/$/;"	m	struct:port_range
get	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range
port_range	include/types/port_range.h	/^struct port_range {$/;"	s
ports	include/types/port_range.h	/^	uint16_t ports[0];		\/* array of <size> ports, in host byte order *\/$/;"	m	struct:port_range
put	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range
size	include/types/port_range.h	/^	int size, get, put;		\/* range size, and get\/put positions *\/$/;"	m	struct:port_range
HTTP_AUTH_BASIC	include/types/proto_http.h	/^	HTTP_AUTH_BASIC,$/;"	e	enum:__anon67
HTTP_AUTH_DIGEST	include/types/proto_http.h	/^	HTTP_AUTH_DIGEST,$/;"	e	enum:__anon67
HTTP_AUTH_UNKNOWN	include/types/proto_http.h	/^	HTTP_AUTH_UNKNOWN	= 0,$/;"	e	enum:__anon67
HTTP_AUTH_WRONG	include/types/proto_http.h	/^	HTTP_AUTH_WRONG		= -1,		\/* missing or unknown *\/$/;"	e	enum:__anon67
HTTP_ERR_200	include/types/proto_http.h	/^	HTTP_ERR_200 = 0,$/;"	e	enum:__anon69
HTTP_ERR_400	include/types/proto_http.h	/^	HTTP_ERR_400,$/;"	e	enum:__anon69
HTTP_ERR_403	include/types/proto_http.h	/^	HTTP_ERR_403,$/;"	e	enum:__anon69
HTTP_ERR_408	include/types/proto_http.h	/^	HTTP_ERR_408,$/;"	e	enum:__anon69
HTTP_ERR_500	include/types/proto_http.h	/^	HTTP_ERR_500,$/;"	e	enum:__anon69
HTTP_ERR_502	include/types/proto_http.h	/^	HTTP_ERR_502,$/;"	e	enum:__anon69
HTTP_ERR_503	include/types/proto_http.h	/^	HTTP_ERR_503,$/;"	e	enum:__anon69
HTTP_ERR_504	include/types/proto_http.h	/^	HTTP_ERR_504,$/;"	e	enum:__anon69
HTTP_ERR_SIZE	include/types/proto_http.h	/^	HTTP_ERR_SIZE$/;"	e	enum:__anon69
HTTP_METH_CONNECT	include/types/proto_http.h	/^	HTTP_METH_CONNECT,$/;"	e	enum:__anon66
HTTP_METH_DELETE	include/types/proto_http.h	/^	HTTP_METH_DELETE,$/;"	e	enum:__anon66
HTTP_METH_GET	include/types/proto_http.h	/^	HTTP_METH_GET,$/;"	e	enum:__anon66
HTTP_METH_HEAD	include/types/proto_http.h	/^	HTTP_METH_HEAD,$/;"	e	enum:__anon66
HTTP_METH_NONE	include/types/proto_http.h	/^	HTTP_METH_NONE = 0,$/;"	e	enum:__anon66
HTTP_METH_OPTIONS	include/types/proto_http.h	/^	HTTP_METH_OPTIONS,$/;"	e	enum:__anon66
HTTP_METH_OTHER	include/types/proto_http.h	/^	HTTP_METH_OTHER,$/;"	e	enum:__anon66
HTTP_METH_POST	include/types/proto_http.h	/^	HTTP_METH_POST,$/;"	e	enum:__anon66
HTTP_METH_PUT	include/types/proto_http.h	/^	HTTP_METH_PUT,$/;"	e	enum:__anon66
HTTP_METH_TRACE	include/types/proto_http.h	/^	HTTP_METH_TRACE,$/;"	e	enum:__anon66
HTTP_MSGF_CNT_LEN	include/types/proto_http.h	183;"	d
HTTP_MSGF_TE_CHNK	include/types/proto_http.h	184;"	d
HTTP_MSGF_VER_11	include/types/proto_http.h	191;"	d
HTTP_MSGF_XFER_LEN	include/types/proto_http.h	190;"	d
HTTP_MSG_100_SENT	include/types/proto_http.h	166;"	d
HTTP_MSG_BODY	include/types/proto_http.h	165;"	d
HTTP_MSG_CHUNK_SIZE	include/types/proto_http.h	167;"	d
HTTP_MSG_CLOSED	include/types/proto_http.h	175;"	d
HTTP_MSG_CLOSING	include/types/proto_http.h	174;"	d
HTTP_MSG_DATA	include/types/proto_http.h	168;"	d
HTTP_MSG_DATA_CRLF	include/types/proto_http.h	169;"	d
HTTP_MSG_DONE	include/types/proto_http.h	173;"	d
HTTP_MSG_ERROR	include/types/proto_http.h	158;"	d
HTTP_MSG_HDR_COL	include/types/proto_http.h	144;"	d
HTTP_MSG_HDR_FIRST	include/types/proto_http.h	142;"	d
HTTP_MSG_HDR_L1_LF	include/types/proto_http.h	146;"	d
HTTP_MSG_HDR_L1_LWS	include/types/proto_http.h	147;"	d
HTTP_MSG_HDR_L1_SP	include/types/proto_http.h	145;"	d
HTTP_MSG_HDR_L2_LF	include/types/proto_http.h	149;"	d
HTTP_MSG_HDR_L2_LWS	include/types/proto_http.h	150;"	d
HTTP_MSG_HDR_NAME	include/types/proto_http.h	143;"	d
HTTP_MSG_HDR_VAL	include/types/proto_http.h	148;"	d
HTTP_MSG_LAST_LF	include/types/proto_http.h	152;"	d
HTTP_MSG_RPBEFORE	include/types/proto_http.h	129;"	d
HTTP_MSG_RPBEFORE_CR	include/types/proto_http.h	130;"	d
HTTP_MSG_RPCODE	include/types/proto_http.h	135;"	d
HTTP_MSG_RPCODE_SP	include/types/proto_http.h	136;"	d
HTTP_MSG_RPLINE_END	include/types/proto_http.h	138;"	d
HTTP_MSG_RPREASON	include/types/proto_http.h	137;"	d
HTTP_MSG_RPVER	include/types/proto_http.h	133;"	d
HTTP_MSG_RPVER_SP	include/types/proto_http.h	134;"	d
HTTP_MSG_RQBEFORE	include/types/proto_http.h	118;"	d
HTTP_MSG_RQBEFORE_CR	include/types/proto_http.h	119;"	d
HTTP_MSG_RQLINE_END	include/types/proto_http.h	127;"	d
HTTP_MSG_RQMETH	include/types/proto_http.h	122;"	d
HTTP_MSG_RQMETH_SP	include/types/proto_http.h	123;"	d
HTTP_MSG_RQURI	include/types/proto_http.h	124;"	d
HTTP_MSG_RQURI_SP	include/types/proto_http.h	125;"	d
HTTP_MSG_RQVER	include/types/proto_http.h	126;"	d
HTTP_MSG_TRAILERS	include/types/proto_http.h	170;"	d
HTTP_MSG_TUNNEL	include/types/proto_http.h	176;"	d
HTTP_REQ_ACT_ALLOW	include/types/proto_http.h	/^	HTTP_REQ_ACT_ALLOW,$/;"	e	enum:__anon68
HTTP_REQ_ACT_DENY	include/types/proto_http.h	/^	HTTP_REQ_ACT_DENY,$/;"	e	enum:__anon68
HTTP_REQ_ACT_HTTP_AUTH	include/types/proto_http.h	/^	HTTP_REQ_ACT_HTTP_AUTH,$/;"	e	enum:__anon68
HTTP_REQ_ACT_MAX	include/types/proto_http.h	/^	HTTP_REQ_ACT_MAX$/;"	e	enum:__anon68
HTTP_REQ_ACT_UNKNOWN	include/types/proto_http.h	/^	HTTP_REQ_ACT_UNKNOWN = 0,$/;"	e	enum:__anon68
PERSIST_TYPE_FORCE	include/types/proto_http.h	/^	PERSIST_TYPE_FORCE,             \/* force-persist *\/$/;"	e	enum:__anon65
PERSIST_TYPE_IGNORE	include/types/proto_http.h	/^	PERSIST_TYPE_IGNORE,            \/* ignore-persist *\/$/;"	e	enum:__anon65
PERSIST_TYPE_NONE	include/types/proto_http.h	/^	PERSIST_TYPE_NONE = 0,          \/* no persistence *\/$/;"	e	enum:__anon65
REDIRECT_FLAG_APPEND_SLASH	include/types/proto_http.h	/^	REDIRECT_FLAG_APPEND_SLASH = 2,	\/* append a slash if missing at the end *\/$/;"	e	enum:__anon63
REDIRECT_FLAG_DROP_QS	include/types/proto_http.h	/^	REDIRECT_FLAG_DROP_QS = 1,	\/* drop query string *\/$/;"	e	enum:__anon63
REDIRECT_FLAG_NONE	include/types/proto_http.h	/^	REDIRECT_FLAG_NONE = 0,$/;"	e	enum:__anon63
REDIRECT_TYPE_LOCATION	include/types/proto_http.h	/^	REDIRECT_TYPE_LOCATION,         \/* location redirect *\/$/;"	e	enum:__anon64
REDIRECT_TYPE_NONE	include/types/proto_http.h	/^	REDIRECT_TYPE_NONE = 0,         \/* no redirection *\/$/;"	e	enum:__anon64
REDIRECT_TYPE_PREFIX	include/types/proto_http.h	/^	REDIRECT_TYPE_PREFIX,           \/* prefix redirect *\/$/;"	e	enum:__anon64
STAT_STATUS_DENY	include/types/proto_http.h	/^	STAT_STATUS_DENY,	\/* action denied *\/$/;"	e	enum:__anon71
STAT_STATUS_DONE	include/types/proto_http.h	/^	STAT_STATUS_DONE,	\/* the action is successful *\/$/;"	e	enum:__anon71
STAT_STATUS_ERRP	include/types/proto_http.h	/^	STAT_STATUS_ERRP,	\/* an error occured due to invalid values in parameters *\/$/;"	e	enum:__anon71
STAT_STATUS_EXCD	include/types/proto_http.h	/^	STAT_STATUS_EXCD,	\/* an error occured because the buffer couldn't store all data *\/$/;"	e	enum:__anon71
STAT_STATUS_INIT	include/types/proto_http.h	/^	STAT_STATUS_INIT = 0,$/;"	e	enum:__anon71
STAT_STATUS_NONE	include/types/proto_http.h	/^	STAT_STATUS_NONE,	\/* nothing happened (no action chosen or servers state didn't change) *\/$/;"	e	enum:__anon71
STAT_STATUS_PART	include/types/proto_http.h	/^	STAT_STATUS_PART,	\/* the action is partially successful *\/$/;"	e	enum:__anon71
STAT_STATUS_SIZE	include/types/proto_http.h	/^	STAT_STATUS_SIZE$/;"	e	enum:__anon71
STAT_STATUS_UNKN	include/types/proto_http.h	/^	STAT_STATUS_UNKN,	\/* an unknown error occured, shouldn't happen *\/$/;"	e	enum:__anon71
ST_ADM_ACTION_DISABLE	include/types/proto_http.h	/^	ST_ADM_ACTION_DISABLE,$/;"	e	enum:__anon70
ST_ADM_ACTION_ENABLE	include/types/proto_http.h	/^	ST_ADM_ACTION_ENABLE,$/;"	e	enum:__anon70
ST_ADM_ACTION_NONE	include/types/proto_http.h	/^	ST_ADM_ACTION_NONE = 0,$/;"	e	enum:__anon70
ST_ADM_ACTION_SHUTDOWN	include/types/proto_http.h	/^	ST_ADM_ACTION_SHUTDOWN,$/;"	e	enum:__anon70
ST_ADM_ACTION_START	include/types/proto_http.h	/^	ST_ADM_ACTION_START,$/;"	e	enum:__anon70
ST_ADM_ACTION_STOP	include/types/proto_http.h	/^	ST_ADM_ACTION_STOP,$/;"	e	enum:__anon70
TX_CACHEABLE	include/types/proto_http.h	63;"	d
TX_CACHE_COOK	include/types/proto_http.h	64;"	d
TX_CACHE_SHIFT	include/types/proto_http.h	65;"	d
TX_CK_DOWN	include/types/proto_http.h	42;"	d
TX_CK_EXPIRED	include/types/proto_http.h	44;"	d
TX_CK_INVALID	include/types/proto_http.h	41;"	d
TX_CK_MASK	include/types/proto_http.h	47;"	d
TX_CK_NONE	include/types/proto_http.h	40;"	d
TX_CK_OLD	include/types/proto_http.h	45;"	d
TX_CK_SHIFT	include/types/proto_http.h	48;"	d
TX_CK_UNUSED	include/types/proto_http.h	46;"	d
TX_CK_VALID	include/types/proto_http.h	43;"	d
TX_CLALLOW	include/types/proto_http.h	34;"	d
TX_CLDENY	include/types/proto_http.h	33;"	d
TX_CLTARPIT	include/types/proto_http.h	37;"	d
TX_CON_CLO_SET	include/types/proto_http.h	82;"	d
TX_CON_KAL_SET	include/types/proto_http.h	83;"	d
TX_CON_WANT_CLO	include/types/proto_http.h	79;"	d
TX_CON_WANT_KAL	include/types/proto_http.h	77;"	d
TX_CON_WANT_MSK	include/types/proto_http.h	80;"	d
TX_CON_WANT_SCL	include/types/proto_http.h	78;"	d
TX_CON_WANT_TUN	include/types/proto_http.h	76;"	d
TX_HDR_CONN_CLO	include/types/proto_http.h	90;"	d
TX_HDR_CONN_KAL	include/types/proto_http.h	91;"	d
TX_HDR_CONN_PRS	include/types/proto_http.h	89;"	d
TX_NOT_FIRST	include/types/proto_http.h	95;"	d
TX_SCK_DELETED	include/types/proto_http.h	53;"	d
TX_SCK_FOUND	include/types/proto_http.h	52;"	d
TX_SCK_INSERTED	include/types/proto_http.h	54;"	d
TX_SCK_MASK	include/types/proto_http.h	57;"	d
TX_SCK_NONE	include/types/proto_http.h	51;"	d
TX_SCK_PRESENT	include/types/proto_http.h	60;"	d
TX_SCK_REPLACED	include/types/proto_http.h	55;"	d
TX_SCK_SHIFT	include/types/proto_http.h	58;"	d
TX_SCK_UPDATED	include/types/proto_http.h	56;"	d
TX_SVALLOW	include/types/proto_http.h	36;"	d
TX_SVDENY	include/types/proto_http.h	35;"	d
TX_USE_PX_CONN	include/types/proto_http.h	92;"	d
TX_WAIT_NEXT_RQ	include/types/proto_http.h	87;"	d
_TYPES_PROTO_HTTP_H	include/types/proto_http.h	23;"	d
action	include/types/proto_http.h	/^	unsigned int action;$/;"	m	struct:http_req_rule
auth	include/types/proto_http.h	/^	struct http_auth_data auth;	\/* HTTP auth data *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_auth_data
body_len	include/types/proto_http.h	/^	unsigned long long body_len;           \/* total known length of the body, excluding encoding *\/$/;"	m	struct:http_msg
buf	include/types/proto_http.h	/^	struct buffer *buf;                    \/* pointer to the buffer which holds the message *\/$/;"	m	struct:http_msg	typeref:struct:http_msg::buffer
c	include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon72::__anon74
c_l	include/types/proto_http.h	/^			int c, c_l;            \/* CODE, length *\/$/;"	m	struct:http_msg::__anon72::__anon74
cap	include/types/proto_http.h	/^	char **cap;                            \/* array of captured headers (may be NULL) *\/$/;"	m	struct:http_msg
chunk_len	include/types/proto_http.h	/^	unsigned long long chunk_len;          \/* cache for last chunk size or content-length header value *\/$/;"	m	struct:http_msg
cli_cookie	include/types/proto_http.h	/^	char *cli_cookie;               \/* cookie presented by the client, in capture mode *\/$/;"	m	struct:http_txn
cond	include/types/proto_http.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:http_req_rule	typeref:struct:http_req_rule::acl_cond
cookie_first_date	include/types/proto_http.h	/^	int cookie_first_date;          \/* if non-zero, first date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn
cookie_last_date	include/types/proto_http.h	/^	int cookie_last_date;           \/* if non-zero, last date the expirable cookie was set\/seen *\/$/;"	m	struct:http_txn
del	include/types/proto_http.h	/^	int  del;  \/* relative to line *\/$/;"	m	struct:hdr_ctx
eoh	include/types/proto_http.h	/^	unsigned int eoh;                      \/* End Of Headers, relative to buffer *\/$/;"	m	struct:http_msg
eol	include/types/proto_http.h	/^	unsigned int eol;                      \/* end of line *\/$/;"	m	struct:http_msg
err_pos	include/types/proto_http.h	/^	int err_pos;                           \/* err handling: -2=block, -1=pass, 0+=detected *\/$/;"	m	struct:http_msg
flags	include/types/proto_http.h	/^	unsigned int flags;                    \/* flags describing the message (HTTP version, ...) *\/$/;"	m	struct:http_msg
flags	include/types/proto_http.h	/^	unsigned int flags;             \/* transaction flags *\/$/;"	m	struct:http_txn
hdr_ctx	include/types/proto_http.h	/^struct hdr_ctx {$/;"	s
hdr_idx	include/types/proto_http.h	/^	struct hdr_idx hdr_idx;         \/* array of header indexes (max: global.tune.max_http_hdr) *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::hdr_idx
http_auth	include/types/proto_http.h	/^	} http_auth;$/;"	m	struct:http_req_rule	typeref:struct:http_req_rule::__anon75
http_auth_data	include/types/proto_http.h	/^struct http_auth_data {$/;"	s
http_meth_t	include/types/proto_http.h	/^} http_meth_t;$/;"	t	typeref:enum:__anon66
http_msg	include/types/proto_http.h	/^struct http_msg {$/;"	s
http_req_rule	include/types/proto_http.h	/^struct http_req_rule {$/;"	s
http_txn	include/types/proto_http.h	/^struct http_txn {$/;"	s
idx	include/types/proto_http.h	/^	int  idx;$/;"	m	struct:hdr_ctx
l	include/types/proto_http.h	/^			int l;                 \/* request line length (not including CR) *\/$/;"	m	struct:http_msg::__anon72::__anon73
l	include/types/proto_http.h	/^			int l;                 \/* status line length (not including CR) *\/$/;"	m	struct:http_msg::__anon72::__anon74
line	include/types/proto_http.h	/^	char *line;$/;"	m	struct:hdr_ctx
list	include/types/proto_http.h	/^	struct list list;$/;"	m	struct:http_req_rule	typeref:struct:http_req_rule::list
m_l	include/types/proto_http.h	/^			int m_l;               \/* METHOD length (method starts at buf->p) *\/$/;"	m	struct:http_msg::__anon72::__anon73
meth	include/types/proto_http.h	/^	http_meth_t meth;               \/* HTTP method *\/$/;"	m	struct:http_txn
method	include/types/proto_http.h	/^	int method;			\/* one of HTTP_AUTH_* *\/$/;"	m	struct:http_auth_data
method_data	include/types/proto_http.h	/^	struct chunk method_data;	\/* points to the creditial part from 'Authorization:' header *\/$/;"	m	struct:http_auth_data	typeref:struct:http_auth_data::chunk
msg_state	include/types/proto_http.h	/^	unsigned int msg_state;                \/* where we are in the current message parsing *\/$/;"	m	struct:http_msg
next	include/types/proto_http.h	/^	unsigned int next;                     \/* pointer to next byte to parse, relative to buf->p *\/$/;"	m	struct:http_msg
pass	include/types/proto_http.h	/^	char *user, *pass;		\/* extracted username & password *\/$/;"	m	struct:http_auth_data
prev	include/types/proto_http.h	/^	int  prev; \/* index of previous header *\/$/;"	m	struct:hdr_ctx
r	include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon72::__anon74
r_l	include/types/proto_http.h	/^			int r, r_l;            \/* REASON, length *\/$/;"	m	struct:http_msg::__anon72::__anon74
realm	include/types/proto_http.h	/^		char *realm;$/;"	m	struct:http_req_rule::__anon75
req	include/types/proto_http.h	/^	struct http_msg req;            \/* HTTP request message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg
rq	include/types/proto_http.h	/^		} rq;                          \/* request line : field, length *\/$/;"	m	union:http_msg::__anon72	typeref:struct:http_msg::__anon72::__anon73
rsp	include/types/proto_http.h	/^	struct http_msg rsp;            \/* HTTP response message *\/$/;"	m	struct:http_txn	typeref:struct:http_txn::http_msg
sessid	include/types/proto_http.h	/^	char *sessid;                   \/* the appsession id, if found in the request or in the response *\/$/;"	m	struct:http_txn
sl	include/types/proto_http.h	/^	} sl;                                  \/* start line *\/$/;"	m	struct:http_msg	typeref:union:http_msg::__anon72
sol	include/types/proto_http.h	/^	unsigned int sol;                      \/* start of current line during parsing otherwise zero *\/$/;"	m	struct:http_msg
sov	include/types/proto_http.h	/^	unsigned int sov;                      \/* current header: start of value *\/$/;"	m	struct:http_msg
srv_cookie	include/types/proto_http.h	/^	char *srv_cookie;               \/* cookie presented by the server, in capture mode *\/$/;"	m	struct:http_txn
st	include/types/proto_http.h	/^		} st;                          \/* status line : field, length *\/$/;"	m	union:http_msg::__anon72	typeref:struct:http_msg::__anon72::__anon74
status	include/types/proto_http.h	/^	int status;                     \/* HTTP status from the server, negative if from proxy *\/$/;"	m	struct:http_txn
tws	include/types/proto_http.h	/^	int  tws;  \/* added to vlen if some trailing white spaces are present *\/$/;"	m	struct:hdr_ctx
u	include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon72::__anon73
u_l	include/types/proto_http.h	/^			int u, u_l;            \/* URI, length *\/$/;"	m	struct:http_msg::__anon72::__anon73
uri	include/types/proto_http.h	/^	char *uri;                      \/* first line if log needed, NULL otherwise *\/$/;"	m	struct:http_txn
user	include/types/proto_http.h	/^	char *user, *pass;		\/* extracted username & password *\/$/;"	m	struct:http_auth_data
v	include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon72::__anon73
v_l	include/types/proto_http.h	/^			int v, v_l;            \/* VERSION, length *\/$/;"	m	struct:http_msg::__anon72::__anon73
v_l	include/types/proto_http.h	/^			int v_l;               \/* VERSION length (version starts at buf->p) *\/$/;"	m	struct:http_msg::__anon72::__anon74
val	include/types/proto_http.h	/^	int  val;  \/* relative to line, may skip some leading white spaces *\/$/;"	m	struct:hdr_ctx
vlen	include/types/proto_http.h	/^	int  vlen; \/* relative to line+val, stops before trailing white spaces *\/$/;"	m	struct:hdr_ctx
TCP_ACT_ACCEPT	include/types/proto_tcp.h	/^	TCP_ACT_ACCEPT = 1,$/;"	e	enum:__anon92
TCP_ACT_REJECT	include/types/proto_tcp.h	/^	TCP_ACT_REJECT = 2,$/;"	e	enum:__anon92
TCP_ACT_TRK_SC1	include/types/proto_tcp.h	/^	TCP_ACT_TRK_SC1 = 3,$/;"	e	enum:__anon92
TCP_ACT_TRK_SC2	include/types/proto_tcp.h	/^	TCP_ACT_TRK_SC2 = 4,$/;"	e	enum:__anon92
_TYPES_PROTO_TCP_H	include/types/proto_tcp.h	23;"	d
act_prm	include/types/proto_tcp.h	/^	} act_prm;$/;"	m	struct:tcp_rule	typeref:union:tcp_rule::__anon93
action	include/types/proto_tcp.h	/^	int action;$/;"	m	struct:tcp_rule
cond	include/types/proto_tcp.h	/^	struct acl_cond *cond;$/;"	m	struct:tcp_rule	typeref:struct:tcp_rule::acl_cond
list	include/types/proto_tcp.h	/^	struct list list;$/;"	m	struct:tcp_rule	typeref:struct:tcp_rule::list
tcp_rule	include/types/proto_tcp.h	/^struct tcp_rule {$/;"	s
trk_ctr	include/types/proto_tcp.h	/^		struct track_ctr_prm trk_ctr;$/;"	m	union:tcp_rule::__anon93	typeref:struct:tcp_rule::__anon93::track_ctr_prm
LI_ASSIGNED	include/types/protocols.h	/^	LI_ASSIGNED,    \/* assigned to the protocol, but not listening yet *\/$/;"	e	enum:__anon6
LI_FULL	include/types/protocols.h	/^	LI_FULL,        \/* reached its connection limit *\/$/;"	e	enum:__anon6
LI_INIT	include/types/protocols.h	/^	LI_INIT,        \/* all parameters filled in, but not assigned yet *\/$/;"	e	enum:__anon6
LI_LIMITED	include/types/protocols.h	/^	LI_LIMITED,     \/* transient state: limits have been reached, listener is queued *\/$/;"	e	enum:__anon6
LI_LISTEN	include/types/protocols.h	/^	LI_LISTEN,      \/* started, listening but not enabled *\/$/;"	e	enum:__anon6
LI_NEW	include/types/protocols.h	/^	LI_NEW	= 0,    \/* not initialized yet *\/$/;"	e	enum:__anon6
LI_O_ACC_PROXY	include/types/protocols.h	86;"	d
LI_O_CHK_MONNET	include/types/protocols.h	85;"	d
LI_O_DEF_ACCEPT	include/types/protocols.h	83;"	d
LI_O_FOREIGN	include/types/protocols.h	81;"	d
LI_O_NOLINGER	include/types/protocols.h	80;"	d
LI_O_NONE	include/types/protocols.h	79;"	d
LI_O_NOQUICKACK	include/types/protocols.h	82;"	d
LI_O_TCP_RULES	include/types/protocols.h	84;"	d
LI_O_UNLIMITED	include/types/protocols.h	87;"	d
LI_PAUSED	include/types/protocols.h	/^	LI_PAUSED,      \/* listener was paused, it's bound but not listening  *\/$/;"	e	enum:__anon6
LI_READY	include/types/protocols.h	/^	LI_READY,       \/* started, listening and enabled *\/$/;"	e	enum:__anon6
PROTO_NAME_LEN	include/types/protocols.h	38;"	d
_TYPES_PROTOCOLS_H	include/types/protocols.h	23;"	d
accept	include/types/protocols.h	/^	int (*accept)(int fd);				\/* generic accept function *\/$/;"	m	struct:protocol
accept	include/types/protocols.h	/^	int (*accept)(struct listener *l, int fd, struct sockaddr_storage *addr); \/* upper layer's accept() *\/$/;"	m	struct:listener
addr	include/types/protocols.h	/^	struct sockaddr_storage addr;	\/* the address we listen to *\/$/;"	m	struct:listener	typeref:struct:listener::sockaddr_storage
analysers	include/types/protocols.h	/^	unsigned int analysers;		\/* bitmap of required protocol analysers *\/$/;"	m	struct:listener
backlog	include/types/protocols.h	/^	unsigned int backlog;		\/* if set, listen backlog *\/$/;"	m	struct:listener
bind	include/types/protocols.h	/^	int (*bind)(struct listener *l, char *errmsg, int errlen); \/* bind a listener *\/$/;"	m	struct:protocol
bind_all	include/types/protocols.h	/^	int (*bind_all)(struct protocol *proto, char *errmsg, int errlen); \/* bind all unbound listeners *\/$/;"	m	struct:protocol
conf	include/types/protocols.h	/^	} conf;				\/* config information *\/$/;"	m	struct:listener	typeref:struct:listener::__anon9
connect	include/types/protocols.h	/^	int (*connect)(struct stream_interface *);      \/* connect function if any *\/$/;"	m	struct:protocol
counters	include/types/protocols.h	/^	struct licounters *counters;	\/* statistics counters *\/$/;"	m	struct:listener	typeref:struct:listener::licounters
disable_all	include/types/protocols.h	/^	int (*disable_all)(struct protocol *proto);	\/* disable all bound listeners *\/$/;"	m	struct:protocol
enable_all	include/types/protocols.h	/^	int (*enable_all)(struct protocol *proto);	\/* enable all bound listeners *\/$/;"	m	struct:protocol
fd	include/types/protocols.h	/^	int fd;				\/* the listen socket *\/$/;"	m	struct:listener
file	include/types/protocols.h	/^		const char *file;	\/* file where the section appears *\/$/;"	m	struct:listener::__anon9
frontend	include/types/protocols.h	/^	struct proxy *frontend;		\/* the frontend this listener belongs to, or NULL *\/$/;"	m	struct:listener	typeref:struct:listener::proxy
get_dst	include/types/protocols.h	/^	int (*get_dst)(int fd, struct sockaddr *, socklen_t, int dir); \/* syscall used to retrieve dst addr *\/$/;"	m	struct:protocol
get_src	include/types/protocols.h	/^	int (*get_src)(int fd, struct sockaddr *, socklen_t, int dir); \/* syscall used to retrieve src addr *\/$/;"	m	struct:protocol
gid	include/types/protocols.h	/^			gid_t gid;	\/* -1 to leave unchanged *\/$/;"	m	struct:listener::__anon7::__anon8
handler	include/types/protocols.h	/^	struct task * (*handler)(struct task *t); \/* protocol handler. It is a task *\/$/;"	m	struct:listener	typeref:struct:listener::handler
id	include/types/protocols.h	/^		struct eb32_node id;	\/* place in the tree of used IDs *\/$/;"	m	struct:listener::__anon9	typeref:struct:listener::__anon9::eb32_node
interface	include/types/protocols.h	/^	char *interface;		\/* interface name or NULL *\/$/;"	m	struct:listener
l3_addrlen	include/types/protocols.h	/^	int l3_addrlen;					\/* layer3 address length, used by hashes *\/$/;"	m	struct:protocol
level	include/types/protocols.h	/^			int level;	\/* access level (ACCESS_LVL_*) *\/$/;"	m	struct:listener::__anon7::__anon8
line	include/types/protocols.h	/^		int line;		\/* line where the section appears *\/$/;"	m	struct:listener::__anon9
list	include/types/protocols.h	/^	struct list list;				\/* list of registered protocols *\/$/;"	m	struct:protocol	typeref:struct:protocol::list
listener	include/types/protocols.h	/^struct listener {$/;"	s
listeners	include/types/protocols.h	/^	struct list listeners;				\/* list of listeners using this protocol *\/$/;"	m	struct:protocol	typeref:struct:protocol::list
luid	include/types/protocols.h	/^	int luid;			\/* listener universally unique ID, used for SNMP *\/$/;"	m	struct:listener
maxconn	include/types/protocols.h	/^	int maxconn;			\/* maximum connections allowed on this listener *\/$/;"	m	struct:listener
maxseg	include/types/protocols.h	/^	int maxseg;			\/* for TCP, advertised MSS *\/$/;"	m	struct:listener
mode	include/types/protocols.h	/^			mode_t mode;	\/* 0 to leave unchanged *\/$/;"	m	struct:listener::__anon7::__anon8
name	include/types/protocols.h	/^	char *name;			\/* *\/$/;"	m	struct:listener
name	include/types/protocols.h	/^	char name[PROTO_NAME_LEN];			\/* protocol name, zero-terminated *\/$/;"	m	struct:protocol
nb_listeners	include/types/protocols.h	/^	int nb_listeners;				\/* number of listeners *\/$/;"	m	struct:protocol
nbconn	include/types/protocols.h	/^	int nbconn;			\/* current number of connections on this listener *\/$/;"	m	struct:listener
next	include/types/protocols.h	/^	struct listener *next;		\/* next address for the same proxy, or NULL *\/$/;"	m	struct:listener	typeref:struct:listener::listener
nice	include/types/protocols.h	/^	int nice;			\/* nice value to assign to the instanciated tasks *\/$/;"	m	struct:listener
options	include/types/protocols.h	/^	int options;			\/* socket options : LI_O_* *\/$/;"	m	struct:listener
perm	include/types/protocols.h	/^	} perm;$/;"	m	struct:listener	typeref:union:listener::__anon7
proto	include/types/protocols.h	/^	struct protocol *proto;		\/* protocol this listener belongs to *\/$/;"	m	struct:listener	typeref:struct:listener::protocol
proto_list	include/types/protocols.h	/^	struct list proto_list;         \/* list in the protocol header *\/$/;"	m	struct:listener	typeref:struct:listener::list
protocol	include/types/protocols.h	/^struct protocol {$/;"	s
sock	include/types/protocols.h	/^	struct sock_ops *sock;          \/* listener socket operations *\/$/;"	m	struct:listener	typeref:struct:listener::sock_ops
sock_addrlen	include/types/protocols.h	/^	socklen_t sock_addrlen;				\/* socket address length, used by bind() *\/$/;"	m	struct:protocol
sock_domain	include/types/protocols.h	/^	int sock_domain;				\/* socket domain, as passed to socket()   *\/$/;"	m	struct:protocol
sock_family	include/types/protocols.h	/^	sa_family_t sock_family;			\/* socket family, for sockaddr *\/$/;"	m	struct:protocol
sock_prot	include/types/protocols.h	/^	int sock_prot;					\/* socket protocol, as passed to socket() *\/$/;"	m	struct:protocol
sock_type	include/types/protocols.h	/^	int sock_type;					\/* socket type, as passed to socket()     *\/$/;"	m	struct:protocol
state	include/types/protocols.h	/^	int state;			\/* state: NEW, INIT, ASSIGNED, LISTEN, READY, FULL *\/$/;"	m	struct:listener
timeout	include/types/protocols.h	/^	int  *timeout;                  \/* pointer to client-side timeout *\/$/;"	m	struct:listener
uid	include/types/protocols.h	/^			uid_t uid;	\/* -1 to leave unchanged *\/$/;"	m	struct:listener::__anon7::__anon8
unbind_all	include/types/protocols.h	/^	int (*unbind_all)(struct protocol *proto);	\/* unbind all bound listeners *\/$/;"	m	struct:protocol
ux	include/types/protocols.h	/^		} ux;$/;"	m	union:listener::__anon7	typeref:struct:listener::__anon7::__anon8
wait_queue	include/types/protocols.h	/^	struct list wait_queue;		\/* link element to make the listener wait for something (LI_LIMITED)  *\/$/;"	m	struct:listener	typeref:struct:listener::list
PR_CAP_BE	include/types/proxy.h	69;"	d
PR_CAP_FE	include/types/proxy.h	68;"	d
PR_CAP_LISTEN	include/types/proxy.h	71;"	d
PR_CAP_NONE	include/types/proxy.h	67;"	d
PR_CAP_RS	include/types/proxy.h	70;"	d
PR_CK_ANY	include/types/proxy.h	168;"	d
PR_CK_HTTPONLY	include/types/proxy.h	172;"	d
PR_CK_IND	include/types/proxy.h	165;"	d
PR_CK_INS	include/types/proxy.h	166;"	d
PR_CK_NOC	include/types/proxy.h	169;"	d
PR_CK_PFX	include/types/proxy.h	167;"	d
PR_CK_POST	include/types/proxy.h	170;"	d
PR_CK_PSV	include/types/proxy.h	171;"	d
PR_CK_RW	include/types/proxy.h	164;"	d
PR_CK_SECURE	include/types/proxy.h	173;"	d
PR_MODE_HEALTH	include/types/proxy.h	64;"	d
PR_MODE_HTTP	include/types/proxy.h	63;"	d
PR_MODE_TCP	include/types/proxy.h	62;"	d
PR_O2_AS_M_ANY	include/types/proxy.h	132;"	d
PR_O2_AS_M_PP	include/types/proxy.h	130;"	d
PR_O2_AS_M_QS	include/types/proxy.h	131;"	d
PR_O2_AS_PFX	include/types/proxy.h	127;"	d
PR_O2_AS_REQL	include/types/proxy.h	126;"	d
PR_O2_CHK_ANY	include/types/proxy.h	160;"	d
PR_O2_CHK_NONE	include/types/proxy.h	151;"	d
PR_O2_CHK_SNDST	include/types/proxy.h	135;"	d
PR_O2_CLFLOG	include/types/proxy.h	120;"	d
PR_O2_EXP_INV	include/types/proxy.h	147;"	d
PR_O2_EXP_NONE	include/types/proxy.h	141;"	d
PR_O2_EXP_RSTR	include/types/proxy.h	145;"	d
PR_O2_EXP_RSTS	include/types/proxy.h	143;"	d
PR_O2_EXP_STR	include/types/proxy.h	144;"	d
PR_O2_EXP_STS	include/types/proxy.h	142;"	d
PR_O2_EXP_TYPE	include/types/proxy.h	146;"	d
PR_O2_FAKE_KA	include/types/proxy.h	139;"	d
PR_O2_HTTP_CHK	include/types/proxy.h	155;"	d
PR_O2_INDEPSTR	include/types/proxy.h	122;"	d
PR_O2_LDAP_CHK	include/types/proxy.h	157;"	d
PR_O2_LOGERRORS	include/types/proxy.h	116;"	d
PR_O2_LOGHCHKS	include/types/proxy.h	121;"	d
PR_O2_MYSQL_CHK	include/types/proxy.h	156;"	d
PR_O2_NODELAY	include/types/proxy.h	133;"	d
PR_O2_NOLOGNORM	include/types/proxy.h	115;"	d
PR_O2_PGSQL_CHK	include/types/proxy.h	152;"	d
PR_O2_RDPC_PRST	include/types/proxy.h	119;"	d
PR_O2_REDIS_CHK	include/types/proxy.h	153;"	d
PR_O2_REQBUG_OK	include/types/proxy.h	113;"	d
PR_O2_RSPBUG_OK	include/types/proxy.h	114;"	d
PR_O2_SMARTACC	include/types/proxy.h	117;"	d
PR_O2_SMARTCON	include/types/proxy.h	118;"	d
PR_O2_SMTP_CHK	include/types/proxy.h	154;"	d
PR_O2_SOCKSTAT	include/types/proxy.h	123;"	d
PR_O2_SPLIC_ANY	include/types/proxy.h	112;"	d
PR_O2_SPLIC_AUT	include/types/proxy.h	111;"	d
PR_O2_SPLIC_REQ	include/types/proxy.h	109;"	d
PR_O2_SPLIC_RTR	include/types/proxy.h	110;"	d
PR_O2_SRC_ADDR	include/types/proxy.h	137;"	d
PR_O2_SSL3_CHK	include/types/proxy.h	158;"	d
PR_O2_USE_PXHDR	include/types/proxy.h	134;"	d
PR_O_ABRT_CLOSE	include/types/proxy.h	93;"	d
PR_O_BIND_SRC	include/types/proxy.h	80;"	d
PR_O_CHK_CACHE	include/types/proxy.h	87;"	d
PR_O_CONTSTATS	include/types/proxy.h	103;"	d
PR_O_DISABLE404	include/types/proxy.h	105;"	d
PR_O_DISPATCH	include/types/proxy.h	77;"	d
PR_O_FF_ALWAYS	include/types/proxy.h	83;"	d
PR_O_FORCE_CLO	include/types/proxy.h	91;"	d
PR_O_FWDFOR	include/types/proxy.h	79;"	d
PR_O_HTTP_CLOSE	include/types/proxy.h	86;"	d
PR_O_HTTP_PROXY	include/types/proxy.h	104;"	d
PR_O_KEEPALIVE	include/types/proxy.h	78;"	d
PR_O_LOGASAP	include/types/proxy.h	85;"	d
PR_O_NULLNOLOG	include/types/proxy.h	81;"	d
PR_O_ORGTO	include/types/proxy.h	106;"	d
PR_O_PERSIST	include/types/proxy.h	84;"	d
PR_O_REDISP	include/types/proxy.h	74;"	d
PR_O_SERVER_CLO	include/types/proxy.h	102;"	d
PR_O_TCP_CLI_KA	include/types/proxy.h	88;"	d
PR_O_TCP_NOLING	include/types/proxy.h	92;"	d
PR_O_TCP_SRV_KA	include/types/proxy.h	89;"	d
PR_O_TPXY_ADDR	include/types/proxy.h	96;"	d
PR_O_TPXY_CIP	include/types/proxy.h	97;"	d
PR_O_TPXY_CLI	include/types/proxy.h	98;"	d
PR_O_TPXY_DYN	include/types/proxy.h	99;"	d
PR_O_TPXY_MASK	include/types/proxy.h	100;"	d
PR_O_TRANSP	include/types/proxy.h	75;"	d
PR_O_USE_ALL_BK	include/types/proxy.h	90;"	d
PR_STERROR	include/types/proxy.h	/^	PR_STERROR,             \/* proxy experienced an unrecoverable error *\/$/;"	e	enum:__anon10
PR_STFULL	include/types/proxy.h	/^	PR_STFULL,              \/* frontend is full (maxconn reached) *\/$/;"	e	enum:__anon10
PR_STNEW	include/types/proxy.h	/^	PR_STNEW = 0,           \/* proxy has not been initialized yet *\/$/;"	e	enum:__anon10
PR_STPAUSED	include/types/proxy.h	/^	PR_STPAUSED,            \/* frontend is paused (during hot restart) *\/$/;"	e	enum:__anon10
PR_STREADY	include/types/proxy.h	/^	PR_STREADY,             \/* proxy has been initialized and is ready *\/$/;"	e	enum:__anon10
PR_STSTOPPED	include/types/proxy.h	/^	PR_STSTOPPED,           \/* proxy is stopped (end of a restart) *\/$/;"	e	enum:__anon10
STK_IS_MATCH	include/types/proxy.h	176;"	d
STK_IS_STORE	include/types/proxy.h	177;"	d
STK_ON_RSP	include/types/proxy.h	178;"	d
_TYPES_PROXY_H	include/types/proxy.h	23;"	d
accept	include/types/proxy.h	/^	int (*accept)(struct session *s);       \/* application layer's accept() *\/$/;"	m	struct:proxy
acl	include/types/proxy.h	/^	struct list acl;                        \/* ACL declared on this proxy *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
acl_requires	include/types/proxy.h	/^	int acl_requires;                       \/* Elements required to satisfy all ACLs (ACL_USE_*) *\/$/;"	m	struct:proxy
appsession	include/types/proxy.h	/^		int appsession;                 \/* appsession cookie expiration *\/$/;"	m	struct:proxy::__anon14
appsession_len	include/types/proxy.h	/^	int  appsession_len;			\/* length of the appsession cookie value to be used *\/$/;"	m	struct:proxy
appsession_name	include/types/proxy.h	/^	char *appsession_name;			\/* name of the cookie to look for *\/$/;"	m	struct:proxy
appsession_name_len	include/types/proxy.h	/^	int  appsession_name_len;		\/* strlen(appsession_name), computed only once *\/$/;"	m	struct:proxy
b_flags	include/types/proxy.h	/^	unsigned int b_flags;		\/* buffer flags *\/$/;"	m	struct:error_snapshot
b_out	include/types/proxy.h	/^	unsigned int b_out;		\/* pending output bytes *\/$/;"	m	struct:error_snapshot
b_tot	include/types/proxy.h	/^	unsigned long long b_tot;	\/* total bytes transferred via this buffer *\/$/;"	m	struct:error_snapshot
b_wrap	include/types/proxy.h	/^	unsigned int b_wrap;		\/* position where the buffer is expected to wrap *\/$/;"	m	struct:error_snapshot
backend	include/types/proxy.h	/^		struct proxy *backend;		\/* target backend *\/$/;"	m	union:switching_rule::__anon16	typeref:struct:switching_rule::__anon16::proxy
backlog	include/types/proxy.h	/^	unsigned int backlog;			\/* force the frontend's listen backlog *\/$/;"	m	struct:proxy
be	include/types/proxy.h	/^		struct proxy *be;		\/* default backend, or NULL if none set *\/$/;"	m	union:proxy::__anon11	typeref:struct:proxy::__anon11::proxy
be	include/types/proxy.h	/^	} be;$/;"	m	struct:switching_rule	typeref:union:switching_rule::__anon16
be_counters	include/types/proxy.h	/^	struct pxcounters be_counters;		\/* backend statistics counters *\/$/;"	m	struct:proxy	typeref:struct:proxy::pxcounters
be_req_ana	include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
be_rsp_ana	include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
be_sess_per_sec	include/types/proxy.h	/^	struct freq_ctr be_sess_per_sec;	\/* sessions per second on the backend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
beconn	include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends sessions *\/$/;"	m	struct:proxy
bind_hdr_len	include/types/proxy.h	/^	int bind_hdr_len;			\/* length of the name of the header above *\/$/;"	m	struct:proxy
bind_hdr_name	include/types/proxy.h	/^	char *bind_hdr_name;			\/* bind to this header name if defined *\/$/;"	m	struct:proxy
bind_hdr_occ	include/types/proxy.h	/^	int bind_hdr_occ;			\/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled *\/$/;"	m	struct:proxy
bind_proc	include/types/proxy.h	/^	unsigned int bind_proc;			\/* bitmask of processes using this proxy. 0 = all. *\/$/;"	m	struct:proxy
block_cond	include/types/proxy.h	/^	struct list block_cond;                 \/* early blocking conditions (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
buf	include/types/proxy.h	/^	char buf[BUFSIZE];		\/* copy of the beginning of the message *\/$/;"	m	struct:error_snapshot
cap	include/types/proxy.h	/^	int cap;				\/* supported capabilities (PR_CAP_*) *\/$/;"	m	struct:proxy
capture_len	include/types/proxy.h	/^	int  capture_len;			\/* length of the string to be captured *\/$/;"	m	struct:proxy
capture_name	include/types/proxy.h	/^	char *capture_name;			\/* beginning of the name of the cookie to capture *\/$/;"	m	struct:proxy
capture_namelen	include/types/proxy.h	/^	int  capture_namelen;			\/* length of the cookie name to match *\/$/;"	m	struct:proxy
check	include/types/proxy.h	/^		int check;                      \/* maximum time for complete check *\/$/;"	m	struct:proxy::__anon14
check_len	include/types/proxy.h	/^	int check_len;				\/* Length of the HTTP or SSL3 request *\/$/;"	m	struct:proxy
check_req	include/types/proxy.h	/^	char *check_req;			\/* HTTP or SSL request to use for PR_O_HTTP_CHK|PR_O_SSL3_CHK *\/$/;"	m	struct:proxy
ck_opts	include/types/proxy.h	/^	unsigned int ck_opts;			\/* PR_CK_* (cookie options) *\/$/;"	m	struct:proxy
client	include/types/proxy.h	/^		int client;                     \/* client I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon14
code	include/types/proxy.h	/^	int code;$/;"	m	struct:redirect_rule
cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::acl_cond
cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:server_rule	typeref:struct:server_rule::acl_cond
cond	include/types/proxy.h	/^	struct acl_cond *cond;			\/* acl condition to meet *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::acl_cond
cond	include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::acl_cond
cond	include/types/proxy.h	/^	struct acl_cond *cond;                  \/* acl condition to meet *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::acl_cond
conf	include/types/proxy.h	/^	} conf;					\/* config information *\/$/;"	m	struct:proxy	typeref:struct:proxy::__anon15
conn_retries	include/types/proxy.h	/^	int conn_retries;			\/* maximum number of connect retries *\/$/;"	m	struct:proxy
connect	include/types/proxy.h	/^		int connect;                    \/* connect timeout (in ticks) *\/$/;"	m	struct:proxy::__anon14
cookie_domain	include/types/proxy.h	/^	char *cookie_domain;			\/* domain used to insert the cookie *\/$/;"	m	struct:proxy
cookie_len	include/types/proxy.h	/^	int  cookie_len;			\/* strlen(cookie_name), computed only once *\/$/;"	m	struct:proxy
cookie_len	include/types/proxy.h	/^	int cookie_len;$/;"	m	struct:redirect_rule
cookie_maxidle	include/types/proxy.h	/^	unsigned int cookie_maxidle;		\/* max idle time for this cookie *\/$/;"	m	struct:proxy
cookie_maxlife	include/types/proxy.h	/^	unsigned int cookie_maxlife;		\/* max life time for this cookie *\/$/;"	m	struct:proxy
cookie_name	include/types/proxy.h	/^	char *cookie_name;			\/* name of the cookie to look for *\/$/;"	m	struct:proxy
cookie_str	include/types/proxy.h	/^	char *cookie_str;$/;"	m	struct:redirect_rule
defbe	include/types/proxy.h	/^	} defbe;$/;"	m	struct:proxy	typeref:union:proxy::__anon11
defsrv	include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::
desc	include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy
dispatch_addr	include/types/proxy.h	/^	struct sockaddr_storage dispatch_addr;	\/* the default address to connect to *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_storage
down_time	include/types/proxy.h	/^	unsigned down_time;			\/* total time the proxy was down *\/$/;"	m	struct:proxy
down_trans	include/types/proxy.h	/^	unsigned down_trans;			\/* up-down transitions *\/$/;"	m	struct:proxy
errmsg	include/types/proxy.h	/^	struct chunk errmsg[HTTP_ERR_SIZE];	\/* default or customized error messages for known errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::chunk
error_snapshot	include/types/proxy.h	/^struct error_snapshot {$/;"	s
ev_id	include/types/proxy.h	/^	unsigned int ev_id;		\/* event number (counter incremented for each capture) *\/$/;"	m	struct:error_snapshot
except_mask	include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::
except_mask_to	include/types/proxy.h	/^	struct in_addr except_mask_to;		\/* the netmask for except_to. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
except_net	include/types/proxy.h	/^	struct in_addr except_net, except_mask; \/* don't x-forward-for for this address. FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
except_to	include/types/proxy.h	/^	struct in_addr except_to;		\/* don't x-original-to for this address. *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
expect_regex	include/types/proxy.h	/^	regex_t *expect_regex;			\/* http-check expected content *\/$/;"	m	struct:proxy
expect_str	include/types/proxy.h	/^	char *expect_str;			\/* http-check expected content : string or text version of the regex *\/$/;"	m	struct:proxy
expr	include/types/proxy.h	/^	struct sample_expr *expr;               \/* fetch expr to fetch key *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::sample_expr
fe_conn_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_conn_per_sec;	\/* received connections per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
fe_counters	include/types/proxy.h	/^	struct pxcounters fe_counters;		\/* frontend statistics counters *\/$/;"	m	struct:proxy	typeref:struct:proxy::pxcounters
fe_req_ana	include/types/proxy.h	/^	unsigned int fe_req_ana, be_req_ana;	\/* bitmap of common request protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
fe_req_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_req_per_sec;		\/* HTTP requests per second on the frontend *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
fe_rsp_ana	include/types/proxy.h	/^	unsigned int fe_rsp_ana, be_rsp_ana;	\/* bitmap of common response protocol analysers for the frontend and backend *\/$/;"	m	struct:proxy
fe_sess_per_sec	include/types/proxy.h	/^	struct freq_ctr fe_sess_per_sec;	\/* accepted sessions per second on the frontend (after tcp rules) *\/$/;"	m	struct:proxy	typeref:struct:proxy::freq_ctr
fe_sps_lim	include/types/proxy.h	/^	unsigned int fe_sps_lim;		\/* limit on new sessions per second on the frontend *\/$/;"	m	struct:proxy
feconn	include/types/proxy.h	/^	unsigned int feconn, beconn;		\/* # of active frontend and backends sessions *\/$/;"	m	struct:proxy
file	include/types/proxy.h	/^		const char *file;		\/* file where the section appears *\/$/;"	m	struct:proxy::__anon15
flags	include/types/proxy.h	/^	int flags;                              \/* STK_* *\/$/;"	m	struct:sticking_rule
flags	include/types/proxy.h	/^	unsigned int flags;$/;"	m	struct:redirect_rule
format_unique_id	include/types/proxy.h	/^	struct list format_unique_id;		\/* unique-id format *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
fullconn	include/types/proxy.h	/^	unsigned int fullconn;			\/* #conns on backend above which servers are used at full load *\/$/;"	m	struct:proxy
fwdfor_hdr_len	include/types/proxy.h	/^	int fwdfor_hdr_len;			\/* length of "x-forwarded-for" header *\/$/;"	m	struct:proxy
fwdfor_hdr_name	include/types/proxy.h	/^	char *fwdfor_hdr_name;			\/* header to use - default: "x-forwarded-for" *\/$/;"	m	struct:proxy
grace	include/types/proxy.h	/^	int grace;				\/* grace time after stop request *\/$/;"	m	struct:proxy
header_unique_id	include/types/proxy.h	/^	char *header_unique_id; 		\/* unique-id header *\/$/;"	m	struct:proxy
hh_len	include/types/proxy.h	/^	int  hh_len;				\/* strlen(hh_name), computed only once *\/$/;"	m	struct:proxy
hh_match_domain	include/types/proxy.h	/^	int  hh_match_domain;			\/* toggle use of special match function *\/$/;"	m	struct:proxy
hh_name	include/types/proxy.h	/^	char *hh_name;				\/* name of the header parameter used for hashing *\/$/;"	m	struct:proxy
htbl_proxy	include/types/proxy.h	/^	struct appsession_hash htbl_proxy;	\/* Per Proxy hashtable *\/$/;"	m	struct:proxy	typeref:struct:proxy::appsession_hash
http_req_rules	include/types/proxy.h	/^	struct list http_req_rules;		\/* HTTP request rules: allow\/deny\/http-auth *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
httpka	include/types/proxy.h	/^		int httpka;                     \/* maximum time for a new HTTP request when using keep-alive *\/$/;"	m	struct:proxy::__anon14
httpreq	include/types/proxy.h	/^		int httpreq;                    \/* maximum time for complete HTTP request *\/$/;"	m	struct:proxy::__anon14
id	include/types/proxy.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:proxy::__anon15	typeref:struct:proxy::__anon15::eb32_node
id	include/types/proxy.h	/^	char *id, *desc;			\/* proxy id (name) and description *\/$/;"	m	struct:proxy
iface_len	include/types/proxy.h	/^	int iface_len;				\/* bind interface name length *\/$/;"	m	struct:proxy
iface_name	include/types/proxy.h	/^	char *iface_name;			\/* bind interface name or NULL *\/$/;"	m	struct:proxy
inspect_delay	include/types/proxy.h	/^		unsigned int inspect_delay;     \/* inspection delay *\/$/;"	m	struct:proxy::__anon12
inspect_delay	include/types/proxy.h	/^		unsigned int inspect_delay;     \/* inspection delay *\/$/;"	m	struct:proxy::__anon13
inspect_rules	include/types/proxy.h	/^		struct list inspect_rules;      \/* inspection rules *\/$/;"	m	struct:proxy::__anon12	typeref:struct:proxy::__anon12::list
inspect_rules	include/types/proxy.h	/^		struct list inspect_rules;      \/* inspection rules *\/$/;"	m	struct:proxy::__anon13	typeref:struct:proxy::__anon13::list
invalid_rep	include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::
invalid_req	include/types/proxy.h	/^	struct error_snapshot invalid_req, invalid_rep; \/* captures of last errors *\/$/;"	m	struct:proxy	typeref:struct:proxy::error_snapshot
l4_rules	include/types/proxy.h	/^		struct list l4_rules;           \/* layer4 rules *\/$/;"	m	struct:proxy::__anon12	typeref:struct:proxy::__anon12::list
last_change	include/types/proxy.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:proxy
lbprm	include/types/proxy.h	/^	struct lbprm lbprm;			\/* load-balancing parameters *\/$/;"	m	struct:proxy	typeref:struct:proxy::lbprm
len	include/types/proxy.h	/^	unsigned int len;		\/* original length of the last invalid request\/response *\/$/;"	m	struct:error_snapshot
line	include/types/proxy.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:proxy::__anon15
list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:persist_rule	typeref:struct:persist_rule::list
list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:server_rule	typeref:struct:server_rule::list
list	include/types/proxy.h	/^	struct list list;			\/* list linked to from the proxy *\/$/;"	m	struct:switching_rule	typeref:struct:switching_rule::list
list	include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:redirect_rule	typeref:struct:redirect_rule::list
list	include/types/proxy.h	/^	struct list list;                       \/* list linked to from the proxy *\/$/;"	m	struct:sticking_rule	typeref:struct:sticking_rule::list
listen	include/types/proxy.h	/^	struct listener *listen;		\/* the listen addresses and sockets *\/$/;"	m	struct:proxy	typeref:struct:proxy::listener
listener_queue	include/types/proxy.h	/^	struct list listener_queue;		\/* list of the temporarily limited listeners because of lack of a proxy resource *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
logformat	include/types/proxy.h	/^	struct list logformat; 			\/* log_format linked list *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
logformat_string	include/types/proxy.h	/^	char *logformat_string;			\/* log format string *\/$/;"	m	struct:proxy
logsrvs	include/types/proxy.h	/^	struct list logsrvs;$/;"	m	struct:proxy	typeref:struct:proxy::list
m_blen	include/types/proxy.h	/^	unsigned long long m_blen;	\/* body len for this message *\/$/;"	m	struct:error_snapshot
m_clen	include/types/proxy.h	/^	unsigned long long m_clen;	\/* chunk len for this message *\/$/;"	m	struct:error_snapshot
m_flags	include/types/proxy.h	/^	unsigned int m_flags;		\/* message flags *\/$/;"	m	struct:error_snapshot
maxconn	include/types/proxy.h	/^	unsigned int maxconn;			\/* max # of active sessions on the frontend *\/$/;"	m	struct:proxy
mode	include/types/proxy.h	/^	int mode;				\/* mode = PR_MODE_TCP, PR_MODE_HTTP or PR_MODE_HEALTH *\/$/;"	m	struct:proxy
mon_fail_cond	include/types/proxy.h	/^	struct list mon_fail_cond;              \/* list of conditions to fail monitoring requests (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
mon_mask	include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::
mon_net	include/types/proxy.h	/^	struct in_addr mon_net, mon_mask;	\/* don't forward connections from this net (network order) FIXME: should support IPv6 *\/$/;"	m	struct:proxy	typeref:struct:proxy::in_addr
monitor_uri	include/types/proxy.h	/^	char *monitor_uri;			\/* a special URI to which we respond with HTTP\/200 OK *\/$/;"	m	struct:proxy
monitor_uri_len	include/types/proxy.h	/^	int monitor_uri_len;			\/* length of the string above. 0 if unused *\/$/;"	m	struct:proxy
name	include/types/proxy.h	/^		char *name;			\/* default backend name during config parse *\/$/;"	m	union:proxy::__anon11
name	include/types/proxy.h	/^		char *name;			\/* target backend name during config parsing *\/$/;"	m	union:switching_rule::__anon16
name	include/types/proxy.h	/^		char *name;			\/* target server name during config parsing *\/$/;"	m	union:server_rule::__anon17
name	include/types/proxy.h	/^		char *name;                     \/* target table name during config parsing *\/$/;"	m	union:sticking_rule::__anon18
nb_req_cap	include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy
nb_rsp_cap	include/types/proxy.h	/^	int nb_req_cap, nb_rsp_cap;		\/* # of headers to be captured *\/$/;"	m	struct:proxy
nbpend	include/types/proxy.h	/^	int nbpend;				\/* number of pending connections with no server assigned yet *\/$/;"	m	struct:proxy
next	include/types/proxy.h	/^	struct proxy *next;$/;"	m	struct:proxy	typeref:struct:proxy::proxy
no_options	include/types/proxy.h	/^	int no_options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy
no_options2	include/types/proxy.h	/^	int no_options2;			\/* PR_O2_* *\/$/;"	m	struct:proxy
oe	include/types/proxy.h	/^	struct proxy *oe;		\/* other end = frontend or backend involved *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::proxy
options	include/types/proxy.h	/^	int options;				\/* PR_O_REDISP, PR_O_TRANSP, ... *\/$/;"	m	struct:proxy
options2	include/types/proxy.h	/^	int options2;				\/* PR_O2_* *\/$/;"	m	struct:proxy
orgto_hdr_len	include/types/proxy.h	/^	int orgto_hdr_len;			\/* length of "x-original-to" header *\/$/;"	m	struct:proxy
orgto_hdr_name	include/types/proxy.h	/^	char *orgto_hdr_name;			\/* header to use - default: "x-original-to" *\/$/;"	m	struct:proxy
parent	include/types/proxy.h	/^	void *parent;				\/* parent of the proxy when applicable *\/$/;"	m	struct:proxy
pendconns	include/types/proxy.h	/^	struct list pendconns;			\/* pending connections with no server assigned yet *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
persist_rule	include/types/proxy.h	/^struct persist_rule {$/;"	s
persist_rules	include/types/proxy.h	/^	struct list persist_rules;		\/* 'force-persist' and 'ignore-persist' rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
pos	include/types/proxy.h	/^	unsigned int pos;		\/* position of the first invalid character *\/$/;"	m	struct:error_snapshot
proxy	include/types/proxy.h	/^struct proxy {$/;"	s
ptr	include/types/proxy.h	/^		struct server *ptr;		\/* target server *\/$/;"	m	union:server_rule::__anon17	typeref:struct:server_rule::__anon17::server
queue	include/types/proxy.h	/^		int queue;                      \/* queue timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon14
rdp_cookie_len	include/types/proxy.h	/^	int  rdp_cookie_len;			\/* strlen(rdp_cookie_name), computed only once *\/$/;"	m	struct:proxy
rdp_cookie_name	include/types/proxy.h	/^	char *rdp_cookie_name;			\/* name of the RDP cookie to look for *\/$/;"	m	struct:proxy
rdr_len	include/types/proxy.h	/^	int rdr_len;$/;"	m	struct:redirect_rule
rdr_str	include/types/proxy.h	/^	char *rdr_str;$/;"	m	struct:redirect_rule
redirect_rule	include/types/proxy.h	/^struct redirect_rule {$/;"	s
redirect_rules	include/types/proxy.h	/^	struct list redirect_rules;             \/* content redirecting rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
req_add	include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
req_cap	include/types/proxy.h	/^	struct cap_hdr *req_cap;		\/* chained list of request headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr
req_cap_pool	include/types/proxy.h	/^	struct pool_head *req_cap_pool,		\/* pools of pre-allocated char ** used to build the sessions *\/$/;"	m	struct:proxy	typeref:struct:proxy::pool_head
req_exp	include/types/proxy.h	/^	struct hdr_exp *req_exp;		\/* regular expressions for request headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp
rsp_add	include/types/proxy.h	/^	struct list req_add, rsp_add;           \/* headers to be added *\/$/;"	m	struct:proxy	typeref:struct:proxy::
rsp_cap	include/types/proxy.h	/^	struct cap_hdr *rsp_cap;		\/* chained list of response headers to be captured *\/$/;"	m	struct:proxy	typeref:struct:proxy::cap_hdr
rsp_cap_pool	include/types/proxy.h	/^	                 *rsp_cap_pool;$/;"	m	struct:proxy	typeref:struct:proxy::
rsp_exp	include/types/proxy.h	/^	struct hdr_exp *rsp_exp;		\/* regular expressions for response headers *\/$/;"	m	struct:proxy	typeref:struct:proxy::hdr_exp
s_flags	include/types/proxy.h	/^	unsigned int s_flags;		\/* session flags *\/$/;"	m	struct:error_snapshot
server	include/types/proxy.h	/^		int server;                     \/* server I\/O timeout (in ticks) *\/$/;"	m	struct:proxy::__anon14
server_id_hdr_len	include/types/proxy.h	/^	int server_id_hdr_len;                      \/* the length of the id (name) header... name *\/$/;"	m	struct:proxy
server_id_hdr_name	include/types/proxy.h	/^	char *server_id_hdr_name;                   \/* the header to use to send the server id (name) *\/$/;"	m	struct:proxy
server_rule	include/types/proxy.h	/^struct server_rule {$/;"	s
server_rules	include/types/proxy.h	/^	struct list server_rules;               \/* server switching rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
sid	include/types/proxy.h	/^	unsigned int sid;		\/* ID of the faulty session *\/$/;"	m	struct:error_snapshot
source_addr	include/types/proxy.h	/^	struct sockaddr_storage source_addr;	\/* the address to which we want to bind for connect() *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_storage
src	include/types/proxy.h	/^	struct sockaddr_storage src;	\/* client's address *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::sockaddr_storage
srv	include/types/proxy.h	/^	struct server *srv, defsrv;		\/* known servers; default server configuration *\/$/;"	m	struct:proxy	typeref:struct:proxy::server
srv	include/types/proxy.h	/^	struct server *srv;		\/* server associated with the error (or NULL) *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::server
srv	include/types/proxy.h	/^	} srv;$/;"	m	struct:server_rule	typeref:union:server_rule::__anon17
srv_act	include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy
srv_bck	include/types/proxy.h	/^	int srv_act, srv_bck;			\/* # of servers eligible for LB (UP|!checked) AND (enabled+weight!=0) *\/$/;"	m	struct:proxy
state	include/types/proxy.h	/^	int state;				\/* proxy state *\/$/;"	m	struct:proxy
state	include/types/proxy.h	/^	unsigned int state;		\/* message state before the error (when saved) *\/$/;"	m	struct:error_snapshot
sticking_rule	include/types/proxy.h	/^struct sticking_rule {$/;"	s
sticking_rules	include/types/proxy.h	/^	struct list sticking_rules;             \/* content sticking rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
stop_time	include/types/proxy.h	/^	int stop_time;                          \/* date to stop listening, when stopping != 0 (int ticks) *\/$/;"	m	struct:proxy
storersp_rules	include/types/proxy.h	/^	struct list storersp_rules;             \/* content store response rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
switching_rule	include/types/proxy.h	/^struct switching_rule {$/;"	s
switching_rules	include/types/proxy.h	/^	struct list switching_rules;            \/* content switching rules (chained) *\/$/;"	m	struct:proxy	typeref:struct:proxy::list
t	include/types/proxy.h	/^		struct stktable *t;	        \/* target table *\/$/;"	m	union:sticking_rule::__anon18	typeref:struct:sticking_rule::__anon18::stktable
t_flags	include/types/proxy.h	/^	unsigned int t_flags;		\/* transaction flags *\/$/;"	m	struct:error_snapshot
table	include/types/proxy.h	/^	struct stktable table;			\/* table for storing sticking sessions *\/$/;"	m	struct:proxy	typeref:struct:proxy::stktable
table	include/types/proxy.h	/^	} table;$/;"	m	struct:sticking_rule	typeref:union:sticking_rule::__anon18
tarpit	include/types/proxy.h	/^		int tarpit;                     \/* tarpit timeout, defaults to connect if unspecified *\/$/;"	m	struct:proxy::__anon14
task	include/types/proxy.h	/^	struct task *task;			\/* the associated task, mandatory to manage rate limiting, stopping and resource shortage *\/$/;"	m	struct:proxy	typeref:struct:proxy::task
tcp_rep	include/types/proxy.h	/^	} tcp_rep;$/;"	m	struct:proxy	typeref:struct:proxy::__anon13
tcp_req	include/types/proxy.h	/^	} tcp_req;$/;"	m	struct:proxy	typeref:struct:proxy::__anon12
timeout	include/types/proxy.h	/^	} timeout;$/;"	m	struct:proxy	typeref:struct:proxy::__anon14
to_log	include/types/proxy.h	/^	int to_log;				\/* things to be logged (LW_*) *\/$/;"	m	struct:proxy
totpend	include/types/proxy.h	/^	int totpend;				\/* total number of pending connections on this instance (for stats) *\/$/;"	m	struct:proxy
tproxy_addr	include/types/proxy.h	/^	struct sockaddr_storage tproxy_addr;	\/* non-local address we want to bind to for connect() *\/$/;"	m	struct:proxy	typeref:struct:proxy::sockaddr_storage
tunnel	include/types/proxy.h	/^		int tunnel;                     \/* I\/O timeout to use in tunnel mode (in ticks) *\/$/;"	m	struct:proxy::__anon14
type	include/types/proxy.h	/^	int type;$/;"	m	struct:persist_rule
type	include/types/proxy.h	/^	int type;$/;"	m	struct:redirect_rule
uniqueid_format_string	include/types/proxy.h	/^	char *uniqueid_format_string;		\/* unique-id format string *\/$/;"	m	struct:proxy
uri_auth	include/types/proxy.h	/^	struct uri_auth *uri_auth;		\/* if non-NULL, the (list of) per-URI authentications *\/$/;"	m	struct:proxy	typeref:struct:proxy::uri_auth
uri_dirs_depth1	include/types/proxy.h	/^	int  uri_dirs_depth1;			\/* directories+1 (slashes) limit for uri balancing algorithm *\/$/;"	m	struct:proxy
uri_len_limit	include/types/proxy.h	/^	int  uri_len_limit;			\/* character limit for uri balancing algorithm *\/$/;"	m	struct:proxy
uri_whole	include/types/proxy.h	/^	int  uri_whole;				\/* if != 0, calculates the hash from the whole uri. Still honors the len_limit and dirs_depth1 *\/$/;"	m	struct:proxy
url_param_len	include/types/proxy.h	/^	int  url_param_len;			\/* strlen(url_param_name), computed only once *\/$/;"	m	struct:proxy
url_param_name	include/types/proxy.h	/^	char *url_param_name;			\/* name of the URL parameter used for hashing *\/$/;"	m	struct:proxy
url_param_post_limit	include/types/proxy.h	/^	unsigned url_param_post_limit;		\/* if checking POST body for URI parameter, max body to wait for *\/$/;"	m	struct:proxy
used_listener_id	include/types/proxy.h	/^		struct eb_root used_listener_id;\/* list of listener IDs in use *\/$/;"	m	struct:proxy::__anon15	typeref:struct:proxy::__anon15::eb_root
used_server_id	include/types/proxy.h	/^		struct eb_root used_server_id;	\/* list of server IDs in use *\/$/;"	m	struct:proxy::__anon15	typeref:struct:proxy::__anon15::eb_root
uuid	include/types/proxy.h	/^	int uuid;				\/* universally unique proxy ID, used for SNMP *\/$/;"	m	struct:proxy
when	include/types/proxy.h	/^	struct timeval when;		\/* date of this event, (tv_sec == 0) means "never" *\/$/;"	m	struct:error_snapshot	typeref:struct:error_snapshot::timeval
_TYPES_QUEUE_H	include/types/queue.h	23;"	d
list	include/types/queue.h	/^	struct list list;		\/* chaining ... *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::list
pendconn	include/types/queue.h	/^struct pendconn {$/;"	s
sess	include/types/queue.h	/^	struct session *sess;		\/* the session waiting for a connection *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::session
srv	include/types/queue.h	/^	struct server *srv;		\/* the server we are waiting for *\/$/;"	m	struct:pendconn	typeref:struct:pendconn::server
SMP_CAP_REQ	include/types/sample.h	/^	SMP_CAP_REQ = 1 << 0, \/* fetch supported on request *\/$/;"	e	enum:__anon50
SMP_CAP_RES	include/types/sample.h	/^	SMP_CAP_RES = 1 << 1, \/* fetch supported on response *\/$/;"	e	enum:__anon50
SMP_F_MAY_CHANGE	include/types/sample.h	/^	SMP_F_MAY_CHANGE = 1 << 1, \/* sample is unstable and might change (eg: request length) *\/$/;"	e	enum:__anon52
SMP_F_NOT_LAST	include/types/sample.h	/^	SMP_F_NOT_LAST   = 1 << 0, \/* other occurrences might exist for this sample *\/$/;"	e	enum:__anon52
SMP_F_VOLATILE	include/types/sample.h	/^	SMP_F_VOLATILE   = (1<<2)|(1<<3)|(1<<4)|(1<<5)|(1<<6), \/* any volatility condition *\/$/;"	e	enum:__anon52
SMP_F_VOL_1ST	include/types/sample.h	/^	SMP_F_VOL_1ST    = 1 << 3, \/* result sensitive to changes in first line (eg: URI) *\/$/;"	e	enum:__anon52
SMP_F_VOL_HDR	include/types/sample.h	/^	SMP_F_VOL_HDR    = 1 << 4, \/* result sensitive to changes in headers *\/$/;"	e	enum:__anon52
SMP_F_VOL_SESS	include/types/sample.h	/^	SMP_F_VOL_SESS   = 1 << 6, \/* result sensitive to new session (eg: src IP) *\/$/;"	e	enum:__anon52
SMP_F_VOL_TEST	include/types/sample.h	/^	SMP_F_VOL_TEST   = 1 << 2, \/* result must not survive longer than the test (eg: time) *\/$/;"	e	enum:__anon52
SMP_F_VOL_TXN	include/types/sample.h	/^	SMP_F_VOL_TXN    = 1 << 5, \/* result sensitive to new transaction (eg: HTTP version) *\/$/;"	e	enum:__anon52
SMP_OPT_DIR	include/types/sample.h	/^	SMP_OPT_DIR     = (SMP_OPT_DIR_REQ|SMP_OPT_DIR_RES), \/* mask to get direction *\/$/;"	e	enum:__anon51
SMP_OPT_DIR_REQ	include/types/sample.h	/^	SMP_OPT_DIR_REQ = 0,    \/* direction = request *\/$/;"	e	enum:__anon51
SMP_OPT_DIR_RES	include/types/sample.h	/^	SMP_OPT_DIR_RES = 1,    \/* direction = response *\/$/;"	e	enum:__anon51
SMP_OPT_FINAL	include/types/sample.h	/^	SMP_OPT_FINAL   = 2,    \/* final fetch, contents won't change anymore *\/$/;"	e	enum:__anon51
SMP_OPT_ITERATE	include/types/sample.h	/^	SMP_OPT_ITERATE = 4,    \/* fetches may be iterated if supported (for ACLs) *\/$/;"	e	enum:__anon51
SMP_TYPES	include/types/sample.h	/^	SMP_TYPES        \/* number of types, must always be last *\/$/;"	e	enum:__anon49
SMP_T_BIN	include/types/sample.h	/^	SMP_T_BIN,       \/* buffer type *\/$/;"	e	enum:__anon49
SMP_T_BOOL	include/types/sample.h	/^	SMP_T_BOOL = 0,  \/* boolean *\/$/;"	e	enum:__anon49
SMP_T_CBIN	include/types/sample.h	/^	SMP_T_CBIN,      \/* constant buffer type, data need dup before conversion *\/$/;"	e	enum:__anon49
SMP_T_CSTR	include/types/sample.h	/^	SMP_T_CSTR,      \/* constant char string type, data need dup before conversion *\/$/;"	e	enum:__anon49
SMP_T_IPV4	include/types/sample.h	/^	SMP_T_IPV4,      \/* ipv4 type *\/$/;"	e	enum:__anon49
SMP_T_IPV6	include/types/sample.h	/^	SMP_T_IPV6,      \/* ipv6 type *\/$/;"	e	enum:__anon49
SMP_T_SINT	include/types/sample.h	/^	SMP_T_SINT,      \/* signed 32bits integer type *\/$/;"	e	enum:__anon49
SMP_T_STR	include/types/sample.h	/^	SMP_T_STR,       \/* char string type *\/$/;"	e	enum:__anon49
SMP_T_UINT	include/types/sample.h	/^	SMP_T_UINT,      \/* unsigned 32bits integer type *\/$/;"	e	enum:__anon49
_TYPES_SAMPLE_H	include/types/sample.h	24;"	d
a	include/types/sample.h	/^	void *a[8];     \/* any array of up to 8 pointers *\/$/;"	m	union:smp_ctx
arg_mask	include/types/sample.h	/^	unsigned int arg_mask;                    \/* arguments (ARG*()) *\/$/;"	m	struct:sample_conv
arg_mask	include/types/sample.h	/^	unsigned int arg_mask;                    \/* arguments (ARG*()) *\/$/;"	m	struct:sample_fetch
arg_p	include/types/sample.h	/^	struct arg *arg_p;                        \/* optional arguments *\/$/;"	m	struct:sample_conv_expr	typeref:struct:sample_conv_expr::arg
arg_p	include/types/sample.h	/^	struct arg *arg_p;                        \/* optional pointer to arguments to fetch function *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::arg
cap	include/types/sample.h	/^	unsigned int cap;                         \/* fetch capabilities (SMP_CAP_*) *\/$/;"	m	struct:sample_fetch
conv	include/types/sample.h	/^	struct sample_conv *conv;                 \/* sample conversion used *\/$/;"	m	struct:sample_conv_expr	typeref:struct:sample_conv_expr::sample_conv
conv_exprs	include/types/sample.h	/^	struct list conv_exprs;                   \/* list of conversion expression to apply *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::list
ctx	include/types/sample.h	/^	union smp_ctx ctx;$/;"	m	struct:sample	typeref:union:sample::smp_ctx
d	include/types/sample.h	/^	double d;       \/* any float or double *\/$/;"	m	union:smp_ctx
data	include/types/sample.h	/^	} data;                        \/* sample data *\/$/;"	m	struct:sample	typeref:union:sample::__anon53
fetch	include/types/sample.h	/^	struct sample_fetch *fetch;               \/* sample fetch method *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::sample_fetch
flags	include/types/sample.h	/^	unsigned int flags;       \/* SMP_F_* *\/$/;"	m	struct:sample
i	include/types/sample.h	/^	int i;          \/* any integer *\/$/;"	m	union:smp_ctx
in_type	include/types/sample.h	/^	unsigned int in_type;                     \/* expected input sample type *\/$/;"	m	struct:sample_conv
ipv4	include/types/sample.h	/^		struct in_addr  ipv4;  \/* used for ipv4 addresses *\/$/;"	m	union:sample::__anon53	typeref:struct:sample::__anon53::in_addr
ipv6	include/types/sample.h	/^		struct in6_addr ipv6;  \/* used for ipv6 addresses *\/$/;"	m	union:sample::__anon53	typeref:struct:sample::__anon53::in6_addr
kw	include/types/sample.h	/^	const char *kw;                           \/* configuration keyword  *\/$/;"	m	struct:sample_conv
kw	include/types/sample.h	/^	const char *kw;                           \/* configuration keyword *\/$/;"	m	struct:sample_fetch
kw	include/types/sample.h	/^	struct sample_conv kw[VAR_ARRAY];         \/* array of sample conversion descriptors *\/$/;"	m	struct:sample_conv_kw_list	typeref:struct:sample_conv_kw_list::sample_conv
kw	include/types/sample.h	/^	struct sample_fetch kw[VAR_ARRAY];        \/* array of sample fetch descriptors *\/$/;"	m	struct:sample_fetch_kw_list	typeref:struct:sample_fetch_kw_list::sample_fetch
list	include/types/sample.h	/^	struct list list;                         \/* head of sample conversion keyword list *\/$/;"	m	struct:sample_conv_kw_list	typeref:struct:sample_conv_kw_list::list
list	include/types/sample.h	/^	struct list list;                         \/* head of sample fetch keyword list *\/$/;"	m	struct:sample_fetch_kw_list	typeref:struct:sample_fetch_kw_list::list
list	include/types/sample.h	/^	struct list list;                         \/* member of a sample_expr *\/$/;"	m	struct:sample_conv_expr	typeref:struct:sample_conv_expr::list
list	include/types/sample.h	/^	struct list list;                         \/* member of list of sample, currently not used *\/$/;"	m	struct:sample_expr	typeref:struct:sample_expr::list
ll	include/types/sample.h	/^	long long ll;   \/* any long long or smaller *\/$/;"	m	union:smp_ctx
out_type	include/types/sample.h	/^	unsigned int out_type;                    \/* output sample type *\/$/;"	m	struct:sample_conv
out_type	include/types/sample.h	/^	unsigned long out_type;                   \/* output sample type *\/$/;"	m	struct:sample_fetch
p	include/types/sample.h	/^	void *p;        \/* any pointer *\/$/;"	m	union:smp_ctx
process	include/types/sample.h	/^	int (*process)(const struct arg *arg_p,$/;"	m	struct:sample_conv
process	include/types/sample.h	/^	int (*process)(struct proxy *px,$/;"	m	struct:sample_fetch
sample	include/types/sample.h	/^struct sample {$/;"	s
sample_conv	include/types/sample.h	/^struct sample_conv {$/;"	s
sample_conv_expr	include/types/sample.h	/^struct sample_conv_expr {$/;"	s
sample_conv_kw_list	include/types/sample.h	/^struct sample_conv_kw_list {$/;"	s
sample_expr	include/types/sample.h	/^struct sample_expr {$/;"	s
sample_fetch	include/types/sample.h	/^struct sample_fetch {$/;"	s
sample_fetch_kw_list	include/types/sample.h	/^struct sample_fetch_kw_list {$/;"	s
sint	include/types/sample.h	/^		int             sint;  \/* used for signed 32bits integers *\/$/;"	m	union:sample::__anon53
smp_ctx	include/types/sample.h	/^union smp_ctx {$/;"	u
str	include/types/sample.h	/^		struct chunk    str;   \/* used for char strings or buffers *\/$/;"	m	union:sample::__anon53	typeref:struct:sample::__anon53::chunk
type	include/types/sample.h	/^	int type;                 \/* SMP_T_* *\/$/;"	m	struct:sample
uint	include/types/sample.h	/^		unsigned int    uint;  \/* used for unsigned 32bits integers and booleans *\/$/;"	m	union:sample::__anon53
val_args	include/types/sample.h	/^	int (*val_args)(struct arg *arg_p,$/;"	m	struct:sample_conv
val_args	include/types/sample.h	/^	int (*val_args)(struct arg *arg_p,$/;"	m	struct:sample_fetch
SRV_BACKUP	include/types/server.h	44;"	d
SRV_BIND_SRC	include/types/server.h	46;"	d
SRV_CHECKED	include/types/server.h	47;"	d
SRV_CHK_DISABLE	include/types/server.h	70;"	d
SRV_CHK_ERROR	include/types/server.h	68;"	d
SRV_CHK_RUNNING	include/types/server.h	69;"	d
SRV_CHK_UNKNOWN	include/types/server.h	67;"	d
SRV_EWGHT_MAX	include/types/server.h	76;"	d
SRV_EWGHT_RANGE	include/types/server.h	75;"	d
SRV_GOINGDOWN	include/types/server.h	48;"	d
SRV_MAINTAIN	include/types/server.h	50;"	d
SRV_MAPPORTS	include/types/server.h	45;"	d
SRV_NON_STICK	include/types/server.h	57;"	d
SRV_RUNNING	include/types/server.h	43;"	d
SRV_SEND_PROXY	include/types/server.h	56;"	d
SRV_STATUS_FULL	include/types/server.h	63;"	d
SRV_STATUS_INTERNAL	include/types/server.h	61;"	d
SRV_STATUS_NOSRV	include/types/server.h	62;"	d
SRV_STATUS_OK	include/types/server.h	60;"	d
SRV_STATUS_QUEUED	include/types/server.h	64;"	d
SRV_TPROXY_ADDR	include/types/server.h	51;"	d
SRV_TPROXY_CIP	include/types/server.h	52;"	d
SRV_TPROXY_CLI	include/types/server.h	53;"	d
SRV_TPROXY_DYN	include/types/server.h	54;"	d
SRV_TPROXY_MASK	include/types/server.h	55;"	d
SRV_UWGHT_MAX	include/types/server.h	74;"	d
SRV_UWGHT_RANGE	include/types/server.h	73;"	d
SRV_WARMINGUP	include/types/server.h	49;"	d
_TYPES_SERVER_H	include/types/server.h	23;"	d
actconns	include/types/server.h	/^	struct list actconns;			\/* active connections *\/$/;"	m	struct:server	typeref:struct:server::list
addr	include/types/server.h	/^	struct sockaddr_storage addr;		\/* the address to connect to *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_storage
bind_hdr_len	include/types/server.h	/^	int bind_hdr_len;			\/* length of the name of the header above *\/$/;"	m	struct:server
bind_hdr_name	include/types/server.h	/^	char *bind_hdr_name;			\/* bind to this header name if defined *\/$/;"	m	struct:server
bind_hdr_occ	include/types/server.h	/^	int bind_hdr_occ;			\/* occurrence number of header above: >0 = from first, <0 = from end, 0=disabled *\/$/;"	m	struct:server
check	include/types/server.h	/^	struct task *check;                     \/* the task associated to the health check processing *\/$/;"	m	struct:server	typeref:struct:server::task
check_addr	include/types/server.h	/^	struct sockaddr_storage check_addr;	\/* the address to check, if different from <addr> *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_storage
check_code	include/types/server.h	/^	short check_status, check_code;		\/* check result, check code *\/$/;"	m	struct:server
check_data	include/types/server.h	/^	char *check_data;			\/* storage of partial check results *\/$/;"	m	struct:server
check_data_len	include/types/server.h	/^	int check_data_len;			\/* length of partial check results stored in check_data *\/$/;"	m	struct:server
check_desc	include/types/server.h	/^	char check_desc[HCHK_DESC_LEN];		\/* health check descritpion *\/$/;"	m	struct:server
check_duration	include/types/server.h	/^	long check_duration;			\/* time in ms took to finish last health check *\/$/;"	m	struct:server
check_port	include/types/server.h	/^	short check_port;			\/* the port to use for the health checks *\/$/;"	m	struct:server
check_start	include/types/server.h	/^	struct timeval check_start;		\/* last health check start time *\/$/;"	m	struct:server	typeref:struct:server::timeval
check_status	include/types/server.h	/^	short check_status, check_code;		\/* check result, check code *\/$/;"	m	struct:server
cklen	include/types/server.h	/^	int cklen;				\/* the len of the cookie, to speed up checks *\/$/;"	m	struct:server
conf	include/types/server.h	/^	} conf;					\/* config information *\/$/;"	m	struct:server	typeref:struct:server::__anon96
consecutive_errors	include/types/server.h	/^	int consecutive_errors;			\/* current number of consecutive errors *\/$/;"	m	struct:server
consecutive_errors_limit	include/types/server.h	/^	int consecutive_errors_limit;		\/* number of consecutive errors that triggers an event *\/$/;"	m	struct:server
cookie	include/types/server.h	/^	char *cookie;				\/* the id set in the cookie *\/$/;"	m	struct:server
counters	include/types/server.h	/^	struct srvcounters counters;		\/* statistics counters *\/$/;"	m	struct:server	typeref:struct:server::srvcounters
cur_sess	include/types/server.h	/^	int cur_sess;				\/* number of currently active sessions (including syn_sent) *\/$/;"	m	struct:server
curfd	include/types/server.h	/^	int curfd;				\/* file desc used for current test, or -1 if not in test *\/$/;"	m	struct:server
down_time	include/types/server.h	/^	unsigned down_time;			\/* total time the server was down *\/$/;"	m	struct:server
downinter	include/types/server.h	/^	int inter, fastinter, downinter;	\/* checks: time in milliseconds *\/$/;"	m	struct:server
eweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server
fall	include/types/server.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:server
fastinter	include/types/server.h	/^	int inter, fastinter, downinter;	\/* checks: time in milliseconds *\/$/;"	m	struct:server
file	include/types/server.h	/^		const char *file;		\/* file where the section appears *\/$/;"	m	struct:server::__anon96
health	include/types/server.h	/^	int health;				\/* 0->rise-1 = bad; rise->rise+fall-1 = good *\/$/;"	m	struct:server
id	include/types/server.h	/^		struct eb32_node id;		\/* place in the tree of used IDs *\/$/;"	m	struct:server::__anon96	typeref:struct:server::__anon96::eb32_node
id	include/types/server.h	/^	char *id;				\/* just for identification *\/$/;"	m	struct:server
iface_len	include/types/server.h	/^	int iface_len;				\/* bind interface name length *\/$/;"	m	struct:server
iface_name	include/types/server.h	/^	char *iface_name;			\/* bind interface name or NULL *\/$/;"	m	struct:server
inter	include/types/server.h	/^	int inter, fastinter, downinter;	\/* checks: time in milliseconds *\/$/;"	m	struct:server
iweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server
last_change	include/types/server.h	/^	time_t last_change;			\/* last time, when the state was changed *\/$/;"	m	struct:server
lb_node	include/types/server.h	/^	struct eb32_node lb_node;               \/* node used for tree-based load balancing *\/$/;"	m	struct:server	typeref:struct:server::eb32_node
lb_nodes	include/types/server.h	/^	struct tree_occ *lb_nodes;              \/* lb_nodes_tot * struct tree_occ *\/$/;"	m	struct:server	typeref:struct:server::tree_occ
lb_nodes_now	include/types/server.h	/^	unsigned lb_nodes_now;                  \/* number of lb_nodes placed in the tree (C-HASH) *\/$/;"	m	struct:server
lb_nodes_tot	include/types/server.h	/^	unsigned lb_nodes_tot;                  \/* number of allocated lb_nodes (C-HASH) *\/$/;"	m	struct:server
lb_tree	include/types/server.h	/^	struct eb_root *lb_tree;                \/* we want to know in what tree the server is *\/$/;"	m	struct:server	typeref:struct:server::eb_root
line	include/types/server.h	/^		int line;			\/* line where the section appears *\/$/;"	m	struct:server::__anon96
lpos	include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server
maxconn	include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server
maxqueue	include/types/server.h	/^	int maxqueue;				\/* maximum number of pending connections allowed *\/$/;"	m	struct:server
minconn	include/types/server.h	/^	unsigned maxconn, minconn;		\/* max # of active sessions (0 = unlimited), min# for dynamic limit. *\/$/;"	m	struct:server
nbpend	include/types/server.h	/^	int nbpend;				\/* number of pending connections *\/$/;"	m	struct:server
next	include/types/server.h	/^	struct server *next;$/;"	m	struct:server	typeref:struct:server::server
next_full	include/types/server.h	/^	struct server *next_full;               \/* next server in the temporary full list *\/$/;"	m	struct:server	typeref:struct:server::server
node	include/types/server.h	/^	struct eb32_node node;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::eb32_node
npos	include/types/server.h	/^	unsigned npos, lpos;			\/* next and last positions in the LB tree *\/$/;"	m	struct:server
observe	include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server
onerror	include/types/server.h	/^	short observe, onerror;			\/* observing mode: one of HANA_OBS_*; what to do on error: on of ANA_ONERR_* *\/$/;"	m	struct:server
onmarkeddown	include/types/server.h	/^	short onmarkeddown;			\/* what to do when marked down: one of HANA_ONMARKEDDOWN_* *\/$/;"	m	struct:server
onmarkedup	include/types/server.h	/^	short onmarkedup;			\/* what to do when marked up: one of HANA_ONMARKEDUP_* *\/$/;"	m	struct:server
pendconns	include/types/server.h	/^	struct list pendconns;			\/* pending connections *\/$/;"	m	struct:server	typeref:struct:server::list
prev_eweight	include/types/server.h	/^	unsigned prev_eweight;			\/* eweight before last change *\/$/;"	m	struct:server
prev_state	include/types/server.h	/^	int prev_state;				\/* server state before last change (SRV_*) *\/$/;"	m	struct:server
proto	include/types/server.h	/^	struct protocol *proto;	                \/* server address protocol *\/$/;"	m	struct:server	typeref:struct:server::protocol
proxy	include/types/server.h	/^	struct proxy *proxy;			\/* the proxy this server belongs to *\/$/;"	m	struct:server	typeref:struct:server::proxy
puid	include/types/server.h	/^	int puid;				\/* proxy-unique server ID, used for SNMP, and "first" LB algo *\/$/;"	m	struct:server
rdr_len	include/types/server.h	/^	int rdr_len;				\/* the length of the redirection prefix *\/$/;"	m	struct:server
rdr_pfx	include/types/server.h	/^	char *rdr_pfx;				\/* the redirection prefix *\/$/;"	m	struct:server
result	include/types/server.h	/^	int result;				\/* health-check result : SRV_CHK_* *\/$/;"	m	struct:server
rise	include/types/server.h	/^	int rise, fall;				\/* time in iterations *\/$/;"	m	struct:server
rweight	include/types/server.h	/^	unsigned rweight;			\/* remainer of weight in the current LB tree *\/$/;"	m	struct:server
served	include/types/server.h	/^	int served;				\/* # of active sessions currently being served (ie not pending) *\/$/;"	m	struct:server
server	include/types/server.h	/^	struct server *server;$/;"	m	struct:tree_occ	typeref:struct:tree_occ::server
server	include/types/server.h	/^struct server {$/;"	s
sess_per_sec	include/types/server.h	/^	struct freq_ctr sess_per_sec;		\/* sessions per second on this server *\/$/;"	m	struct:server	typeref:struct:server::freq_ctr
slowstart	include/types/server.h	/^	int slowstart;				\/* slowstart time in seconds (ms in the conf) *\/$/;"	m	struct:server
sock	include/types/server.h	/^	struct sock_ops *sock;                  \/* server socket operations *\/$/;"	m	struct:server	typeref:struct:server::sock_ops
sock_init_arg	include/types/server.h	/^	void *sock_init_arg;                    \/* socket operations's opaque init argument if needed *\/$/;"	m	struct:server
source_addr	include/types/server.h	/^	struct sockaddr_storage source_addr;	\/* the address to which we want to bind for connect() *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_storage
sport_range	include/types/server.h	/^	struct port_range *sport_range;		\/* optional per-server TCP source ports *\/$/;"	m	struct:server	typeref:struct:server::port_range
state	include/types/server.h	/^	int state;				\/* server state (SRV_*) *\/$/;"	m	struct:server
tproxy_addr	include/types/server.h	/^	struct sockaddr_storage tproxy_addr;	\/* non-local address we want to bind to for connect() *\/$/;"	m	struct:server	typeref:struct:server::sockaddr_storage
track	include/types/server.h	/^	struct server *tracknext, *track;	\/* next server in a tracking list, tracked server *\/$/;"	m	struct:server	typeref:struct:server::
trackit	include/types/server.h	/^	char *trackit;				\/* temporary variable to make assignment deferrable *\/$/;"	m	struct:server
tracknext	include/types/server.h	/^	struct server *tracknext, *track;	\/* next server in a tracking list, tracked server *\/$/;"	m	struct:server	typeref:struct:server::server
tree_occ	include/types/server.h	/^struct tree_occ {$/;"	s
uweight	include/types/server.h	/^	unsigned iweight,uweight, eweight;	\/* initial weight, user-specified weight, and effective weight *\/$/;"	m	struct:server
warmup	include/types/server.h	/^	struct task *warmup;                    \/* the task dedicated to the warmup when slowstart is set *\/$/;"	m	struct:server	typeref:struct:server::task
wscore	include/types/server.h	/^	unsigned wscore;			\/* weight score, used during srv map computation *\/$/;"	m	struct:server
SN_ADDR_SET	include/types/session.h	47;"	d
SN_ASSIGNED	include/types/session.h	46;"	d
SN_BE_ASSIGNED	include/types/session.h	48;"	d
SN_BE_TRACK_SC1	include/types/session.h	86;"	d
SN_BE_TRACK_SC2	include/types/session.h	87;"	d
SN_CONN_TAR	include/types/session.h	55;"	d
SN_CURR_SESS	include/types/session.h	52;"	d
SN_DIRECT	include/types/session.h	45;"	d
SN_ERR_CLICL	include/types/session.h	62;"	d
SN_ERR_CLITO	include/types/session.h	61;"	d
SN_ERR_DOWN	include/types/session.h	68;"	d
SN_ERR_INTERNAL	include/types/session.h	67;"	d
SN_ERR_KILLED	include/types/session.h	69;"	d
SN_ERR_MASK	include/types/session.h	71;"	d
SN_ERR_NONE	include/types/session.h	60;"	d
SN_ERR_PRXCOND	include/types/session.h	65;"	d
SN_ERR_RESOURCE	include/types/session.h	66;"	d
SN_ERR_SHIFT	include/types/session.h	72;"	d
SN_ERR_SRVCL	include/types/session.h	64;"	d
SN_ERR_SRVTO	include/types/session.h	63;"	d
SN_ERR_UP	include/types/session.h	70;"	d
SN_FINST_C	include/types/session.h	76;"	d
SN_FINST_D	include/types/session.h	78;"	d
SN_FINST_H	include/types/session.h	77;"	d
SN_FINST_L	include/types/session.h	79;"	d
SN_FINST_MASK	include/types/session.h	82;"	d
SN_FINST_Q	include/types/session.h	80;"	d
SN_FINST_R	include/types/session.h	75;"	d
SN_FINST_SHIFT	include/types/session.h	83;"	d
SN_FINST_T	include/types/session.h	81;"	d
SN_FORCE_PRST	include/types/session.h	50;"	d
SN_IGNORE_PRST	include/types/session.h	85;"	d
SN_MONITOR	include/types/session.h	51;"	d
SN_REDIRECTABLE	include/types/session.h	56;"	d
SN_REDISP	include/types/session.h	54;"	d
SN_TUNNEL	include/types/session.h	57;"	d
TT_ANON	include/types/session.h	/^	TT_ANON     = 1,$/;"	e	enum:__anon41
TT_BIT_SHIFT	include/types/session.h	105;"	d
TT_CLIENT	include/types/session.h	/^	TT_CLIENT   = 0x10,$/;"	e	enum:__anon41
TT_CLIENT_1	include/types/session.h	/^	TT_CLIENT_1,$/;"	e	enum:__anon41
TT_CLIENT_2	include/types/session.h	/^	TT_CLIENT_2,$/;"	e	enum:__anon41
TT_HTTP_CLI	include/types/session.h	/^	TT_HTTP_CLI = 0x20,$/;"	e	enum:__anon41
TT_HTTP_CLI_1	include/types/session.h	/^	TT_HTTP_CLI_1,$/;"	e	enum:__anon41
TT_HTTP_CLI_10	include/types/session.h	/^	TT_HTTP_CLI_10,$/;"	e	enum:__anon41
TT_HTTP_CLI_2	include/types/session.h	/^	TT_HTTP_CLI_2,$/;"	e	enum:__anon41
TT_HTTP_CLI_3	include/types/session.h	/^	TT_HTTP_CLI_3,$/;"	e	enum:__anon41
TT_HTTP_CLI_4	include/types/session.h	/^	TT_HTTP_CLI_4,$/;"	e	enum:__anon41
TT_HTTP_CLI_5	include/types/session.h	/^	TT_HTTP_CLI_5,$/;"	e	enum:__anon41
TT_HTTP_CLI_6	include/types/session.h	/^	TT_HTTP_CLI_6,$/;"	e	enum:__anon41
TT_HTTP_CLI_7	include/types/session.h	/^	TT_HTTP_CLI_7,$/;"	e	enum:__anon41
TT_HTTP_CLI_8	include/types/session.h	/^	TT_HTTP_CLI_8,$/;"	e	enum:__anon41
TT_HTTP_CLI_9	include/types/session.h	/^	TT_HTTP_CLI_9,$/;"	e	enum:__anon41
TT_HTTP_CNT	include/types/session.h	/^	TT_HTTP_CNT = 0x40,$/;"	e	enum:__anon41
TT_HTTP_CNT_1	include/types/session.h	/^	TT_HTTP_CNT_1,$/;"	e	enum:__anon41
TT_HTTP_SRV	include/types/session.h	/^	TT_HTTP_SRV = 0x30,$/;"	e	enum:__anon41
TT_HTTP_SRV_1	include/types/session.h	/^	TT_HTTP_SRV_1,$/;"	e	enum:__anon41
TT_HTTP_SRV_10	include/types/session.h	/^	TT_HTTP_SRV_10,$/;"	e	enum:__anon41
TT_HTTP_SRV_11	include/types/session.h	/^	TT_HTTP_SRV_11,$/;"	e	enum:__anon41
TT_HTTP_SRV_12	include/types/session.h	/^	TT_HTTP_SRV_12,$/;"	e	enum:__anon41
TT_HTTP_SRV_13	include/types/session.h	/^	TT_HTTP_SRV_13,$/;"	e	enum:__anon41
TT_HTTP_SRV_14	include/types/session.h	/^	TT_HTTP_SRV_14,$/;"	e	enum:__anon41
TT_HTTP_SRV_2	include/types/session.h	/^	TT_HTTP_SRV_2,$/;"	e	enum:__anon41
TT_HTTP_SRV_3	include/types/session.h	/^	TT_HTTP_SRV_3,$/;"	e	enum:__anon41
TT_HTTP_SRV_4	include/types/session.h	/^	TT_HTTP_SRV_4,$/;"	e	enum:__anon41
TT_HTTP_SRV_5	include/types/session.h	/^	TT_HTTP_SRV_5,$/;"	e	enum:__anon41
TT_HTTP_SRV_6	include/types/session.h	/^	TT_HTTP_SRV_6,$/;"	e	enum:__anon41
TT_HTTP_SRV_7	include/types/session.h	/^	TT_HTTP_SRV_7,$/;"	e	enum:__anon41
TT_HTTP_SRV_8	include/types/session.h	/^	TT_HTTP_SRV_8,$/;"	e	enum:__anon41
TT_HTTP_SRV_9	include/types/session.h	/^	TT_HTTP_SRV_9,$/;"	e	enum:__anon41
TT_HTTP_URI	include/types/session.h	/^	TT_HTTP_URI = 0x50,$/;"	e	enum:__anon41
TT_HTTP_URI_1	include/types/session.h	/^	TT_HTTP_URI_1,$/;"	e	enum:__anon41
TT_NONE	include/types/session.h	/^	TT_NONE     = 0,$/;"	e	enum:__anon41
_TYPES_SESSION_H	include/types/session.h	23;"	d
accept_date	include/types/session.h	/^		struct timeval accept_date;	\/* date of the accept() in user date *\/$/;"	m	struct:session::__anon43	typeref:struct:session::__anon43::timeval
back_refs	include/types/session.h	/^	struct list back_refs;			\/* list of users tracking this session *\/$/;"	m	struct:session	typeref:struct:session::list
be	include/types/session.h	/^	struct proxy *be;			\/* the proxy this session depends on for the server side *\/$/;"	m	struct:session	typeref:struct:session::proxy
by_srv	include/types/session.h	/^	struct list by_srv;			\/* position in server session list *\/$/;"	m	struct:session	typeref:struct:session::list
bytes_in	include/types/session.h	/^		long long bytes_in;		\/* number of bytes transferred from the client to the server *\/$/;"	m	struct:session::__anon43
bytes_out	include/types/session.h	/^		long long bytes_out;		\/* number of bytes transferred from the server to the client *\/$/;"	m	struct:session::__anon43
cache	include/types/session.h	/^	int cache;$/;"	m	struct:session
count	include/types/session.h	/^	int count;$/;"	m	struct:session
do_log	include/types/session.h	/^	void (*do_log)(struct session *s);	\/* the function to call in order to log (or NULL) *\/$/;"	m	struct:session
fe	include/types/session.h	/^	struct proxy *fe;			\/* the proxy this session depends on for the client side *\/$/;"	m	struct:session	typeref:struct:session::proxy
flags	include/types/session.h	/^		int flags;$/;"	m	struct:session::__anon42
flags	include/types/session.h	/^	int flags;				\/* some flags describing the session *\/$/;"	m	struct:session
fp	include/types/session.h	/^	FILE *fp;$/;"	m	struct:session
list	include/types/session.h	/^	struct list list;			\/* position in global sessions list *\/$/;"	m	struct:session	typeref:struct:session::list
listener	include/types/session.h	/^	struct listener *listener;		\/* the listener by which the request arrived *\/$/;"	m	struct:session	typeref:struct:session::listener
logs	include/types/session.h	/^	} logs;$/;"	m	struct:session	typeref:struct:session::__anon43
logwait	include/types/session.h	/^		int logwait;			\/* log fields waiting to be collected : LW_* *\/$/;"	m	struct:session::__anon43
n	include/types/session.h	/^		char *n;			\/* or its name during parsing. *\/$/;"	m	union:track_ctr_prm::__anon44
offset	include/types/session.h	/^	long offset;$/;"	m	struct:session
pend_pos	include/types/session.h	/^	struct pendconn *pend_pos;		\/* if not NULL, points to the position in the pending queue *\/$/;"	m	struct:session	typeref:struct:session::pendconn
prx_queue_size	include/types/session.h	/^		unsigned long prx_queue_size;	\/* overall number of sessions waiting for a connect slot on this instance at accept() time *\/$/;"	m	struct:session::__anon43
rep	include/types/session.h	/^	struct buffer *rep;			\/* response buffer *\/$/;"	m	struct:session	typeref:struct:session::buffer
req	include/types/session.h	/^	struct buffer *req;			\/* request buffer *\/$/;"	m	struct:session	typeref:struct:session::buffer
send_flag	include/types/session.h	/^	int send_flag;$/;"	m	struct:session
session	include/types/session.h	/^struct session {$/;"	s
si	include/types/session.h	/^	struct stream_interface si[2];          \/* client and server stream interfaces *\/$/;"	m	struct:session	typeref:struct:session::stream_interface
size	include/types/session.h	/^	long size;$/;"	m	struct:session
srv_conn	include/types/session.h	/^	struct server *srv_conn;		\/* session already has a slot on a server and is not in queue *\/$/;"	m	struct:session	typeref:struct:session::server
srv_error	include/types/session.h	/^	void (*srv_error)(struct session *s,	\/* the function to call upon unrecoverable server errors (or NULL) *\/$/;"	m	struct:session
srv_queue_size	include/types/session.h	/^		unsigned long srv_queue_size;	\/* number of sessions waiting for a connect slot on this server at accept() time (in direct assignment) *\/$/;"	m	struct:session::__anon43
stkctr1_entry	include/types/session.h	/^	struct stksess *stkctr1_entry;          \/* entry containing counters currently being tracked as set 1 by this session *\/$/;"	m	struct:session	typeref:struct:session::stksess
stkctr1_table	include/types/session.h	/^	struct stktable *stkctr1_table;         \/* table the counters above belong to (undefined if counters are null) *\/$/;"	m	struct:session	typeref:struct:session::stktable
stkctr2_entry	include/types/session.h	/^	struct stksess *stkctr2_entry;          \/* entry containing counters currently being tracked as set 2 by this session *\/$/;"	m	struct:session	typeref:struct:session::stksess
stkctr2_table	include/types/session.h	/^	struct stktable *stkctr2_table;         \/* table the counters above belong to (undefined if counters are null) *\/$/;"	m	struct:session	typeref:struct:session::stktable
store	include/types/session.h	/^	} store[8];				\/* tracked stickiness values to store *\/$/;"	m	struct:session	typeref:struct:session::__anon42
store_count	include/types/session.h	/^	int store_count;$/;"	m	struct:session
t	include/types/session.h	/^		struct stktable *t;		\/* a pointer to the table *\/$/;"	m	union:track_ctr_prm::__anon44	typeref:struct:track_ctr_prm::__anon44::stktable
t_close	include/types/session.h	/^		unsigned long t_close;		\/* total session duration *\/$/;"	m	struct:session::__anon43
t_connect	include/types/session.h	/^		long  t_connect;		\/* delay before the connect() to the server succeeds, -1 if never occurs *\/$/;"	m	struct:session::__anon43
t_data	include/types/session.h	/^		long  t_data;			\/* delay before the first data byte from the server ... *\/$/;"	m	struct:session::__anon43
t_queue	include/types/session.h	/^		long  t_queue;			\/* delay before the session gets out of the connect queue, -1 if never occurs *\/$/;"	m	struct:session::__anon43
table	include/types/session.h	/^		struct stktable *table;$/;"	m	struct:session::__anon42	typeref:struct:session::__anon42::stktable
table	include/types/session.h	/^	} table;$/;"	m	struct:track_ctr_prm	typeref:union:track_ctr_prm::__anon44
target	include/types/session.h	/^	struct target target;			\/* target to use for this session *\/$/;"	m	struct:session	typeref:struct:session::target
task	include/types/session.h	/^	struct task *task;			\/* the task associated with this session *\/$/;"	m	struct:session	typeref:struct:session::task
term_trace	include/types/session.h	/^	unsigned term_trace;			\/* term trace: 4*8 bits indicating which part of the code closed *\/$/;"	m	struct:session
track_ctr_prm	include/types/session.h	/^struct track_ctr_prm {$/;"	s
ts	include/types/session.h	/^		struct stksess *ts;$/;"	m	struct:session::__anon42	typeref:struct:session::__anon42::stksess
tv_accept	include/types/session.h	/^		struct timeval tv_accept;	\/* date of the accept() in internal date (monotonic) *\/$/;"	m	struct:session::__anon43	typeref:struct:session::__anon43::timeval
tv_request	include/types/session.h	/^		struct timeval tv_request;	\/* date the request arrives, {0,0} if never occurs *\/$/;"	m	struct:session::__anon43	typeref:struct:session::__anon43::timeval
txn	include/types/session.h	/^	struct http_txn txn;			\/* current HTTP transaction being processed. Should become a list. *\/$/;"	m	struct:session	typeref:struct:session::http_txn
type	include/types/session.h	/^	int type;				\/* type of the key *\/$/;"	m	struct:track_ctr_prm
uniq_id	include/types/session.h	/^	unsigned int uniq_id;			\/* unique ID used for the traces *\/$/;"	m	struct:session
unique_id	include/types/session.h	/^	char *unique_id;			\/* custom unique ID *\/$/;"	m	struct:session
SIG_F_ONE_SHOOT	include/types/signal.h	24;"	d
SIG_F_TYPE_FCT	include/types/signal.h	25;"	d
SIG_F_TYPE_TASK	include/types/signal.h	26;"	d
_TYPES_SIGNAL_H	include/types/signal.h	15;"	d
arg	include/types/signal.h	/^	int arg;                        \/* arg to pass to function, or signals*\/$/;"	m	struct:sig_handler
count	include/types/signal.h	/^	int count;                      \/* number of times raised *\/$/;"	m	struct:signal_descriptor
flags	include/types/signal.h	/^	int flags;                      \/* SIG_F_* *\/$/;"	m	struct:sig_handler
handler	include/types/signal.h	/^	void *handler;                  \/* function to call or task to wake up *\/$/;"	m	struct:sig_handler
handlers	include/types/signal.h	/^	struct list handlers;           \/* sig_handler *\/$/;"	m	struct:signal_descriptor	typeref:struct:signal_descriptor::list
list	include/types/signal.h	/^	struct list list;$/;"	m	struct:sig_handler	typeref:struct:sig_handler::list
sig_handler	include/types/signal.h	/^struct sig_handler {$/;"	s
signal_descriptor	include/types/signal.h	/^struct signal_descriptor {$/;"	s
ARG_T_DELAY	include/types/stick_table.h	/^	ARG_T_DELAY,              \/* a delay which supports time units *\/$/;"	e	enum:__anon57
ARG_T_INT	include/types/stick_table.h	/^	ARG_T_INT,                \/* signed integer *\/$/;"	e	enum:__anon57
ARG_T_NONE	include/types/stick_table.h	/^	ARG_T_NONE = 0,           \/* data type takes no argument (default) *\/$/;"	e	enum:__anon57
STD_T_FRQP	include/types/stick_table.h	/^	STD_T_FRQP,               \/* data is of type freq_ctr_period *\/$/;"	e	enum:__anon56
STD_T_SINT	include/types/stick_table.h	/^	STD_T_SINT = 0,           \/* data is of type signed int *\/$/;"	e	enum:__anon56
STD_T_UINT	include/types/stick_table.h	/^	STD_T_UINT,               \/* data is of type unsigned int *\/$/;"	e	enum:__anon56
STD_T_ULL	include/types/stick_table.h	/^	STD_T_ULL,                \/* data is of type unsigned long long *\/$/;"	e	enum:__anon56
STKTABLE_DATA_TYPES	include/types/stick_table.h	/^	STKTABLE_DATA_TYPES       \/* Number of data types, must always be last *\/$/;"	e	enum:__anon55
STKTABLE_DT_BYTES_IN_CNT	include/types/stick_table.h	/^	STKTABLE_DT_BYTES_IN_CNT, \/* cumulated bytes count from client to servers *\/$/;"	e	enum:__anon55
STKTABLE_DT_BYTES_IN_RATE	include/types/stick_table.h	/^	STKTABLE_DT_BYTES_IN_RATE,\/* bytes rate from client to servers *\/$/;"	e	enum:__anon55
STKTABLE_DT_BYTES_OUT_CNT	include/types/stick_table.h	/^	STKTABLE_DT_BYTES_OUT_CNT,\/* cumulated bytes count from servers to client *\/$/;"	e	enum:__anon55
STKTABLE_DT_BYTES_OUT_RATE	include/types/stick_table.h	/^	STKTABLE_DT_BYTES_OUT_RATE,\/* bytes rate from servers to client *\/$/;"	e	enum:__anon55
STKTABLE_DT_CONN_CNT	include/types/stick_table.h	/^	STKTABLE_DT_CONN_CNT,     \/* cumulated number of connections *\/$/;"	e	enum:__anon55
STKTABLE_DT_CONN_CUR	include/types/stick_table.h	/^	STKTABLE_DT_CONN_CUR,     \/* concurrent number of connections *\/$/;"	e	enum:__anon55
STKTABLE_DT_CONN_RATE	include/types/stick_table.h	/^	STKTABLE_DT_CONN_RATE,    \/* incoming connection rate *\/$/;"	e	enum:__anon55
STKTABLE_DT_GPC0	include/types/stick_table.h	/^	STKTABLE_DT_GPC0,         \/* General Purpose Counter 0 (unsigned 32-bit integer) *\/$/;"	e	enum:__anon55
STKTABLE_DT_HTTP_ERR_CNT	include/types/stick_table.h	/^	STKTABLE_DT_HTTP_ERR_CNT, \/* cumulated number of HTTP requests errors (4xx) *\/$/;"	e	enum:__anon55
STKTABLE_DT_HTTP_ERR_RATE	include/types/stick_table.h	/^	STKTABLE_DT_HTTP_ERR_RATE,\/* HTTP request error rate *\/$/;"	e	enum:__anon55
STKTABLE_DT_HTTP_REQ_CNT	include/types/stick_table.h	/^	STKTABLE_DT_HTTP_REQ_CNT, \/* cumulated number of incoming HTTP requests *\/$/;"	e	enum:__anon55
STKTABLE_DT_HTTP_REQ_RATE	include/types/stick_table.h	/^	STKTABLE_DT_HTTP_REQ_RATE,\/* incoming HTTP request rate *\/$/;"	e	enum:__anon55
STKTABLE_DT_SERVER_ID	include/types/stick_table.h	/^	STKTABLE_DT_SERVER_ID,    \/* the server ID to use with this session if > 0 *\/$/;"	e	enum:__anon55
STKTABLE_DT_SESS_CNT	include/types/stick_table.h	/^	STKTABLE_DT_SESS_CNT,     \/* cumulated number of sessions (accepted connections) *\/$/;"	e	enum:__anon55
STKTABLE_DT_SESS_RATE	include/types/stick_table.h	/^	STKTABLE_DT_SESS_RATE,    \/* accepted sessions rate *\/$/;"	e	enum:__anon55
STKTABLE_TYPES	include/types/stick_table.h	/^	STKTABLE_TYPES            \/* Number of types, must always be last *\/$/;"	e	enum:__anon54
STKTABLE_TYPE_BINARY	include/types/stick_table.h	/^	STKTABLE_TYPE_BINARY,     \/* table key is a buffer of data  *\/$/;"	e	enum:__anon54
STKTABLE_TYPE_INTEGER	include/types/stick_table.h	/^	STKTABLE_TYPE_INTEGER,    \/* table key is unsigned 32bit integer *\/$/;"	e	enum:__anon54
STKTABLE_TYPE_IP	include/types/stick_table.h	/^	STKTABLE_TYPE_IP = 0,     \/* table key is ipv4 *\/$/;"	e	enum:__anon54
STKTABLE_TYPE_IPV6	include/types/stick_table.h	/^	STKTABLE_TYPE_IPV6,       \/* table key is ipv6 *\/$/;"	e	enum:__anon54
STKTABLE_TYPE_STRING	include/types/stick_table.h	/^	STKTABLE_TYPE_STRING,     \/* table key is a null terminated string *\/$/;"	e	enum:__anon54
STK_F_CUSTOM_KEYSIZE	include/types/stick_table.h	114;"	d
_TYPES_STICK_TABLE_H	include/types/stick_table.h	24;"	d
arg_type	include/types/stick_table.h	/^	int arg_type;     \/* type of optional argument, ARG_T_* *\/$/;"	m	struct:stktable_data_type
buf	include/types/stick_table.h	/^	char buf[BUFSIZE];        \/* used to store a null terminated string key or a buffer of data *\/$/;"	m	union:stktable_key_data
bytes_in_cnt	include/types/stick_table.h	/^	unsigned long long bytes_in_cnt;$/;"	m	union:stktable_data
bytes_in_rate	include/types/stick_table.h	/^	struct freq_ctr_period bytes_in_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
bytes_out_cnt	include/types/stick_table.h	/^	unsigned long long bytes_out_cnt;$/;"	m	union:stktable_data
bytes_out_rate	include/types/stick_table.h	/^	struct freq_ctr_period bytes_out_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
conn_cnt	include/types/stick_table.h	/^	unsigned int conn_cnt;$/;"	m	union:stktable_data
conn_cur	include/types/stick_table.h	/^	unsigned int conn_cur;$/;"	m	union:stktable_data
conn_rate	include/types/stick_table.h	/^	struct freq_ctr_period conn_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
current	include/types/stick_table.h	/^	unsigned int current;     \/* number of sticky sessions currently in table *\/$/;"	m	struct:stktable
data	include/types/stick_table.h	/^	union stktable_key_data data;   \/* data *\/$/;"	m	struct:stktable_key	typeref:union:stktable_key::stktable_key_data
data_arg	include/types/stick_table.h	/^	} data_arg[STKTABLE_DATA_TYPES]; \/* optional argument of each data type *\/$/;"	m	struct:stktable	typeref:union:stktable::__anon59
data_ofs	include/types/stick_table.h	/^	int data_ofs[STKTABLE_DATA_TYPES]; \/* negative offsets of present data types, or 0 if absent *\/$/;"	m	struct:stktable
data_size	include/types/stick_table.h	/^	int data_size;            \/* the size of the data that is prepended *before* stksess *\/$/;"	m	struct:stktable
default_size	include/types/stick_table.h	/^	size_t default_size;      \/* default key size *\/$/;"	m	struct:stktable_type
exp	include/types/stick_table.h	/^	struct eb32_node exp;     \/* ebtree node used to hold the session in expiration tree *\/$/;"	m	struct:stksess	typeref:struct:stksess::eb32_node
exp_next	include/types/stick_table.h	/^	int exp_next;             \/* next expiration date (ticks) *\/$/;"	m	struct:stktable
exp_task	include/types/stick_table.h	/^	struct task *exp_task;    \/* expiration task *\/$/;"	m	struct:stktable	typeref:struct:stktable::task
expire	include/types/stick_table.h	/^	int expire;               \/* time to live for sticky sessions (milliseconds) *\/$/;"	m	struct:stktable
expire	include/types/stick_table.h	/^	unsigned int expire;      \/* session expiration date *\/$/;"	m	struct:stksess
exps	include/types/stick_table.h	/^	struct eb_root exps;      \/* head of sticky session expiration tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root
flags	include/types/stick_table.h	/^	int flags;                \/* type flags *\/$/;"	m	struct:stktable_type
gpc0	include/types/stick_table.h	/^	unsigned int gpc0;$/;"	m	union:stktable_data
http_err_cnt	include/types/stick_table.h	/^	unsigned int http_err_cnt;$/;"	m	union:stktable_data
http_err_rate	include/types/stick_table.h	/^	struct freq_ctr_period http_err_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
http_req_cnt	include/types/stick_table.h	/^	unsigned int http_req_cnt;$/;"	m	union:stktable_data
http_req_rate	include/types/stick_table.h	/^	struct freq_ctr_period http_req_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
i	include/types/stick_table.h	/^		int i;$/;"	m	union:stktable::__anon59
id	include/types/stick_table.h	/^	char *id;		  \/* table id name *\/$/;"	m	struct:stktable
integer	include/types/stick_table.h	/^	uint32_t integer;         \/* used to store an integer key *\/$/;"	m	union:stktable_key_data
ip	include/types/stick_table.h	/^	struct in_addr ip;        \/* used to store an ipv4 key *\/$/;"	m	union:stktable_key_data	typeref:struct:stktable_key_data::in_addr
ipv6	include/types/stick_table.h	/^	struct in6_addr ipv6;     \/* used to store an ipv6 key *\/$/;"	m	union:stktable_key_data	typeref:struct:stktable_key_data::in6_addr
key	include/types/stick_table.h	/^	struct ebmb_node key;     \/* ebtree node used to hold the session in table *\/$/;"	m	struct:stksess	typeref:struct:stksess::ebmb_node
key	include/types/stick_table.h	/^	void *key;                      \/* pointer on key buffer *\/$/;"	m	struct:stktable_key
key_len	include/types/stick_table.h	/^	size_t key_len;                 \/* data len to read in buff in case of null terminated string *\/$/;"	m	struct:stktable_key
key_size	include/types/stick_table.h	/^	size_t key_size;          \/* size of a key, maximum size in case of string *\/$/;"	m	struct:stktable
keys	include/types/stick_table.h	/^	struct eb_root keys;      \/* head of sticky session tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root
kw	include/types/stick_table.h	/^	const char *kw;           \/* keyword string *\/$/;"	m	struct:stktable_type
localupdate	include/types/stick_table.h	/^	unsigned int localupdate;$/;"	m	struct:stktable
name	include/types/stick_table.h	/^		char *name;$/;"	m	union:stktable::__anon58
name	include/types/stick_table.h	/^	const char *name; \/* name of the data type *\/$/;"	m	struct:stktable_data_type
nopurge	include/types/stick_table.h	/^	int nopurge;              \/* if non-zero, don't purge sticky sessions when full *\/$/;"	m	struct:stktable
p	include/types/stick_table.h	/^		struct peers *p; \/* sync peers *\/$/;"	m	union:stktable::__anon58	typeref:struct:stktable::__anon58::peers
p	include/types/stick_table.h	/^		void *p;$/;"	m	union:stktable::__anon59
peers	include/types/stick_table.h	/^	} peers;$/;"	m	struct:stktable	typeref:union:stktable::__anon58
pool	include/types/stick_table.h	/^	struct pool_head *pool;   \/* pool used to allocate sticky sessions *\/$/;"	m	struct:stktable	typeref:struct:stktable::pool_head
ref_cnt	include/types/stick_table.h	/^	unsigned int ref_cnt;     \/* reference count, can only purge when zero *\/$/;"	m	struct:stksess
server_id	include/types/stick_table.h	/^	int server_id;$/;"	m	union:stktable_data
sess_cnt	include/types/stick_table.h	/^	unsigned int sess_cnt;$/;"	m	union:stktable_data
sess_rate	include/types/stick_table.h	/^	struct freq_ctr_period sess_rate;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
size	include/types/stick_table.h	/^	unsigned int size;        \/* maximum number of sticky sessions in table *\/$/;"	m	struct:stktable
std_t_frqp	include/types/stick_table.h	/^	struct freq_ctr_period std_t_frqp;$/;"	m	union:stktable_data	typeref:struct:stktable_data::freq_ctr_period
std_t_sint	include/types/stick_table.h	/^	int std_t_sint;$/;"	m	union:stktable_data
std_t_uint	include/types/stick_table.h	/^	unsigned int std_t_uint;$/;"	m	union:stktable_data
std_t_ull	include/types/stick_table.h	/^	unsigned long long std_t_ull;$/;"	m	union:stktable_data
std_type	include/types/stick_table.h	/^	int std_type;     \/* standard type we can use for this data, STD_T_* *\/$/;"	m	struct:stktable_data_type
stksess	include/types/stick_table.h	/^struct stksess {$/;"	s
stktable	include/types/stick_table.h	/^struct stktable {$/;"	s
stktable_data	include/types/stick_table.h	/^union stktable_data {$/;"	u
stktable_data_type	include/types/stick_table.h	/^struct stktable_data_type {$/;"	s
stktable_key	include/types/stick_table.h	/^struct stktable_key {$/;"	s
stktable_key_data	include/types/stick_table.h	/^union stktable_key_data {$/;"	u
stktable_type	include/types/stick_table.h	/^struct stktable_type {$/;"	s
sync_task	include/types/stick_table.h	/^	struct task *sync_task;   \/* sync task *\/$/;"	m	struct:stktable	typeref:struct:stktable::task
type	include/types/stick_table.h	/^	unsigned long type;       \/* type of table (determines key format) *\/$/;"	m	struct:stktable
u	include/types/stick_table.h	/^		unsigned int u;$/;"	m	union:stktable::__anon59
upd	include/types/stick_table.h	/^	struct eb32_node upd;     \/* ebtree node used to hold the update sequence tree *\/$/;"	m	struct:stksess	typeref:struct:stksess::eb32_node
update	include/types/stick_table.h	/^	unsigned int update;$/;"	m	struct:stktable
updates	include/types/stick_table.h	/^	struct eb_root updates;   \/* head of sticky updates sequence tree *\/$/;"	m	struct:stktable	typeref:struct:stktable::eb_root
SI_ET_CONN_ABRT	include/types/stream_interface.h	/^	SI_ET_CONN_ABRT  = 0x0020,  \/* connection aborted by external cause (eg: abort) *\/$/;"	e	enum:__anon26
SI_ET_CONN_ERR	include/types/stream_interface.h	/^	SI_ET_CONN_ERR   = 0x0010,  \/* connection error (eg: no server available) *\/$/;"	e	enum:__anon26
SI_ET_CONN_OTHER	include/types/stream_interface.h	/^	SI_ET_CONN_OTHER = 0x0040,  \/* connection aborted for other reason (eg: 500) *\/$/;"	e	enum:__anon26
SI_ET_CONN_TO	include/types/stream_interface.h	/^	SI_ET_CONN_TO    = 0x0008,  \/* connection timeout *\/$/;"	e	enum:__anon26
SI_ET_DATA_ABRT	include/types/stream_interface.h	/^	SI_ET_DATA_ABRT  = 0x0200,  \/* data phase aborted by external cause *\/$/;"	e	enum:__anon26
SI_ET_DATA_ERR	include/types/stream_interface.h	/^	SI_ET_DATA_ERR   = 0x0100,  \/* error during data phase *\/$/;"	e	enum:__anon26
SI_ET_DATA_TO	include/types/stream_interface.h	/^	SI_ET_DATA_TO    = 0x0080,  \/* timeout during data phase *\/$/;"	e	enum:__anon26
SI_ET_NONE	include/types/stream_interface.h	/^	SI_ET_NONE       = 0x0000,  \/* no error yet, leave it to zero *\/$/;"	e	enum:__anon26
SI_ET_QUEUE_ABRT	include/types/stream_interface.h	/^	SI_ET_QUEUE_ABRT = 0x0004,  \/* aborted in queue by external cause *\/$/;"	e	enum:__anon26
SI_ET_QUEUE_ERR	include/types/stream_interface.h	/^	SI_ET_QUEUE_ERR  = 0x0002,  \/* queue error (eg: full) *\/$/;"	e	enum:__anon26
SI_ET_QUEUE_TO	include/types/stream_interface.h	/^	SI_ET_QUEUE_TO   = 0x0001,  \/* queue timeout *\/$/;"	e	enum:__anon26
SI_FL_CAP_SPLICE	include/types/stream_interface.h	91;"	d
SI_FL_CAP_SPLTCP	include/types/stream_interface.h	/^	SI_FL_CAP_SPLTCP = 0x0010,  \/* splicing possible from\/to TCP *\/$/;"	e	enum:__anon27
SI_FL_DONT_WAKE	include/types/stream_interface.h	/^	SI_FL_DONT_WAKE  = 0x0020,  \/* resync in progress, don't wake up *\/$/;"	e	enum:__anon27
SI_FL_ERR	include/types/stream_interface.h	/^	SI_FL_ERR        = 0x0002,  \/* a non-recoverable error has occurred *\/$/;"	e	enum:__anon27
SI_FL_EXP	include/types/stream_interface.h	/^	SI_FL_EXP        = 0x0001,  \/* timeout has expired *\/$/;"	e	enum:__anon27
SI_FL_FROM_SET	include/types/stream_interface.h	/^	SI_FL_FROM_SET   = 0x4000,  \/* addr.from is set *\/$/;"	e	enum:__anon27
SI_FL_INDEP_STR	include/types/stream_interface.h	/^	SI_FL_INDEP_STR  = 0x0040,  \/* independant streams = don't update rex on write *\/$/;"	e	enum:__anon27
SI_FL_NOHALF	include/types/stream_interface.h	/^	SI_FL_NOHALF     = 0x0100,  \/* no half close, close both sides at once *\/$/;"	e	enum:__anon27
SI_FL_NOLINGER	include/types/stream_interface.h	/^	SI_FL_NOLINGER   = 0x0080,  \/* may close without lingering. One-shot. *\/$/;"	e	enum:__anon27
SI_FL_NONE	include/types/stream_interface.h	/^	SI_FL_NONE       = 0x0000,  \/* nothing *\/$/;"	e	enum:__anon27
SI_FL_SRC_ADDR	include/types/stream_interface.h	/^	SI_FL_SRC_ADDR   = 0x1000,  \/* get the source ip\/port with getsockname *\/$/;"	e	enum:__anon27
SI_FL_TO_SET	include/types/stream_interface.h	/^	SI_FL_TO_SET     = 0x2000,  \/* addr.to is set *\/$/;"	e	enum:__anon27
SI_FL_WAIT_DATA	include/types/stream_interface.h	/^	SI_FL_WAIT_DATA  = 0x0008,  \/* waiting for more data to send *\/$/;"	e	enum:__anon27
SI_FL_WAIT_ROOM	include/types/stream_interface.h	/^	SI_FL_WAIT_ROOM  = 0x0004,  \/* waiting for space to store incoming data *\/$/;"	e	enum:__anon27
SI_ST_ASS	include/types/stream_interface.h	/^	SI_ST_ASS,               \/* server just assigned to this interface *\/$/;"	e	enum:__anon25
SI_ST_CER	include/types/stream_interface.h	/^	SI_ST_CER,               \/* [transient] previous connection attempt failed (resource released) *\/$/;"	e	enum:__anon25
SI_ST_CLO	include/types/stream_interface.h	/^	SI_ST_CLO,               \/* stream intf closed, might not existing anymore. Buffers shut. *\/$/;"	e	enum:__anon25
SI_ST_CON	include/types/stream_interface.h	/^	SI_ST_CON,               \/* initiated connection request (resource exists) *\/$/;"	e	enum:__anon25
SI_ST_DIS	include/types/stream_interface.h	/^	SI_ST_DIS,               \/* [transient] disconnected from other side, but cleanup not done yet *\/$/;"	e	enum:__anon25
SI_ST_EST	include/types/stream_interface.h	/^	SI_ST_EST,               \/* connection established (resource exists) *\/$/;"	e	enum:__anon25
SI_ST_INI	include/types/stream_interface.h	/^	SI_ST_INI = 0,           \/* interface not sollicitated yet *\/$/;"	e	enum:__anon25
SI_ST_QUE	include/types/stream_interface.h	/^	SI_ST_QUE,               \/* interface waiting in queue *\/$/;"	e	enum:__anon25
SI_ST_REQ	include/types/stream_interface.h	/^	SI_ST_REQ,               \/* [transient] connection initiation desired and not started yet *\/$/;"	e	enum:__anon25
SI_ST_TAR	include/types/stream_interface.h	/^	SI_ST_TAR,               \/* interface in turn-around state after failed connect attempt *\/$/;"	e	enum:__anon25
TARG_TYPE_APPLET	include/types/stream_interface.h	/^	TARG_TYPE_APPLET,           \/* target is an applet ; use only the applet *\/$/;"	e	enum:__anon28
TARG_TYPE_CLIENT	include/types/stream_interface.h	/^	TARG_TYPE_CLIENT,           \/* target is a client, pointer is NULL by definition *\/$/;"	e	enum:__anon28
TARG_TYPE_NONE	include/types/stream_interface.h	/^	TARG_TYPE_NONE = 0,         \/* no target set, pointer is NULL by definition *\/$/;"	e	enum:__anon28
TARG_TYPE_PROXY	include/types/stream_interface.h	/^	TARG_TYPE_PROXY,            \/* target is a proxy   ; use address with the proxy's settings *\/$/;"	e	enum:__anon28
TARG_TYPE_SERVER	include/types/stream_interface.h	/^	TARG_TYPE_SERVER,           \/* target is a server  ; use address with server's and its proxy's settings *\/$/;"	e	enum:__anon28
TARG_TYPE_TASK	include/types/stream_interface.h	/^	TARG_TYPE_TASK,             \/* target is a task running an external applet *\/$/;"	e	enum:__anon28
_TYPES_STREAM_INTERFACE_H	include/types/stream_interface.h	23;"	d
a	include/types/stream_interface.h	/^		struct si_applet *a;  \/* when type is TARG_TYPE_APPLET *\/$/;"	m	union:target::__anon31	typeref:struct:target::__anon31::si_applet
addr	include/types/stream_interface.h	/^	} addr; \/* addresses of the remote side, client for producer and server for consumer *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::__anon39
applet	include/types/stream_interface.h	/^	} applet;$/;"	m	struct:stream_interface	typeref:struct:stream_interface::__anon32
bol	include/types/stream_interface.h	/^				int bol;		\/* pointer to beginning of current line *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon36
bref	include/types/stream_interface.h	/^				struct bref bref;	\/* back-reference from the session being dumped *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon35	typeref:struct:stream_interface::__anon32::__anon33::__anon35::bref
buf	include/types/stream_interface.h	/^				unsigned int buf;	\/* buffer being dumped, 0 = req, 1 = rep *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon36
chk_rcv	include/types/stream_interface.h	/^	void (*chk_rcv)(struct stream_interface *); \/* chk_rcv function *\/$/;"	m	struct:sock_ops
chk_snd	include/types/stream_interface.h	/^	void (*chk_snd)(struct stream_interface *); \/* chk_snd function *\/$/;"	m	struct:sock_ops
cli	include/types/stream_interface.h	/^			} cli;$/;"	m	union:stream_interface::__anon32::__anon33	typeref:struct:stream_interface::__anon32::__anon33::__anon38
close	include/types/stream_interface.h	/^	void (*close)(struct connection *);         \/* close the data channel on the connection *\/$/;"	m	struct:sock_ops
conn	include/types/stream_interface.h	/^	struct connection conn; \/* descriptor for a connection *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::connection
conn_retries	include/types/stream_interface.h	/^	int conn_retries;	\/* number of connect retries left *\/$/;"	m	struct:stream_interface
connection	include/types/stream_interface.h	/^struct connection {$/;"	s
ctrl	include/types/stream_interface.h	/^	const struct protocol *ctrl;  \/* operations at the control layer, generally a protocol *\/$/;"	m	struct:connection	typeref:struct:connection::protocol
ctx	include/types/stream_interface.h	/^		} ctx;					\/* used by stats I\/O handlers to dump the stats *\/$/;"	m	struct:stream_interface::__anon32	typeref:union:stream_interface::__anon32::__anon33
data	include/types/stream_interface.h	/^	const struct sock_ops *data;  \/* operations at the data layer *\/$/;"	m	struct:connection	typeref:struct:connection::sock_ops
data_ctx	include/types/stream_interface.h	/^	void *data_ctx;               \/* general purpose pointer, initialized to NULL *\/$/;"	m	struct:connection
data_op	include/types/stream_interface.h	/^				signed char data_op;	\/* operator (STD_OP_*) when data_type set *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon37
data_st	include/types/stream_interface.h	/^	int data_st;                  \/* data layer state, initialized to zero *\/$/;"	m	struct:connection
data_type	include/types/stream_interface.h	/^				signed char data_type;	\/* type of data to compare, or -1 if none *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon37
entry	include/types/stream_interface.h	/^				struct stksess *entry;	\/* last entry we were trying to dump (or first if NULL) *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon37	typeref:struct:stream_interface::__anon32::__anon33::__anon37::stksess
err_loc	include/types/stream_interface.h	/^	void *err_loc;          \/* commonly the server, NULL when SI_ET_NONE *\/$/;"	m	struct:stream_interface
err_type	include/types/stream_interface.h	/^	unsigned int err_type;  \/* first error detected, one of SI_ET_* *\/$/;"	m	struct:stream_interface
errors	include/types/stream_interface.h	/^			} errors;$/;"	m	union:stream_interface::__anon32::__anon33	typeref:struct:stream_interface::__anon32::__anon33::__anon36
exp	include/types/stream_interface.h	/^	unsigned int exp;       \/* wake up time for connect, queue, turn-around, ... *\/$/;"	m	struct:stream_interface
fct	include/types/stream_interface.h	/^	void (*fct)(struct stream_interface *);  \/* internal I\/O handler, may never be NULL *\/$/;"	m	struct:si_applet
fd	include/types/stream_interface.h	/^			int fd;       \/* file descriptor for a stream driver when known *\/$/;"	m	struct:connection::__anon29::__anon30
flags	include/types/stream_interface.h	/^				unsigned int flags;	\/* STAT_* *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon34
flags	include/types/stream_interface.h	/^	unsigned int flags;     \/* SI_FL_* *\/$/;"	m	struct:stream_interface
from	include/types/stream_interface.h	/^		struct sockaddr_storage from;	\/* client address, or address to spoof when connecting to the server *\/$/;"	m	struct:stream_interface::__anon39	typeref:struct:stream_interface::__anon39::sockaddr_storage
ib	include/types/stream_interface.h	/^	struct buffer *ib, *ob; \/* input and output buffers *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::buffer
iid	include/types/stream_interface.h	/^				int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon34
iid	include/types/stream_interface.h	/^				int iid;		\/* if >= 0, ID of the proxy to filter on *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon36
l	include/types/stream_interface.h	/^				struct listener *l;$/;"	m	struct:stream_interface::__anon32::__anon33::__anon34	typeref:struct:stream_interface::__anon32::__anon33::__anon34::listener
l	include/types/stream_interface.h	/^		struct listener *l;   \/* when type is TARG_TYPE_CLIENT *\/$/;"	m	union:target::__anon31	typeref:struct:target::__anon31::listener
msg	include/types/stream_interface.h	/^				const char *msg;	\/* pointer to a persistent message to be returned in PRINT state *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon38
name	include/types/stream_interface.h	/^	char *name; \/* applet's name to report in logs *\/$/;"	m	struct:si_applet
ob	include/types/stream_interface.h	/^	struct buffer *ib, *ob; \/* input and output buffers *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::
owner	include/types/stream_interface.h	/^	void *owner;            \/* generally a (struct task*) *\/$/;"	m	struct:stream_interface
p	include/types/stream_interface.h	/^		struct proxy *p;      \/* when type is TARG_TYPE_PROXY  *\/$/;"	m	union:target::__anon31	typeref:struct:target::__anon31::proxy
pos	include/types/stream_interface.h	/^				int pos;		\/* last position of the current session's buffer *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon35
prev_state	include/types/stream_interface.h	/^	unsigned int prev_state;\/* SI_ST*, copy of previous state *\/$/;"	m	struct:stream_interface
proxy	include/types/stream_interface.h	/^				struct proxy *proxy;	\/* table being currently dumped (first if NULL) *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon37	typeref:struct:stream_interface::__anon32::__anon33::__anon37::proxy
ptr	include/types/stream_interface.h	/^				int ptr;		\/* <0: headers, >=0 : text pointer to restart from *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon36
ptr	include/types/stream_interface.h	/^	} ptr;$/;"	m	struct:target	typeref:union:target::__anon31
px	include/types/stream_interface.h	/^				struct proxy *px;	\/* current proxy being dumped, NULL = not started yet. *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon36	typeref:struct:stream_interface::__anon32::__anon33::__anon36::proxy
px	include/types/stream_interface.h	/^				struct proxy *px;$/;"	m	struct:stream_interface::__anon32::__anon33::__anon34	typeref:struct:stream_interface::__anon32::__anon33::__anon34::proxy
px_st	include/types/stream_interface.h	/^				int px_st;		\/* STAT_PX_ST* *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon34
read	include/types/stream_interface.h	/^	int (*read)(int fd);                        \/* read callback after poll() *\/$/;"	m	struct:sock_ops
release	include/types/stream_interface.h	/^	void (*release)(struct stream_interface *);  \/* callback to release resources, may be NULL *\/$/;"	m	struct:si_applet
release	include/types/stream_interface.h	/^	void (*release)(struct stream_interface *); \/* handler to call after the last close() *\/$/;"	m	struct:stream_interface
s	include/types/stream_interface.h	/^		struct server *s;     \/* when type is TARG_TYPE_SERVER *\/$/;"	m	union:target::__anon31	typeref:struct:target::__anon31::server
section	include/types/stream_interface.h	/^				int section;		\/* section of the session being dumped *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon35
send_proxy_ofs	include/types/stream_interface.h	/^	int send_proxy_ofs;	\/* <0 = offset to (re)send from the end, >0 = send all *\/$/;"	m	struct:stream_interface
sess	include/types/stream_interface.h	/^			} sess;$/;"	m	union:stream_interface::__anon32::__anon33	typeref:struct:stream_interface::__anon32::__anon33::__anon35
shutr	include/types/stream_interface.h	/^	void (*shutr)(struct stream_interface *);   \/* shutr function *\/$/;"	m	struct:sock_ops
shutw	include/types/stream_interface.h	/^	void (*shutw)(struct stream_interface *);   \/* shutw function *\/$/;"	m	struct:sock_ops
si_applet	include/types/stream_interface.h	/^struct si_applet {$/;"	s
sid	include/types/stream_interface.h	/^				int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon34
sid	include/types/stream_interface.h	/^				unsigned int sid;	\/* session ID of error being dumped *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon36
sock	include/types/stream_interface.h	/^		} sock;$/;"	m	union:connection::__anon29	typeref:struct:connection::__anon29::__anon30
sock_ops	include/types/stream_interface.h	/^struct sock_ops {$/;"	s
st0	include/types/stream_interface.h	/^		unsigned int st0, st1;     \/* may be used by any function above *\/$/;"	m	struct:stream_interface::__anon32
st1	include/types/stream_interface.h	/^		unsigned int st0, st1;     \/* may be used by any function above *\/$/;"	m	struct:stream_interface::__anon32
st_code	include/types/stream_interface.h	/^				int st_code;		\/* the status code returned by an action *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon34
state	include/types/stream_interface.h	/^	unsigned int state;     \/* SI_ST* *\/$/;"	m	struct:stream_interface
stats	include/types/stream_interface.h	/^			} stats;$/;"	m	union:stream_interface::__anon32::__anon33	typeref:struct:stream_interface::__anon32::__anon33::__anon34
stream_interface	include/types/stream_interface.h	/^struct stream_interface {$/;"	s
sv	include/types/stream_interface.h	/^				struct server *sv;$/;"	m	struct:stream_interface::__anon32::__anon33::__anon34	typeref:struct:stream_interface::__anon32::__anon33::__anon34::server
t	include/types/stream_interface.h	/^		struct task *t;       \/* when type is TARG_TYPE_TASK *\/$/;"	m	union:target::__anon31	typeref:struct:target::__anon31::task
t	include/types/stream_interface.h	/^	} t;$/;"	m	struct:connection	typeref:union:connection::__anon29
table	include/types/stream_interface.h	/^			} table;$/;"	m	union:stream_interface::__anon32::__anon33	typeref:struct:stream_interface::__anon32::__anon33::__anon37
target	include/types/stream_interface.h	/^				void *target;		\/* session we want to dump, or NULL for all *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon35
target	include/types/stream_interface.h	/^				void *target;		\/* table we want to dump, or NULL for all *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon37
target	include/types/stream_interface.h	/^	struct target target;	\/* the target to connect to (server, proxy, applet, ...) *\/$/;"	m	struct:stream_interface	typeref:struct:stream_interface::target
target	include/types/stream_interface.h	/^struct target {$/;"	s
to	include/types/stream_interface.h	/^		struct sockaddr_storage to;	\/* address reached by the client if SN_FRT_ADDR_SET is set, or address to connect to *\/$/;"	m	struct:stream_interface::__anon39	typeref:struct:stream_interface::__anon39::sockaddr_storage
type	include/types/stream_interface.h	/^				int iid, type, sid;	\/* proxy id, type and service id if bounding of stats is enabled *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon34
type	include/types/stream_interface.h	/^	int type;$/;"	m	struct:target
uid	include/types/stream_interface.h	/^				unsigned int uid;	\/* if non-null, the uniq_id of the session being dumped *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon35
update	include/types/stream_interface.h	/^	void (*update)(struct stream_interface *);  \/* I\/O update function *\/$/;"	m	struct:sock_ops
v	include/types/stream_interface.h	/^		void *v;              \/* pointer value, for any type *\/$/;"	m	union:target::__anon31
value	include/types/stream_interface.h	/^				long long value;	\/* value to compare against *\/$/;"	m	struct:stream_interface::__anon32::__anon33::__anon37
write	include/types/stream_interface.h	/^	int (*write)(int fd);                       \/* write callback after poll() *\/$/;"	m	struct:sock_ops
TASK_REASON_SHIFT	include/types/task.h	51;"	d
TASK_RUNNING	include/types/task.h	33;"	d
TASK_SLEEPING	include/types/task.h	32;"	d
TASK_WOKEN_ANY	include/types/task.h	43;"	d
TASK_WOKEN_INIT	include/types/task.h	34;"	d
TASK_WOKEN_IO	include/types/task.h	36;"	d
TASK_WOKEN_MSG	include/types/task.h	38;"	d
TASK_WOKEN_OTHER	include/types/task.h	40;"	d
TASK_WOKEN_RES	include/types/task.h	39;"	d
TASK_WOKEN_SIGNAL	include/types/task.h	37;"	d
TASK_WOKEN_TIMER	include/types/task.h	35;"	d
_TYPES_TASK_H	include/types/task.h	23;"	d
calls	include/types/task.h	/^	unsigned int calls;		\/* number of times ->process() was called *\/$/;"	m	struct:task
context	include/types/task.h	/^	void *context;			\/* the task's context *\/$/;"	m	struct:task
expire	include/types/task.h	/^	int expire;			\/* next expiration date for this task, in ticks *\/$/;"	m	struct:task
nice	include/types/task.h	/^	int nice;			\/* the task's current nice value from -1024 to +1024 *\/$/;"	m	struct:task
process	include/types/task.h	/^	struct task * (*process)(struct task *t);  \/* the function which processes the task *\/$/;"	m	struct:task	typeref:struct:task::process
rq	include/types/task.h	/^	struct eb32_node rq;		\/* ebtree node used to hold the task in the run queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node
state	include/types/task.h	/^	int state;			\/* task state : bit field of TASK_* *\/$/;"	m	struct:task
task	include/types/task.h	/^struct task {$/;"	s
wq	include/types/task.h	/^	struct eb32_node wq;		\/* ebtree node used to hold the task in the wait queue *\/$/;"	m	struct:task	typeref:struct:task::eb32_node
_TYPES_TEMPLATE_H	include/types/template.h	23;"	d
__acl_init	src/acl.c	/^static void __acl_init(void)$/;"	f	file:
acl_exec_cond	src/acl.c	/^int acl_exec_cond(struct acl_cond *cond, struct proxy *px, struct session *l4, void *l7, unsigned int opt)$/;"	f
acl_fetch_false	src/acl.c	/^acl_fetch_false(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_nothing	src/acl.c	/^int acl_fetch_nothing(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f
acl_fetch_req_len	src/acl.c	/^acl_fetch_req_len(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_req_ssl_ver	src/acl.c	/^acl_fetch_req_ssl_ver(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_ssl_hello_sni	src/acl.c	/^acl_fetch_ssl_hello_sni(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_ssl_hello_type	src/acl.c	/^acl_fetch_ssl_hello_type(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_true	src/acl.c	/^acl_fetch_true(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_wait_end	src/acl.c	/^acl_fetch_wait_end(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_find_targets	src/acl.c	/^acl_find_targets(struct proxy *p)$/;"	f
acl_free_reg	src/acl.c	/^static void acl_free_reg(void *ptr)$/;"	f	file:
acl_keywords	src/acl.c	/^static struct acl_kw_list acl_keywords = {$/;"	v	typeref:struct:acl_kw_list	file:
acl_kws	src/acl.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
acl_lookup_ip	src/acl.c	/^static void *acl_lookup_ip(struct sample *smp, struct acl_expr *expr)$/;"	f	file:
acl_lookup_str	src/acl.c	/^static void *acl_lookup_str(struct sample *smp, struct acl_expr *expr)$/;"	f	file:
acl_match_beg	src/acl.c	/^int acl_match_beg(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_dir	src/acl.c	/^int acl_match_dir(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_dom	src/acl.c	/^int acl_match_dom(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_end	src/acl.c	/^int acl_match_end(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_int	src/acl.c	/^int acl_match_int(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_ip	src/acl.c	/^int acl_match_ip(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_len	src/acl.c	/^int acl_match_len(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_nothing	src/acl.c	/^int acl_match_nothing(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_reg	src/acl.c	/^int acl_match_reg(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_str	src/acl.c	/^int acl_match_str(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_match_sub	src/acl.c	/^int acl_match_sub(struct sample *smp, struct acl_pattern *pattern)$/;"	f
acl_parse_dotted_ver	src/acl.c	/^int acl_parse_dotted_ver(const char **text, struct acl_pattern *pattern, int *opaque, char **err)$/;"	f
acl_parse_int	src/acl.c	/^int acl_parse_int(const char **text, struct acl_pattern *pattern, int *opaque, char **err)$/;"	f
acl_parse_ip	src/acl.c	/^int acl_parse_ip(const char **text, struct acl_pattern *pattern, int *opaque, char **err)$/;"	f
acl_parse_nothing	src/acl.c	/^int acl_parse_nothing(const char **text, struct acl_pattern *pattern, int *opaque, char **err)$/;"	f
acl_parse_reg	src/acl.c	/^int acl_parse_reg(const char **text, struct acl_pattern *pattern, int *opaque, char **err)$/;"	f
acl_parse_str	src/acl.c	/^int acl_parse_str(const char **text, struct acl_pattern *pattern, int *opaque, char **err)$/;"	f
acl_parse_strcat	src/acl.c	/^acl_parse_strcat(const char **text, struct acl_pattern *pattern, int *opaque, char **err)$/;"	f
acl_read_patterns_from_file	src/acl.c	/^static int acl_read_patterns_from_file(	struct acl_keyword *aclkw,$/;"	f	file:
acl_register_keywords	src/acl.c	/^void acl_register_keywords(struct acl_kw_list *kwl)$/;"	f
acl_unregister_keywords	src/acl.c	/^void acl_unregister_keywords(struct acl_kw_list *kwl)$/;"	f
build_acl_cond	src/acl.c	/^struct acl_cond *build_acl_cond(const char *file, int line, struct proxy *px, const char **args, char **err)$/;"	f
cond_find_require	src/acl.c	/^struct acl *cond_find_require(const struct acl_cond *cond, unsigned int require)$/;"	f
default_acl_list	src/acl.c	/^} default_acl_list[] = {$/;"	v	typeref:struct:__anon102
expr	src/acl.c	/^	const char *expr[4]; \/* put enough for longest expression *\/$/;"	m	struct:__anon102	file:
filt_cap	src/acl.c	/^const unsigned int filt_cap[] = {$/;"	v
find_acl_by_name	src/acl.c	/^struct acl *find_acl_by_name(const char *name, struct list *head)$/;"	f
find_acl_default	src/acl.c	/^struct acl *find_acl_default(const char *acl_name, struct list *known_acl, char **err)$/;"	f
find_acl_kw	src/acl.c	/^struct acl_keyword *find_acl_kw(const char *kw)$/;"	f
free_pattern	src/acl.c	/^static void free_pattern(struct acl_pattern *pat)$/;"	f	file:
free_pattern_list	src/acl.c	/^static void free_pattern_list(struct list *head)$/;"	f	file:
free_pattern_tree	src/acl.c	/^static void free_pattern_tree(struct eb_root *root)$/;"	f	file:
is_delimiter	src/acl.c	/^static inline unsigned int is_delimiter(unsigned char c, unsigned int mask)$/;"	f	file:
make_4delim	src/acl.c	/^static inline unsigned int make_4delim(unsigned char d1, unsigned char d2, unsigned char d3, unsigned char d4)$/;"	f	file:
match_word	src/acl.c	/^static int match_word(struct sample *smp, struct acl_pattern *pattern, unsigned int delimiters)$/;"	f	file:
name	src/acl.c	/^	const char *name;$/;"	m	struct:__anon102	file:
parse_acl	src/acl.c	/^struct acl *parse_acl(const char **args, struct list *known_acl, char **err)$/;"	f
parse_acl_cond	src/acl.c	/^struct acl_cond *parse_acl_cond(const char **args, struct list *known_acl, int pol, char **err)$/;"	f
parse_acl_expr	src/acl.c	/^struct acl_expr *parse_acl_expr(const char **args, char **err)$/;"	f
prune_acl	src/acl.c	/^struct acl *prune_acl(struct acl *acl) {$/;"	f
prune_acl_cond	src/acl.c	/^struct acl_cond *prune_acl_cond(struct acl_cond *cond)$/;"	f
prune_acl_expr	src/acl.c	/^static struct acl_expr *prune_acl_expr(struct acl_expr *expr)$/;"	f	file:
apools	src/appsession.c	/^struct app_pool apools;$/;"	v	typeref:struct:app_pool
appsess_refresh	src/appsession.c	/^static struct task *appsess_refresh = NULL;$/;"	v	typeref:struct:task	file:
appsession_cleanup	src/appsession.c	/^void appsession_cleanup( void )$/;"	f
appsession_init	src/appsession.c	/^int appsession_init(void)$/;"	f
appsession_refresh	src/appsession.c	/^static struct task *appsession_refresh(struct task *t)$/;"	f	file:
appsession_task_init	src/appsession.c	/^int appsession_task_init(void)$/;"	f
destroy	src/appsession.c	/^void destroy(appsess *temp1) {$/;"	f
have_appsession	src/appsession.c	/^int have_appsession;$/;"	v
match_str	src/appsession.c	/^int match_str(const void *key1, const void *key2)$/;"	f
pool2_appsess	src/appsession.c	/^struct pool_head *pool2_appsess;$/;"	v	typeref:struct:pool_head
arg_type_names	src/arg.c	/^static const char *arg_type_names[ARGT_NBTYPES] = {$/;"	v	file:
make_arg_list	src/arg.c	/^int make_arg_list(const char *in, int len, unsigned int mask, struct arg **argp,$/;"	f
_GNU_SOURCE	src/auth.c	15;"	d	file:
acl_match_auth	src/auth.c	/^acl_match_auth(struct sample *smp, struct acl_pattern *pattern)$/;"	f
auth_find_userlist	src/auth.c	/^auth_find_userlist(char *name)$/;"	f
auth_resolve_groups	src/auth.c	/^auth_resolve_groups(struct userlist *l, char *groups)$/;"	f
check_user	src/auth.c	/^check_user(struct userlist *ul, unsigned int group_mask, const char *user, const char *pass)$/;"	f
userlist	src/auth.c	/^struct userlist *userlist = NULL;    \/* list of all existing userlists *\/$/;"	v	typeref:struct:userlist
userlist_free	src/auth.c	/^userlist_free(struct userlist *ul)$/;"	f
__backend_init	src/backend.c	/^static void __backend_init(void)$/;"	f	file:
acl_fetch_avg_queue_size	src/backend.c	/^acl_fetch_avg_queue_size(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_be_conn	src/backend.c	/^acl_fetch_be_conn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_be_id	src/backend.c	/^acl_fetch_be_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_be_sess_rate	src/backend.c	/^acl_fetch_be_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_connslots	src/backend.c	/^acl_fetch_connslots(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_nbsrv	src/backend.c	/^acl_fetch_nbsrv(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_queue_size	src/backend.c	/^acl_fetch_queue_size(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_srv_conn	src/backend.c	/^acl_fetch_srv_conn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_srv_id	src/backend.c	/^acl_fetch_srv_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_srv_is_up	src/backend.c	/^acl_fetch_srv_is_up(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_kws	src/backend.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
assign_server	src/backend.c	/^int assign_server(struct session *s)$/;"	f
assign_server_address	src/backend.c	/^int assign_server_address(struct session *s)$/;"	f
assign_server_and_queue	src/backend.c	/^int assign_server_and_queue(struct session *s)$/;"	f
assign_tproxy_address	src/backend.c	/^static void assign_tproxy_address(struct session *s)$/;"	f	file:
backend_lb_algo_str	src/backend.c	/^const char *backend_lb_algo_str(int algo) {$/;"	f
backend_parse_balance	src/backend.c	/^int backend_parse_balance(const char **args, char **err, struct proxy *curproxy)$/;"	f
be_downtime	src/backend.c	/^int be_downtime(struct proxy *px) {$/;"	f
connect_server	src/backend.c	/^int connect_server(struct session *s)$/;"	f
get_server_hh	src/backend.c	/^struct server *get_server_hh(struct session *s)$/;"	f
get_server_ph	src/backend.c	/^struct server *get_server_ph(struct proxy *px, const char *uri, int uri_len)$/;"	f
get_server_ph_post	src/backend.c	/^struct server *get_server_ph_post(struct session *s)$/;"	f
get_server_rch	src/backend.c	/^struct server *get_server_rch(struct session *s)$/;"	f
get_server_sh	src/backend.c	/^struct server *get_server_sh(struct proxy *px, const char *addr, int len)$/;"	f
get_server_uh	src/backend.c	/^struct server *get_server_uh(struct proxy *px, char *uri, int uri_len)$/;"	f
recount_servers	src/backend.c	/^void recount_servers(struct proxy *px)$/;"	f
srv_redispatch_connect	src/backend.c	/^int srv_redispatch_connect(struct session *t)$/;"	f
tcp_persist_rdp_cookie	src/backend.c	/^int tcp_persist_rdp_cookie(struct session *s, struct buffer *req, int an_bit)$/;"	f
update_backend_weight	src/backend.c	/^void update_backend_weight(struct proxy *px)$/;"	f
B64BASE	src/base64.c	20;"	d	file:
B64CMAX	src/base64.c	22;"	d	file:
B64CMIN	src/base64.c	21;"	d	file:
B64PADV	src/base64.c	23;"	d	file:
a2base64	src/base64.c	/^int a2base64(char *in, int ilen, char *out, int olen)$/;"	f
b64tos30	src/base64.c	/^int b64tos30(const char *in)$/;"	f
base64dec	src/base64.c	/^int base64dec(const char *in, size_t ilen, char *out, size_t olen) {$/;"	f
base64rev	src/base64.c	/^const char base64rev[]="b###cXYZ[\\\\]^_`a###d###$%&'()*+,-.\/0123456789:;<=######>?@ABCDEFGHIJKLMNOPQRSTUVW";$/;"	v
base64tab	src/base64.c	/^const char base64tab[65]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v
s30tob64	src/base64.c	/^const char *s30tob64(int in, char *out)$/;"	f
bi_putblk	src/buffers.c	/^int bi_putblk(struct buffer *buf, const char *blk, int len)$/;"	f
bi_putchr	src/buffers.c	/^int bi_putchr(struct buffer *buf, char c)$/;"	f
bo_getblk	src/buffers.c	/^int bo_getblk(struct buffer *buf, char *blk, int len, int offset)$/;"	f
bo_getline	src/buffers.c	/^int bo_getline(struct buffer *buf, char *str, int len)$/;"	f
bo_inject	src/buffers.c	/^int bo_inject(struct buffer *buf, const char *msg, int len)$/;"	f
buffer_bounce_realign	src/buffers.c	/^void buffer_bounce_realign(struct buffer *buf)$/;"	f
buffer_dump	src/buffers.c	/^void buffer_dump(FILE *o, struct buffer *b, int from, int to)$/;"	f
buffer_forward	src/buffers.c	/^unsigned long long buffer_forward(struct buffer *buf, unsigned long long bytes)$/;"	f
buffer_insert_line2	src/buffers.c	/^int buffer_insert_line2(struct buffer *b, char *pos, const char *str, int len)$/;"	f
buffer_replace2	src/buffers.c	/^int buffer_replace2(struct buffer *b, char *pos, char *end, const char *str, int len)$/;"	f
buffer_slow_realign	src/buffers.c	/^void buffer_slow_realign(struct buffer *buf)$/;"	f
chunk_asciiencode	src/buffers.c	/^int chunk_asciiencode(struct chunk *dst, struct chunk *src, char qc) {$/;"	f
chunk_htmlencode	src/buffers.c	/^int chunk_htmlencode(struct chunk *dst, struct chunk *src) {$/;"	f
chunk_printf	src/buffers.c	/^int chunk_printf(struct chunk *chk, const char *fmt, ...)$/;"	f
init_buffer	src/buffers.c	/^int init_buffer()$/;"	f
pool2_buffer	src/buffers.c	/^struct pool_head *pool2_buffer;$/;"	v	typeref:struct:pool_head
cache	src/cache.c	/^struct cache    *cache;$/;"	v	typeref:struct:cache
hash	src/cache.c	/^hash_t          *hash;$/;"	v
hash_key	src/cache.c	/^hash_key_t      *hash_key;$/;"	v
init_cache_file	src/cache.c	/^void init_cache_file()$/;"	f
process_cache	src/cache.c	/^int process_cache(struct session *s)$/;"	f
process_cache_file	src/cache.c	/^int process_cache_file(struct session *s)$/;"	f
process_cache_mem	src/cache.c	/^int process_cache_mem(struct session *s)$/;"	f
read_a_file	src/cache.c	/^void read_a_file(hash_key_t *name)$/;"	f
read_files	src/cache.c	/^void read_files(hash_key_t *names, int nelts)$/;"	f
KWM_DEF	src/cfgparse.c	/^	KWM_DEF,      \/* "default" prefixed before the keyword *\/$/;"	e	enum:kw_mod	file:
KWM_NO	src/cfgparse.c	/^	KWM_NO,       \/* "no" prefixed before the keyword *\/$/;"	e	enum:kw_mod	file:
KWM_STD	src/cfgparse.c	/^	KWM_STD = 0,  \/* normal *\/$/;"	e	enum:kw_mod	file:
cap	src/cfgparse.c	/^	unsigned int cap;$/;"	m	struct:cfg_opt	file:
cfg_keywords	src/cfgparse.c	/^static struct cfg_kw_list cfg_keywords = {$/;"	v	typeref:struct:cfg_kw_list	file:
cfg_maxconn	src/cfgparse.c	/^int cfg_maxconn = 0;			\/* # of simultaneous connections, (-n) *\/$/;"	v
cfg_maxpconn	src/cfgparse.c	/^int cfg_maxpconn = DEFAULT_MAXCONN;	\/* # of simultaneous connections per proxy (-N) *\/$/;"	v
cfg_opt	src/cfgparse.c	/^struct cfg_opt {$/;"	s	file:
cfg_opts	src/cfgparse.c	/^static const struct cfg_opt cfg_opts[] =$/;"	v	typeref:struct:cfg_opt	file:
cfg_opts2	src/cfgparse.c	/^static const struct cfg_opt cfg_opts2[] =$/;"	v	typeref:struct:cfg_opt	file:
cfg_parse_global	src/cfgparse.c	/^int cfg_parse_global(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_listen	src/cfgparse.c	/^int cfg_parse_listen(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_peers	src/cfgparse.c	/^int cfg_parse_peers(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_parse_users	src/cfgparse.c	/^cfg_parse_users(const char *file, int linenum, char **args, int kwm)$/;"	f
cfg_register_keywords	src/cfgparse.c	/^void cfg_register_keywords(struct cfg_kw_list *kwl)$/;"	f
cfg_unregister_keywords	src/cfgparse.c	/^void cfg_unregister_keywords(struct cfg_kw_list *kwl)$/;"	f
check_config_validity	src/cfgparse.c	/^int check_config_validity()$/;"	f
checks	src/cfgparse.c	/^	unsigned int checks;$/;"	m	struct:cfg_opt	file:
create_cond_regex_rule	src/cfgparse.c	/^static int create_cond_regex_rule(const char *file, int line,$/;"	f	file:
cursection	src/cfgparse.c	/^static char *cursection = NULL;$/;"	v	file:
defproxy	src/cfgparse.c	/^static struct proxy defproxy;		\/* fake proxy used to assign default values on all instances *\/$/;"	v	typeref:struct:proxy	file:
init_default_instance	src/cfgparse.c	/^void init_default_instance()$/;"	f
kw_mod	src/cfgparse.c	/^enum kw_mod {$/;"	g	file:
mode	src/cfgparse.c	/^	unsigned int mode;$/;"	m	struct:cfg_opt	file:
name	src/cfgparse.c	/^	const char *name;$/;"	m	struct:cfg_opt	file:
readcfgfile	src/cfgparse.c	/^int readcfgfile(const char *file)$/;"	f
sslv3_client_hello_pkt	src/cfgparse.c	/^const char sslv3_client_hello_pkt[] = {$/;"	v
str2listener	src/cfgparse.c	/^static int str2listener(char *str, struct proxy *curproxy, const char *file, int line)$/;"	f	file:
val	src/cfgparse.c	/^	unsigned int val;$/;"	m	struct:cfg_opt	file:
warnif_cond_requires_req	src/cfgparse.c	/^static int warnif_cond_requires_req(const struct acl_cond *cond, const char *file, int line)$/;"	f	file:
warnif_cond_requires_resp	src/cfgparse.c	/^static int warnif_cond_requires_resp(const struct acl_cond *cond, const char *file, int line)$/;"	f	file:
warnif_misplaced_block	src/cfgparse.c	/^int warnif_misplaced_block(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_reqadd	src/cfgparse.c	/^int warnif_misplaced_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_misplaced_reqxxx	src/cfgparse.c	/^int warnif_misplaced_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_block	src/cfgparse.c	/^int warnif_rule_after_block(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_redirect	src/cfgparse.c	/^int warnif_rule_after_redirect(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_reqadd	src/cfgparse.c	/^int warnif_rule_after_reqadd(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_reqxxx	src/cfgparse.c	/^int warnif_rule_after_reqxxx(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnif_rule_after_use_backend	src/cfgparse.c	/^int warnif_rule_after_use_backend(struct proxy *proxy, const char *file, int line, const char *arg)$/;"	f
warnifnotcap	src/cfgparse.c	/^int warnifnotcap(struct proxy *proxy, int cap, const char *file, int line, const char *arg, const char *hint)$/;"	f
SSP_O_HCHK	src/checks.c	149;"	d	file:
analyze_statuses	src/checks.c	/^static const struct analyze_status analyze_statuses[HANA_STATUS_SIZE] = {		\/* 0: ignore, 1: error, 2: OK *\/$/;"	v	typeref:struct:analyze_status	file:
check_for_pending	src/checks.c	/^static int check_for_pending(struct server *s)$/;"	f	file:
check_statuses	src/checks.c	/^static const struct check_status check_statuses[HCHK_STATUS_SIZE] = {$/;"	v	typeref:struct:check_status	file:
event_srv_chk_r	src/checks.c	/^static int event_srv_chk_r(int fd)$/;"	f	file:
event_srv_chk_w	src/checks.c	/^static int event_srv_chk_w(int fd)$/;"	f	file:
get_analyze_status	src/checks.c	/^const char *get_analyze_status(short analyze_status) {$/;"	f
get_check_status_description	src/checks.c	/^const char *get_check_status_description(short check_status) {$/;"	f
get_check_status_info	src/checks.c	/^const char *get_check_status_info(short check_status) {$/;"	f
health_adjust	src/checks.c	/^void health_adjust(struct server *s, short status) {$/;"	f
httpchk_build_status_header	src/checks.c	/^static int httpchk_build_status_header(struct server *s, char *buffer)$/;"	f	file:
httpchk_expect	src/checks.c	/^static int httpchk_expect(struct server *s, int done)$/;"	f	file:
process_chk	src/checks.c	/^static struct task *process_chk(struct task *t)$/;"	f	file:
redistribute_pending	src/checks.c	/^static int redistribute_pending(struct server *s)$/;"	f	file:
server_status_printf	src/checks.c	/^static void server_status_printf(struct chunk *msg, struct server *s, unsigned options, int xferred) {$/;"	f	file:
server_warmup	src/checks.c	/^static struct task *server_warmup(struct task *t)$/;"	f	file:
set_backend_down	src/checks.c	/^static void set_backend_down(struct proxy *be)$/;"	f	file:
set_server_check_status	src/checks.c	/^static void set_server_check_status(struct server *s, short status, char *desc) {$/;"	f	file:
set_server_disabled	src/checks.c	/^static void set_server_disabled(struct server *s) {$/;"	f	file:
set_server_down	src/checks.c	/^void set_server_down(struct server *s)$/;"	f
set_server_enabled	src/checks.c	/^static void set_server_enabled(struct server *s) {$/;"	f	file:
set_server_up	src/checks.c	/^void set_server_up(struct server *s) {$/;"	f
shutdown_backup_sessions	src/checks.c	/^static void shutdown_backup_sessions(struct proxy *px, int why)$/;"	f	file:
shutdown_sessions	src/checks.c	/^static void shutdown_sessions(struct server *srv, int why)$/;"	f	file:
start_checks	src/checks.c	/^int start_checks() {$/;"	f
check_cttproxy_version	src/cttproxy.c	/^int check_cttproxy_version() {$/;"	f
STAT_PX_ST_BE	src/dumpstats.c	/^	STAT_PX_ST_BE,$/;"	e	enum:__anon104	file:
STAT_PX_ST_END	src/dumpstats.c	/^	STAT_PX_ST_END,$/;"	e	enum:__anon104	file:
STAT_PX_ST_FE	src/dumpstats.c	/^	STAT_PX_ST_FE,$/;"	e	enum:__anon104	file:
STAT_PX_ST_FIN	src/dumpstats.c	/^	STAT_PX_ST_FIN,$/;"	e	enum:__anon104	file:
STAT_PX_ST_INIT	src/dumpstats.c	/^	STAT_PX_ST_INIT = 0,$/;"	e	enum:__anon104	file:
STAT_PX_ST_LI	src/dumpstats.c	/^	STAT_PX_ST_LI,$/;"	e	enum:__anon104	file:
STAT_PX_ST_SV	src/dumpstats.c	/^	STAT_PX_ST_SV,$/;"	e	enum:__anon104	file:
STAT_PX_ST_TH	src/dumpstats.c	/^	STAT_PX_ST_TH,$/;"	e	enum:__anon104	file:
STAT_ST_END	src/dumpstats.c	/^	STAT_ST_END,$/;"	e	enum:__anon103	file:
STAT_ST_FIN	src/dumpstats.c	/^	STAT_ST_FIN,$/;"	e	enum:__anon103	file:
STAT_ST_HEAD	src/dumpstats.c	/^	STAT_ST_HEAD,$/;"	e	enum:__anon103	file:
STAT_ST_INFO	src/dumpstats.c	/^	STAT_ST_INFO,$/;"	e	enum:__anon103	file:
STAT_ST_INIT	src/dumpstats.c	/^	STAT_ST_INIT = 0,$/;"	e	enum:__anon103	file:
STAT_ST_LIST	src/dumpstats.c	/^	STAT_ST_LIST,$/;"	e	enum:__anon103	file:
__dumpstats_module_init	src/dumpstats.c	/^static void __dumpstats_module_init(void)$/;"	f	file:
alloc_stats_fe	src/dumpstats.c	/^static struct proxy *alloc_stats_fe(const char *name)$/;"	f	file:
cfg_kws	src/dumpstats.c	/^static struct cfg_kw_list cfg_kws = {{ },{$/;"	v	typeref:struct:cfg_kw_list	file:
cli_applet	src/dumpstats.c	/^static struct si_applet cli_applet = {$/;"	v	typeref:struct:si_applet	file:
cli_applet	src/dumpstats.c	/^static struct si_applet cli_applet;$/;"	v	typeref:struct:si_applet	file:
cli_io_handler	src/dumpstats.c	/^static void cli_io_handler(struct stream_interface *si)$/;"	f	file:
dump_binary	src/dumpstats.c	/^static int dump_binary(struct chunk *out, const char *buf, int bsize)$/;"	f	file:
dump_text	src/dumpstats.c	/^static int dump_text(struct chunk *out, const char *buf, int bsize)$/;"	f	file:
dump_text_line	src/dumpstats.c	/^static int dump_text_line(struct chunk *out, const char *buf, int bsize, int len,$/;"	f	file:
expect_frontend_admin	src/dumpstats.c	/^static struct proxy *expect_frontend_admin(struct session *s, struct stream_interface *si, const char *arg)$/;"	f	file:
expect_server_admin	src/dumpstats.c	/^static struct server *expect_server_admin(struct session *s, struct stream_interface *si, char *arg)$/;"	f	file:
http_stats_applet	src/dumpstats.c	/^struct si_applet http_stats_applet = {$/;"	v	typeref:struct:si_applet
http_stats_io_handler	src/dumpstats.c	/^static void http_stats_io_handler(struct stream_interface *si)$/;"	f	file:
print_csv_header	src/dumpstats.c	/^static int print_csv_header(struct chunk *msg)$/;"	f	file:
stats_accept	src/dumpstats.c	/^static int stats_accept(struct session *s)$/;"	f	file:
stats_dump_errors_to_buffer	src/dumpstats.c	/^static int stats_dump_errors_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_full_sess_to_buffer	src/dumpstats.c	/^static int stats_dump_full_sess_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_http	src/dumpstats.c	/^static int stats_dump_http(struct stream_interface *si, struct uri_auth *uri)$/;"	f	file:
stats_dump_proxy	src/dumpstats.c	/^static int stats_dump_proxy(struct stream_interface *si, struct proxy *px, struct uri_auth *uri)$/;"	f	file:
stats_dump_raw_to_buffer	src/dumpstats.c	/^static int stats_dump_raw_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_sess_to_buffer	src/dumpstats.c	/^static int stats_dump_sess_to_buffer(struct stream_interface *si)$/;"	f	file:
stats_dump_table_entry_to_buffer	src/dumpstats.c	/^static int stats_dump_table_entry_to_buffer(struct chunk *msg, struct stream_interface *si,$/;"	f	file:
stats_dump_table_head_to_buffer	src/dumpstats.c	/^static int stats_dump_table_head_to_buffer(struct chunk *msg, struct stream_interface *si,$/;"	f	file:
stats_http_redir	src/dumpstats.c	/^static int stats_http_redir(struct stream_interface *si, struct uri_auth *uri)$/;"	f	file:
stats_parse_global	src/dumpstats.c	/^static int stats_parse_global(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
stats_permission_denied_msg	src/dumpstats.c	/^static const char stats_permission_denied_msg[] =$/;"	v	file:
stats_sock_parse_request	src/dumpstats.c	/^static int stats_sock_parse_request(struct stream_interface *si, char *line)$/;"	f	file:
stats_sock_table_data_request	src/dumpstats.c	/^static void stats_sock_table_data_request(struct stream_interface *si, char **args)$/;"	f	file:
stats_sock_table_key_request	src/dumpstats.c	/^static void stats_sock_table_key_request(struct stream_interface *si, char **args, bool show)$/;"	f	file:
stats_sock_table_request	src/dumpstats.c	/^static void stats_sock_table_request(struct stream_interface *si, char **args, bool show)$/;"	f	file:
stats_sock_usage_msg	src/dumpstats.c	/^static const char stats_sock_usage_msg[] =$/;"	v	file:
stats_table_request	src/dumpstats.c	/^static int stats_table_request(struct stream_interface *si, bool show)$/;"	f	file:
DIR2MSK	src/ev_epoll.c	64;"	d	file:
FD2BIT	src/ev_epoll.c	68;"	d	file:
FD2MSK	src/ev_epoll.c	69;"	d	file:
FD2OFS	src/ev_epoll.c	67;"	d	file:
__fd_clo	src/ev_epoll.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:
__fd_clr	src/ev_epoll.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:
__fd_is_set	src/ev_epoll.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:
__fd_rem	src/ev_epoll.c	/^REGPRM1 static void __fd_rem(int fd)$/;"	f	file:
__fd_set	src/ev_epoll.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:
_do_fork	src/ev_epoll.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:
_do_init	src/ev_epoll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_poll	src/ev_epoll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_register	src/ev_epoll.c	/^static void _do_register(void)$/;"	f	file:
_do_term	src/ev_epoll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_test	src/ev_epoll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
alloc_chg_list	src/ev_epoll.c	/^REGPRM2 static void alloc_chg_list(const int fd, int old_evt)$/;"	f	file:
chg_list	src/ev_epoll.c	/^static struct fd_chg *chg_list = NULL;	\/\/ list of changes$/;"	v	typeref:struct:fd_chg	file:
chg_ptr	src/ev_epoll.c	/^static struct fd_chg **chg_ptr = NULL;	\/\/ per-fd changes$/;"	v	typeref:struct:fd_chg	file:
dmsk2event	src/ev_epoll.c	/^static int dmsk2event[4] = { 0, EPOLLIN, EPOLLOUT, EPOLLIN | EPOLLOUT };$/;"	v	file:
epoll_events	src/ev_epoll.c	/^static struct epoll_event *epoll_events;$/;"	v	typeref:struct:epoll_event	file:
epoll_fd	src/ev_epoll.c	/^static int epoll_fd;$/;"	v	file:
ev	src/ev_epoll.c	/^static struct epoll_event ev;$/;"	v	typeref:struct:epoll_event	file:
fd	src/ev_epoll.c	/^	unsigned int fd:30;	\/\/ file descriptor$/;"	m	struct:fd_chg	file:
fd_chg	src/ev_epoll.c	/^struct fd_chg {$/;"	s	file:
fd_evts	src/ev_epoll.c	/^static uint32_t *fd_evts;$/;"	v	file:
fd_flush_changes	src/ev_epoll.c	/^REGPRM2 static void fd_flush_changes()$/;"	f	file:
nbchanges	src/ev_epoll.c	/^static int nbchanges = 0;		\/\/ number of changes pending$/;"	v	file:
prev	src/ev_epoll.c	/^	unsigned int prev:2;	\/\/ previous state mask. New one is in fd_evts.$/;"	m	struct:fd_chg	file:
__fd_clo	src/ev_kqueue.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:
__fd_clr	src/ev_kqueue.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:
__fd_is_set	src/ev_kqueue.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:
__fd_rem	src/ev_kqueue.c	/^REGPRM1 static void __fd_rem(int fd)$/;"	f	file:
__fd_set	src/ev_kqueue.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:
_do_fork	src/ev_kqueue.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:
_do_init	src/ev_kqueue.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_poll	src/ev_kqueue.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_register	src/ev_kqueue.c	/^static void _do_register(void)$/;"	f	file:
_do_term	src/ev_kqueue.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_test	src/ev_kqueue.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
dir2filt	src/ev_kqueue.c	/^static const int dir2filt[2] = { EVFILT_READ, EVFILT_WRITE };$/;"	v	file:
fd_evts	src/ev_kqueue.c	/^static fd_set *fd_evts[2];$/;"	v	file:
kev	src/ev_kqueue.c	/^static struct kevent *kev = NULL;$/;"	v	typeref:struct:kevent	file:
kqev_del	src/ev_kqueue.c	/^REGPRM3 static int kqev_del(struct kevent *kev, const int fd, const int dir)$/;"	f	file:
kqueue_fd	src/ev_kqueue.c	/^static int kqueue_fd;$/;"	v	file:
FDSETS_ARE_INT_ALIGNED	src/ev_poll.c	103;"	d	file:
WE_REALLY_KNOW_THAT_FDSETS_ARE_INTS	src/ev_poll.c	106;"	d	file:
__fd_clr	src/ev_poll.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:
__fd_cond_c	src/ev_poll.c	/^REGPRM2 static int __fd_cond_c(const int fd, int dir)$/;"	f	file:
__fd_cond_s	src/ev_poll.c	/^REGPRM2 static int __fd_cond_s(const int fd, int dir)$/;"	f	file:
__fd_is_set	src/ev_poll.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:
__fd_rem	src/ev_poll.c	/^REGPRM1 static void __fd_rem(const int fd)$/;"	f	file:
__fd_set	src/ev_poll.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:
_do_init	src/ev_poll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_poll	src/ev_poll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_register	src/ev_poll.c	/^static void _do_register(void)$/;"	f	file:
_do_term	src/ev_poll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_test	src/ev_poll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
fd_evts	src/ev_poll.c	/^static fd_set *fd_evts[2];$/;"	v	file:
poll_events	src/ev_poll.c	/^static struct pollfd *poll_events = NULL;$/;"	v	typeref:struct:pollfd	file:
__fd_clr	src/ev_select.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:
__fd_cond_c	src/ev_select.c	/^REGPRM2 static int __fd_cond_c(const int fd, int dir)$/;"	f	file:
__fd_cond_s	src/ev_select.c	/^REGPRM2 static int __fd_cond_s(const int fd, int dir)$/;"	f	file:
__fd_is_set	src/ev_select.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:
__fd_rem	src/ev_select.c	/^REGPRM1 static void __fd_rem(int fd)$/;"	f	file:
__fd_set	src/ev_select.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:
_do_init	src/ev_select.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_poll	src/ev_select.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_register	src/ev_select.c	/^static void _do_register(void)$/;"	f	file:
_do_term	src/ev_select.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_test	src/ev_select.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
fd_evts	src/ev_select.c	/^static fd_set *fd_evts[2];$/;"	v	file:
tmp_evts	src/ev_select.c	/^static fd_set *tmp_evts[2];$/;"	v	file:
FD_EV_IDLE	src/ev_sepoll.c	117;"	d	file:
FD_EV_IDLE_R	src/ev_sepoll.c	127;"	d	file:
FD_EV_IDLE_W	src/ev_sepoll.c	133;"	d	file:
FD_EV_IN_PL	src/ev_sepoll.c	115;"	d	file:
FD_EV_IN_SL	src/ev_sepoll.c	114;"	d	file:
FD_EV_MASK	src/ev_sepoll.c	139;"	d	file:
FD_EV_MASK_DIR	src/ev_sepoll.c	125;"	d	file:
FD_EV_MASK_OLD	src/ev_sepoll.c	140;"	d	file:
FD_EV_MASK_R	src/ev_sepoll.c	131;"	d	file:
FD_EV_MASK_W	src/ev_sepoll.c	137;"	d	file:
FD_EV_RW_PL	src/ev_sepoll.c	124;"	d	file:
FD_EV_RW_SL	src/ev_sepoll.c	123;"	d	file:
FD_EV_SPEC	src/ev_sepoll.c	118;"	d	file:
FD_EV_SPEC_R	src/ev_sepoll.c	128;"	d	file:
FD_EV_SPEC_W	src/ev_sepoll.c	134;"	d	file:
FD_EV_STOP	src/ev_sepoll.c	120;"	d	file:
FD_EV_STOP_R	src/ev_sepoll.c	130;"	d	file:
FD_EV_STOP_W	src/ev_sepoll.c	136;"	d	file:
FD_EV_WAIT	src/ev_sepoll.c	119;"	d	file:
FD_EV_WAIT_R	src/ev_sepoll.c	129;"	d	file:
FD_EV_WAIT_W	src/ev_sepoll.c	135;"	d	file:
MIN_RETURN_EVENTS	src/ev_sepoll.c	145;"	d	file:
__fd_clo	src/ev_sepoll.c	/^REGPRM1 static void __fd_clo(int fd)$/;"	f	file:
__fd_clr	src/ev_sepoll.c	/^REGPRM2 static int __fd_clr(const int fd, int dir)$/;"	f	file:
__fd_is_set	src/ev_sepoll.c	/^REGPRM2 static int __fd_is_set(const int fd, int dir)$/;"	f	file:
__fd_rem	src/ev_sepoll.c	/^REGPRM1 static void __fd_rem(int fd)$/;"	f	file:
__fd_set	src/ev_sepoll.c	/^REGPRM2 static int __fd_set(const int fd, int dir)$/;"	f	file:
_do_fork	src/ev_sepoll.c	/^REGPRM1 static int _do_fork(struct poller *p)$/;"	f	file:
_do_init	src/ev_sepoll.c	/^REGPRM1 static int _do_init(struct poller *p)$/;"	f	file:
_do_poll	src/ev_sepoll.c	/^REGPRM2 static void _do_poll(struct poller *p, int exp)$/;"	f	file:
_do_register	src/ev_sepoll.c	/^static void _do_register(void)$/;"	f	file:
_do_term	src/ev_sepoll.c	/^REGPRM1 static void _do_term(struct poller *p)$/;"	f	file:
_do_test	src/ev_sepoll.c	/^REGPRM1 static int _do_test(struct poller *p)$/;"	f	file:
absmaxevents	src/ev_sepoll.c	/^static int absmaxevents = 0;    \/\/ absolute maximum amounts of polled events$/;"	v	file:
alloc_spec_entry	src/ev_sepoll.c	/^REGPRM1 static inline void alloc_spec_entry(const int fd)$/;"	f	file:
epoll_events	src/ev_sepoll.c	/^static struct epoll_event *epoll_events;$/;"	v	typeref:struct:epoll_event	file:
epoll_fd	src/ev_sepoll.c	/^static int epoll_fd;$/;"	v	file:
ev	src/ev_sepoll.c	/^static struct epoll_event ev;$/;"	v	typeref:struct:epoll_event	file:
nbspec	src/ev_sepoll.c	/^static int nbspec = 0;          \/\/ current size of the spec list$/;"	v	file:
release_spec_entry	src/ev_sepoll.c	/^REGPRM1 static void release_spec_entry(int fd)$/;"	f	file:
spec_list	src/ev_sepoll.c	/^static unsigned int *spec_list = NULL;	\/\/ speculative I\/O list$/;"	v	file:
actconn	src/fd.c	/^int actconn;                    \/* # of active sessions *\/$/;"	v
cur_poller	src/fd.c	/^struct poller cur_poller;$/;"	v	typeref:struct:poller
deinit_pollers	src/fd.c	/^void deinit_pollers() {$/;"	f
disable_poller	src/fd.c	/^void disable_poller(const char *poller_name)$/;"	f
fd_delete	src/fd.c	/^void fd_delete(int fd)$/;"	f
fdinfo	src/fd.c	/^struct fdinfo *fdinfo = NULL;   \/* less-often used infos for file descriptors *\/$/;"	v	typeref:struct:fdinfo
fdtab	src/fd.c	/^struct fdtab *fdtab = NULL;     \/* array of all the file descriptors *\/$/;"	v	typeref:struct:fdtab
fork_poller	src/fd.c	/^int fork_poller()$/;"	f
init_pollers	src/fd.c	/^int init_pollers()$/;"	f
list_pollers	src/fd.c	/^int list_pollers(FILE *out)$/;"	f
maxfd	src/fd.c	/^int maxfd;                      \/* # of the highest fd + 1 *\/$/;"	v
nbpollers	src/fd.c	/^int nbpollers = 0;$/;"	v
pollers	src/fd.c	/^struct poller pollers[MAX_POLLERS];$/;"	v	typeref:struct:poller
totalconn	src/fd.c	/^int totalconn;                  \/* total # of terminated sessions *\/$/;"	v
freq_ctr_remain	src/freq_ctr.c	/^unsigned int freq_ctr_remain(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)$/;"	f
freq_ctr_remain_period	src/freq_ctr.c	/^unsigned int freq_ctr_remain_period(struct freq_ctr_period *ctr, unsigned int period,$/;"	f
next_event_delay	src/freq_ctr.c	/^unsigned int next_event_delay(struct freq_ctr *ctr, unsigned int freq, unsigned int pend)$/;"	f
read_freq_ctr	src/freq_ctr.c	/^unsigned int read_freq_ctr(struct freq_ctr *ctr)$/;"	f
read_freq_ctr_period	src/freq_ctr.c	/^unsigned int read_freq_ctr_period(struct freq_ctr_period *ctr, unsigned int period)$/;"	f
__frontend_init	src/frontend.c	/^static void __frontend_init(void)$/;"	f	file:
acl_fetch_fe_conn	src/frontend.c	/^acl_fetch_fe_conn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_fe_id	src/frontend.c	/^acl_fetch_fe_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_fe_sess_rate	src/frontend.c	/^acl_fetch_fe_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_kws	src/frontend.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
frontend_accept	src/frontend.c	/^int frontend_accept(struct session *s)$/;"	f
frontend_decode_proxy_request	src/frontend.c	/^int frontend_decode_proxy_request(struct session *s, struct buffer *req, int an_bit)$/;"	f
make_proxy_line	src/frontend.c	/^int make_proxy_line(char *buf, int buf_len, struct sockaddr_storage *src, struct sockaddr_storage *dst)$/;"	f
MAX_START_RETRIES	src/haproxy.c	141;"	d	file:
cfg_cfgfiles	src/haproxy.c	/^static struct list cfg_cfgfiles = LIST_HEAD_INIT(cfg_cfgfiles);$/;"	v	typeref:struct:list	file:
deinit	src/haproxy.c	/^void deinit(void)$/;"	f
deinit_acl_cond	src/haproxy.c	/^static void deinit_acl_cond(struct acl_cond *cond)$/;"	f	file:
deinit_sample_arg	src/haproxy.c	/^static void deinit_sample_arg(struct arg *p)$/;"	f	file:
deinit_stick_rules	src/haproxy.c	/^static void deinit_stick_rules(struct list *rules)$/;"	f	file:
deinit_tcp_rules	src/haproxy.c	/^static void deinit_tcp_rules(struct list *rules)$/;"	f	file:
display_build_opts	src/haproxy.c	/^void display_build_opts()$/;"	f
display_version	src/haproxy.c	/^void display_version()$/;"	f
dump	src/haproxy.c	/^void dump(struct sig_handler *sh)$/;"	f
global	src/haproxy.c	/^struct global global = {$/;"	v	typeref:struct:global
global_listener_queue	src/haproxy.c	/^struct list global_listener_queue = LIST_HEAD_INIT(global_listener_queue);$/;"	v	typeref:struct:list
global_listener_queue_task	src/haproxy.c	/^struct task *global_listener_queue_task;$/;"	v	typeref:struct:task
hostname	src/haproxy.c	/^char hostname[MAX_HOSTNAME_LEN];$/;"	v
init	src/haproxy.c	/^void init(int argc, char **argv)$/;"	f
jobs	src/haproxy.c	/^int jobs = 0;   \/* number of active jobs (conns, listeners, active tasks, ...) *\/$/;"	v
localpeer	src/haproxy.c	/^char localpeer[MAX_HOSTNAME_LEN];$/;"	v
main	src/haproxy.c	/^int main(int argc, char **argv)$/;"	f
manage_global_listener_queue	src/haproxy.c	/^static struct task *manage_global_listener_queue(struct task *t)$/;"	f	file:
nb_oldpids	src/haproxy.c	/^int nb_oldpids = 0;$/;"	v
nolinger	src/haproxy.c	/^const struct linger nolinger = { .l_onoff = 1, .l_linger = 0 };$/;"	v	typeref:struct:linger
oldpids	src/haproxy.c	/^static int *oldpids = NULL;$/;"	v	file:
oldpids_sig	src/haproxy.c	/^static int oldpids_sig; \/* use USR1 or TERM *\/$/;"	v	file:
one	src/haproxy.c	/^const int one = 1;$/;"	v
pid	src/haproxy.c	/^int  pid;			\/* current process id *\/$/;"	v
relative_pid	src/haproxy.c	/^int  relative_pid = 1;		\/* process id starting at 1 *\/$/;"	v
run_poll_loop	src/haproxy.c	/^void run_poll_loop()$/;"	f
sig_dump_state	src/haproxy.c	/^void sig_dump_state(struct sig_handler *sh)$/;"	f
sig_listen	src/haproxy.c	/^void sig_listen(struct sig_handler *sh)$/;"	f
sig_pause	src/haproxy.c	/^void sig_pause(struct sig_handler *sh)$/;"	f
sig_soft_stop	src/haproxy.c	/^void sig_soft_stop(struct sig_handler *sh)$/;"	f
stopping	src/haproxy.c	/^int stopping;	\/* non zero means stopping in progress *\/$/;"	v
swap_buffer	src/haproxy.c	/^char *swap_buffer = NULL;$/;"	v
tell_old_pids	src/haproxy.c	/^static int tell_old_pids(int sig)$/;"	f	file:
trash	src/haproxy.c	/^char *trash = NULL;$/;"	v
trashlen	src/haproxy.c	/^int trashlen = BUFSIZE;$/;"	v
usage	src/haproxy.c	/^void usage(char *name)$/;"	f
zero	src/haproxy.c	/^const int zero = 0;$/;"	v
hdr_idx_add	src/hdr_idx.c	/^int hdr_idx_add(int len, int cr, struct hdr_idx *list, int after)$/;"	f
pool2_hdr_idx	src/hdr_idx.c	/^struct pool_head *pool2_hdr_idx = NULL;$/;"	v	typeref:struct:pool_head
__i386_linux_vsyscall_init	src/i386-linux-vsys.c	/^static void __i386_linux_vsyscall_init(void)$/;"	f	file:
back_ebx	src/i386-linux-vsys.c	/^static __attribute__((used)) unsigned int back_ebx;$/;"	v	file:
vsyscall	src/i386-linux-vsys.c	/^static void *vsyscall = &int80;  \/* initialize vsyscall to use int80 by default *\/$/;"	v	file:
chash_dequeue_srv	src/lb_chash.c	/^static inline void chash_dequeue_srv(struct server *s)$/;"	f	file:
chash_get_next_server	src/lb_chash.c	/^struct server *chash_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
chash_get_server_hash	src/lb_chash.c	/^struct server *chash_get_server_hash(struct proxy *p, unsigned int hash)$/;"	f
chash_init_server_tree	src/lb_chash.c	/^void chash_init_server_tree(struct proxy *p)$/;"	f
chash_queue_dequeue_srv	src/lb_chash.c	/^static inline void chash_queue_dequeue_srv(struct server *s)$/;"	f	file:
chash_set_server_status_down	src/lb_chash.c	/^static void chash_set_server_status_down(struct server *srv)$/;"	f	file:
chash_set_server_status_up	src/lb_chash.c	/^static void chash_set_server_status_up(struct server *srv)$/;"	f	file:
chash_skip_node	src/lb_chash.c	/^static inline struct eb32_node *chash_skip_node(struct eb_root *root, struct eb32_node *node)$/;"	f	file:
chash_update_server_weight	src/lb_chash.c	/^static void chash_update_server_weight(struct server *srv)$/;"	f	file:
fas_dequeue_srv	src/lb_fas.c	/^static inline void fas_dequeue_srv(struct server *s)$/;"	f	file:
fas_get_next_server	src/lb_fas.c	/^struct server *fas_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
fas_init_server_tree	src/lb_fas.c	/^void fas_init_server_tree(struct proxy *p)$/;"	f
fas_queue_srv	src/lb_fas.c	/^static inline void fas_queue_srv(struct server *s)$/;"	f	file:
fas_remove_from_tree	src/lb_fas.c	/^static inline void fas_remove_from_tree(struct server *s)$/;"	f	file:
fas_set_server_status_down	src/lb_fas.c	/^static void fas_set_server_status_down(struct server *srv)$/;"	f	file:
fas_set_server_status_up	src/lb_fas.c	/^static void fas_set_server_status_up(struct server *srv)$/;"	f	file:
fas_srv_reposition	src/lb_fas.c	/^static void fas_srv_reposition(struct server *s)$/;"	f	file:
fas_update_server_weight	src/lb_fas.c	/^static void fas_update_server_weight(struct server *srv)$/;"	f	file:
fwlc_dequeue_srv	src/lb_fwlc.c	/^static inline void fwlc_dequeue_srv(struct server *s)$/;"	f	file:
fwlc_get_next_server	src/lb_fwlc.c	/^struct server *fwlc_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
fwlc_init_server_tree	src/lb_fwlc.c	/^void fwlc_init_server_tree(struct proxy *p)$/;"	f
fwlc_queue_srv	src/lb_fwlc.c	/^static inline void fwlc_queue_srv(struct server *s)$/;"	f	file:
fwlc_remove_from_tree	src/lb_fwlc.c	/^static inline void fwlc_remove_from_tree(struct server *s)$/;"	f	file:
fwlc_set_server_status_down	src/lb_fwlc.c	/^static void fwlc_set_server_status_down(struct server *srv)$/;"	f	file:
fwlc_set_server_status_up	src/lb_fwlc.c	/^static void fwlc_set_server_status_up(struct server *srv)$/;"	f	file:
fwlc_srv_reposition	src/lb_fwlc.c	/^static void fwlc_srv_reposition(struct server *s)$/;"	f	file:
fwlc_update_server_weight	src/lb_fwlc.c	/^static void fwlc_update_server_weight(struct server *srv)$/;"	f	file:
fwrr_dequeue_srv	src/lb_fwrr.c	/^static inline void fwrr_dequeue_srv(struct server *s)$/;"	f	file:
fwrr_get_next_server	src/lb_fwrr.c	/^struct server *fwrr_get_next_server(struct proxy *p, struct server *srvtoavoid)$/;"	f
fwrr_get_server_from_group	src/lb_fwrr.c	/^static struct server *fwrr_get_server_from_group(struct fwrr_group *grp)$/;"	f	file:
fwrr_get_srv	src/lb_fwrr.c	/^static void fwrr_get_srv(struct server *s)$/;"	f	file:
fwrr_get_srv_down	src/lb_fwrr.c	/^static inline void fwrr_get_srv_down(struct server *s)$/;"	f	file:
fwrr_get_srv_init	src/lb_fwrr.c	/^static inline void fwrr_get_srv_init(struct server *s)$/;"	f	file:
fwrr_get_srv_next	src/lb_fwrr.c	/^static inline void fwrr_get_srv_next(struct server *s)$/;"	f	file:
fwrr_init_server_groups	src/lb_fwrr.c	/^void fwrr_init_server_groups(struct proxy *p)$/;"	f
fwrr_queue_by_weight	src/lb_fwrr.c	/^static inline void fwrr_queue_by_weight(struct eb_root *root, struct server *s)$/;"	f	file:
fwrr_queue_srv	src/lb_fwrr.c	/^static void fwrr_queue_srv(struct server *s)$/;"	f	file:
fwrr_remove_from_tree	src/lb_fwrr.c	/^static inline void fwrr_remove_from_tree(struct server *s)$/;"	f	file:
fwrr_set_server_status_down	src/lb_fwrr.c	/^static void fwrr_set_server_status_down(struct server *srv)$/;"	f	file:
fwrr_set_server_status_up	src/lb_fwrr.c	/^static void fwrr_set_server_status_up(struct server *srv)$/;"	f	file:
fwrr_switch_trees	src/lb_fwrr.c	/^static inline void fwrr_switch_trees(struct fwrr_group *grp)$/;"	f	file:
fwrr_update_position	src/lb_fwrr.c	/^static inline void fwrr_update_position(struct fwrr_group *grp, struct server *s)$/;"	f	file:
fwrr_update_server_weight	src/lb_fwrr.c	/^static void fwrr_update_server_weight(struct server *srv)$/;"	f	file:
init_server_map	src/lb_map.c	/^void init_server_map(struct proxy *p)$/;"	f
map_get_server_hash	src/lb_map.c	/^struct server *map_get_server_hash(struct proxy *px, unsigned int hash)$/;"	f
map_get_server_rr	src/lb_map.c	/^struct server *map_get_server_rr(struct proxy *px, struct server *srvtoavoid)$/;"	f
map_set_server_status_down	src/lb_map.c	/^static void map_set_server_status_down(struct server *srv)$/;"	f	file:
map_set_server_status_up	src/lb_map.c	/^static void map_set_server_status_up(struct server *srv)$/;"	f	file:
recalc_server_map	src/lb_map.c	/^void recalc_server_map(struct proxy *px)$/;"	f
Alert	src/log.c	/^void Alert(const char *fmt, ...)$/;"	f
LOGCHAR	src/log.c	765;"	d	file:
Warning	src/log.c	/^void Warning(const char *fmt, ...)$/;"	f
__send_log	src/log.c	/^void __send_log(struct proxy *p, int level, char *message, size_t size)$/;"	f
add_to_logformat_list	src/log.c	/^void add_to_logformat_list(char *start, char *end, int type, struct list *list_format)$/;"	f
build_logline	src/log.c	/^int build_logline(struct session *s, char *dst, size_t maxsize, struct list *list_format)$/;"	f
clf_http_log_format	src/log.c	/^char clf_http_log_format[] = "%{+Q}o %{-Q}Ci - - [%T] %r %st %B \\"\\" \\"\\" %Cp %ms %f %b %s %Tq %Tw %Tc %Tr %Tt %tsc %ac %fc %bc %sc %rc %sq %bq %cc %cs %hrl %hsl";$/;"	v
config_callback	src/log.c	/^	int (*config_callback)(struct logformat_node *node, struct proxy *curproxy);$/;"	m	struct:logformat_type	file:
default_http_log_format	src/log.c	/^char default_http_log_format[] = "%Ci:%Cp [%t] %f %b\/%s %Tq\/%Tw\/%Tc\/%Tr\/%Tt %st %B %cc %cs %tsc %ac\/%fc\/%bc\/%sc\/%rc %sq\/%bq %hr %hs %{+Q}r"; \/\/ default format$/;"	v
default_tcp_log_format	src/log.c	/^char default_tcp_log_format[] = "%Ci:%Cp [%t] %f %b\/%s %Tw\/%Tc\/%Tt %B %ts %ac\/%fc\/%bc\/%sc\/%rc %sq\/%bq";$/;"	v
get_log_facility	src/log.c	/^int get_log_facility(const char *fac)$/;"	f
get_log_level	src/log.c	/^int get_log_level(const char *lev)$/;"	f
lf_ip	src/log.c	/^char *lf_ip(char *dst, struct sockaddr *sockaddr, size_t size, struct logformat_node *node)$/;"	f
lf_port	src/log.c	/^char *lf_port(char *dst, struct sockaddr *sockaddr, size_t size, struct logformat_node *node)$/;"	f
lf_text	src/log.c	/^char *lf_text(char *dst, char *src, size_t size, struct logformat_node *node)$/;"	f
log_facilities	src/log.c	/^const char *log_facilities[NB_LOG_FACILITIES] = {$/;"	v
log_format	src/log.c	/^char *log_format = NULL;$/;"	v
log_levels	src/log.c	/^const char *log_levels[NB_LOG_LEVELS] = {$/;"	v
logformat_keywords	src/log.c	/^static const struct logformat_type logformat_keywords[] = {$/;"	v	typeref:struct:logformat_type	file:
logformat_type	src/log.c	/^struct logformat_type {$/;"	s	file:
logformat_var_args	src/log.c	/^struct logformat_var_args {$/;"	s	file:
logline	src/log.c	/^static char logline[MAX_SYSLOG_LEN];$/;"	v	file:
lw	src/log.c	/^	int lw; \/* logwait bitsfield *\/$/;"	m	struct:logformat_type	file:
mask	src/log.c	/^	int mask;$/;"	m	struct:logformat_var_args	file:
mode	src/log.c	/^	int mode;$/;"	m	struct:logformat_type	file:
name	src/log.c	/^	char *name;$/;"	m	struct:logformat_type	file:
name	src/log.c	/^	char *name;$/;"	m	struct:logformat_var_args	file:
parse_logformat_string	src/log.c	/^void parse_logformat_string(char *str, struct proxy *curproxy, struct list *list_format, int capabilities)$/;"	f
parse_logformat_var	src/log.c	/^int parse_logformat_var(char *str, size_t len, struct proxy *curproxy, struct list *list_format, int *defoptions)$/;"	f
parse_logformat_var_args	src/log.c	/^int parse_logformat_var_args(char *args, struct logformat_node *node)$/;"	f
prepare_addrsource	src/log.c	/^int prepare_addrsource(struct logformat_node *node, struct proxy *curproxy)$/;"	f
qfprintf	src/log.c	/^void qfprintf(FILE *out, const char *fmt, ...)$/;"	f
send_log	src/log.c	/^void send_log(struct proxy *p, int level, const char *format, ...)$/;"	f
sess_cookie	src/log.c	/^const char sess_cookie[8]     = "NIDVEOU7";	\/* No cookie, Invalid cookie, cookie for a Down server, Valid cookie, Expired cookie, Old cookie, Unused, unknown *\/$/;"	v
sess_fin_state	src/log.c	/^const char sess_fin_state[8]  = "-RCHDLQT";	\/* cliRequest, srvConnect, srvHeader, Data, Last, Queue, Tarpit *\/$/;"	v
sess_log	src/log.c	/^void sess_log(struct session *s)$/;"	f
sess_set_cookie	src/log.c	/^const char sess_set_cookie[8] = "NPDIRU67";	\/* No set-cookie, Set-cookie found and left unchanged (passive),$/;"	v
sess_term_cond	src/log.c	/^const char sess_term_cond[16] = "-cCsSPRIDKUIIIII"; \/* normal, CliTo, CliErr, SrvTo, SrvErr, PxErr, Resource, Internal, Down, Killed, Up, -- *\/$/;"	v
type	src/log.c	/^	int type;$/;"	m	struct:logformat_type	file:
update_log_hdr	src/log.c	/^static char *update_log_hdr()$/;"	f	file:
var_args_list	src/log.c	/^struct logformat_var_args var_args_list[] = {$/;"	v	typeref:struct:logformat_var_args
log_file	src/logging.c	/^static FILE *log_file = NULL;$/;"	v	file:
logging	src/logging.c	/^void logging(int level, const char *format, ...) $/;"	f
logtest	src/logging.c	/^void logtest()$/;"	f
create_pool	src/memory.c	/^struct pool_head *create_pool(char *name, unsigned int size, unsigned int flags)$/;"	f
dump_pools	src/memory.c	/^void dump_pools(void)$/;"	f
mem_poison_byte	src/memory.c	/^char mem_poison_byte = 0;$/;"	v
pool_destroy2	src/memory.c	/^void *pool_destroy2(struct pool_head *pool)$/;"	f
pool_flush2	src/memory.c	/^void pool_flush2(struct pool_head *pool)$/;"	f
pool_gc2	src/memory.c	/^void pool_gc2()$/;"	f
pool_refill_alloc	src/memory.c	/^void *pool_refill_alloc(struct pool_head *pool)$/;"	f
pools	src/memory.c	/^static struct list pools = LIST_HEAD_INIT(pools);$/;"	v	typeref:struct:list	file:
PEER_F_LEARN_ASSIGN	src/peers.c	74;"	d	file:
PEER_F_LEARN_NOTUP2DATE	src/peers.c	75;"	d	file:
PEER_F_TEACH_COMPLETE	src/peers.c	73;"	d	file:
PEER_F_TEACH_FINISHED	src/peers.c	72;"	d	file:
PEER_F_TEACH_PROCESS	src/peers.c	69;"	d	file:
PEER_F_TEACH_STAGE1	src/peers.c	70;"	d	file:
PEER_F_TEACH_STAGE2	src/peers.c	71;"	d	file:
PEER_LEARN_RESET	src/peers.c	78;"	d	file:
PEER_SESSION_ACCEPT	src/peers.c	85;"	d	file:
PEER_SESSION_CONNECT	src/peers.c	94;"	d	file:
PEER_SESSION_CONNECTCODE	src/peers.c	109;"	d	file:
PEER_SESSION_CONNECTEDCODE	src/peers.c	110;"	d	file:
PEER_SESSION_END	src/peers.c	101;"	d	file:
PEER_SESSION_ERRHOST	src/peers.c	118;"	d	file:
PEER_SESSION_ERRPEER	src/peers.c	119;"	d	file:
PEER_SESSION_ERRPROTO	src/peers.c	116;"	d	file:
PEER_SESSION_ERRSIZE	src/peers.c	121;"	d	file:
PEER_SESSION_ERRTABLE	src/peers.c	122;"	d	file:
PEER_SESSION_ERRTYPE	src/peers.c	120;"	d	file:
PEER_SESSION_ERRVERSION	src/peers.c	117;"	d	file:
PEER_SESSION_EXIT	src/peers.c	100;"	d	file:
PEER_SESSION_GETHOST	src/peers.c	87;"	d	file:
PEER_SESSION_GETPEER	src/peers.c	88;"	d	file:
PEER_SESSION_GETSTATUS	src/peers.c	96;"	d	file:
PEER_SESSION_GETTABLE	src/peers.c	89;"	d	file:
PEER_SESSION_GETVERSION	src/peers.c	86;"	d	file:
PEER_SESSION_PROTO_NAME	src/peers.c	124;"	d	file:
PEER_SESSION_SENDSUCCESS	src/peers.c	91;"	d	file:
PEER_SESSION_SUCCESSCODE	src/peers.c	112;"	d	file:
PEER_SESSION_TRYAGAIN	src/peers.c	114;"	d	file:
PEER_SESSION_WAITMSG	src/peers.c	97;"	d	file:
PEER_TEACH_RESET	src/peers.c	77;"	d	file:
SHTABLE_F_DONOTSTOP	src/peers.c	58;"	d	file:
SHTABLE_F_RESYNC_ASSIGN	src/peers.c	56;"	d	file:
SHTABLE_F_RESYNC_LOCAL	src/peers.c	54;"	d	file:
SHTABLE_F_RESYNC_PROCESS	src/peers.c	57;"	d	file:
SHTABLE_F_RESYNC_REMOTE	src/peers.c	55;"	d	file:
SHTABLE_RESYNC_FINISHED	src/peers.c	64;"	d	file:
SHTABLE_RESYNC_FROMLOCAL	src/peers.c	62;"	d	file:
SHTABLE_RESYNC_FROMREMOTE	src/peers.c	63;"	d	file:
SHTABLE_RESYNC_STATEMASK	src/peers.c	61;"	d	file:
peer_accept	src/peers.c	/^int peer_accept(struct session *s)$/;"	f
peer_applet	src/peers.c	/^static struct si_applet peer_applet = {$/;"	v	typeref:struct:si_applet	file:
peer_io_handler	src/peers.c	/^static void peer_io_handler(struct stream_interface *si)$/;"	f	file:
peer_prepare_datamsg	src/peers.c	/^static int peer_prepare_datamsg(struct stksess *ts, struct peer_session *ps, char *msg, size_t size)$/;"	f	file:
peer_session_create	src/peers.c	/^static struct session *peer_session_create(struct peer *peer, struct peer_session *ps)$/;"	f	file:
peer_session_forceshutdown	src/peers.c	/^static void peer_session_forceshutdown(struct session * session)$/;"	f	file:
peer_session_release	src/peers.c	/^static void peer_session_release(struct stream_interface *si)$/;"	f	file:
peers	src/peers.c	/^struct peers *peers = NULL;$/;"	v	typeref:struct:peers
peers_register_table	src/peers.c	/^void peers_register_table(struct peers *peers, struct stktable *table)$/;"	f
process_peer_sync	src/peers.c	/^static struct task *process_peer_sync(struct task * task)$/;"	f	file:
__pipe_module_init	src/pipe.c	/^static void __pipe_module_init(void)$/;"	f	file:
get_pipe	src/pipe.c	/^struct pipe *get_pipe()$/;"	f
init_pipe	src/pipe.c	/^static void init_pipe()$/;"	f	file:
kill_pipe	src/pipe.c	/^void kill_pipe(struct pipe *p)$/;"	f
pipes_free	src/pipe.c	/^int pipes_free = 0;             \/* # of pipes unused *\/$/;"	v
pipes_live	src/pipe.c	/^struct pipe *pipes_live = NULL; \/* pipes which are still ready to use *\/$/;"	v	typeref:struct:pipe
pipes_used	src/pipe.c	/^int pipes_used = 0;             \/* # of pipes in use (2 fds each) *\/$/;"	v
pool2_pipe	src/pipe.c	/^struct pool_head *pool2_pipe = NULL;$/;"	v	typeref:struct:pool_head
put_pipe	src/pipe.c	/^void put_pipe(struct pipe *p)$/;"	f
CHECK_HTTP_MESSAGE_FIRST	src/proto_http.c	7676;"	d	file:
CHECK_HTTP_MESSAGE_FIRST_PERM	src/proto_http.c	7679;"	d	file:
EAT_AND_JUMP_OR_RETURN	src/proto_http.c	942;"	d	file:
EXPECT_LF_HERE	src/proto_http.c	937;"	d	file:
FD_SETS_ARE_BITFIELDS	src/proto_http.c	220;"	d	file:
HTTP_100	src/proto_http.c	/^const char HTTP_100[] =$/;"	v
HTTP_200	src/proto_http.c	/^const char *HTTP_200 =$/;"	v
HTTP_301	src/proto_http.c	/^const char *HTTP_301 =$/;"	v
HTTP_302	src/proto_http.c	/^const char *HTTP_302 =$/;"	v
HTTP_303	src/proto_http.c	/^const char *HTTP_303 =$/;"	v
HTTP_401_fmt	src/proto_http.c	/^const char *HTTP_401_fmt =$/;"	v
HTTP_407_fmt	src/proto_http.c	/^const char *HTTP_407_fmt =$/;"	v
__http_protocol_init	src/proto_http.c	/^static void __http_protocol_init(void)$/;"	f	file:
acl_fetch_cookie_cnt	src/proto_http.c	/^acl_fetch_cookie_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_http_auth	src/proto_http.c	/^acl_fetch_http_auth(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_http_auth_grp	src/proto_http.c	/^acl_fetch_http_auth_grp(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_http_first_req	src/proto_http.c	/^acl_fetch_http_first_req(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_meth	src/proto_http.c	/^acl_fetch_meth(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_path	src/proto_http.c	/^acl_fetch_path(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_proto_http	src/proto_http.c	/^acl_fetch_proto_http(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_rqver	src/proto_http.c	/^acl_fetch_rqver(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_stcode	src/proto_http.c	/^acl_fetch_stcode(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_stver	src/proto_http.c	/^acl_fetch_stver(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_url	src/proto_http.c	/^acl_fetch_url(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_url_ip	src/proto_http.c	/^acl_fetch_url_ip(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_url_port	src/proto_http.c	/^acl_fetch_url_port(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_kws	src/proto_http.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
acl_match_meth	src/proto_http.c	/^static int acl_match_meth(struct sample *smp, struct acl_pattern *pattern)$/;"	f	file:
acl_parse_meth	src/proto_http.c	/^static int acl_parse_meth(const char **text, struct acl_pattern *pattern, int *opaque, char **err)$/;"	f	file:
acl_parse_ver	src/proto_http.c	/^static int acl_parse_ver(const char **text, struct acl_pattern *pattern, int *opaque, char **err)$/;"	f	file:
acl_prefetch_http	src/proto_http.c	/^acl_prefetch_http(struct proxy *px, struct session *s, void *l7, unsigned int opt,$/;"	f	file:
apply_filter_to_req_headers	src/proto_http.c	/^int apply_filter_to_req_headers(struct session *t, struct buffer *req, struct hdr_exp *exp)$/;"	f
apply_filter_to_req_line	src/proto_http.c	/^int apply_filter_to_req_line(struct session *t, struct buffer *req, struct hdr_exp *exp)$/;"	f
apply_filter_to_resp_headers	src/proto_http.c	/^int apply_filter_to_resp_headers(struct session *t, struct buffer *rtr, struct hdr_exp *exp)$/;"	f
apply_filter_to_sts_line	src/proto_http.c	/^int apply_filter_to_sts_line(struct session *t, struct buffer *rtr, struct hdr_exp *exp)$/;"	f
apply_filters_to_request	src/proto_http.c	/^int apply_filters_to_request(struct session *s, struct buffer *req, struct proxy *px)$/;"	f
apply_filters_to_response	src/proto_http.c	/^int apply_filters_to_response(struct session *s, struct buffer *rtr, struct proxy *px)$/;"	f
capture_headers	src/proto_http.c	/^void capture_headers(char *som, struct hdr_idx *idx,$/;"	f
check_response_for_cacheability	src/proto_http.c	/^void check_response_for_cacheability(struct session *t, struct buffer *rtr)$/;"	f
debug_hdr	src/proto_http.c	/^void debug_hdr(const char *dir, struct session *t, const char *start, const char *end)$/;"	f
del_hdr_value	src/proto_http.c	/^int del_hdr_value(struct buffer *buf, char **from, char *next)$/;"	f
error_message	src/proto_http.c	/^struct chunk *error_message(struct session *s, int msgnum)$/;"	f
extract_cookie_value	src/proto_http.c	/^extract_cookie_value(char *hdr, const char *hdr_end,$/;"	f	file:
find_cookie_value_end	src/proto_http.c	/^char *find_cookie_value_end(char *s, const char *e)$/;"	f
find_hdr_value_end	src/proto_http.c	/^char *find_hdr_value_end(char *s, const char *e)$/;"	f
find_http_meth	src/proto_http.c	/^static http_meth_t find_http_meth(const char *str, const int len)$/;"	f	file:
find_query_string	src/proto_http.c	/^static inline char *find_query_string(char *path, size_t path_l)$/;"	f	file:
find_url_param_pos	src/proto_http.c	/^find_url_param_pos(char* query_string, size_t query_string_l,$/;"	f	file:
find_url_param_value	src/proto_http.c	/^find_url_param_value(char* path, size_t path_l,$/;"	f	file:
free_http_req_rules	src/proto_http.c	/^void free_http_req_rules(struct list *r) {$/;"	f
get_http_auth	src/proto_http.c	/^get_http_auth(struct session *s)$/;"	f
get_http_auth_buff	src/proto_http.c	/^char get_http_auth_buff[BUFSIZE];$/;"	v
get_srv_from_appsession	src/proto_http.c	/^void get_srv_from_appsession(struct session *t, const char *begin, int len)$/;"	f
hdr_encode_map	src/proto_http.c	/^fd_set hdr_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
http_100_chunk	src/proto_http.c	/^const struct chunk http_100_chunk = {$/;"	v	typeref:struct:chunk
http_capture_bad_message	src/proto_http.c	/^void http_capture_bad_message(struct error_snapshot *es, struct session *s,$/;"	f
http_change_connection_header	src/proto_http.c	/^void http_change_connection_header(struct http_txn *txn, struct http_msg *msg, int wanted)$/;"	f
http_check_access_rule	src/proto_http.c	/^http_check_access_rule(struct proxy *px, struct list *rules, struct session *s, struct http_txn *txn)$/;"	f	file:
http_end_txn	src/proto_http.c	/^void http_end_txn(struct session *s)$/;"	f
http_end_txn_clean_session	src/proto_http.c	/^void http_end_txn_clean_session(struct session *s)$/;"	f
http_err_chunks	src/proto_http.c	/^struct chunk http_err_chunks[HTTP_ERR_SIZE];$/;"	v	typeref:struct:chunk
http_err_codes	src/proto_http.c	/^const int http_err_codes[HTTP_ERR_SIZE] = {$/;"	v
http_err_msgs	src/proto_http.c	/^static const char *http_err_msgs[HTTP_ERR_SIZE] = {$/;"	v	file:
http_find_header	src/proto_http.c	/^int http_find_header(const char *name,$/;"	f
http_find_header2	src/proto_http.c	/^int http_find_header2(const char *name, int len,$/;"	f
http_forward_trailers	src/proto_http.c	/^int http_forward_trailers(struct http_msg *msg)$/;"	f
http_get_hdr	src/proto_http.c	/^unsigned int http_get_hdr(const struct http_msg *msg, const char *hname, int hlen,$/;"	f
http_get_path	src/proto_http.c	/^http_get_path(struct http_txn *txn)$/;"	f	file:
http_header_add_tail	src/proto_http.c	/^int http_header_add_tail(struct http_msg *msg, struct hdr_idx *hdr_idx, const char *text)$/;"	f
http_header_add_tail2	src/proto_http.c	/^int http_header_add_tail2(struct http_msg *msg,$/;"	f
http_header_match2	src/proto_http.c	/^int http_header_match2(const char *hdr, const char *end,$/;"	f
http_init_txn	src/proto_http.c	/^void http_init_txn(struct session *s)$/;"	f
http_is_crlf	src/proto_http.c	/^const char http_is_crlf[256] = {$/;"	v
http_is_ctl	src/proto_http.c	/^const char http_is_ctl[256] = {$/;"	v
http_is_lws	src/proto_http.c	/^const char http_is_lws[256] = {$/;"	v
http_is_sep	src/proto_http.c	/^const char http_is_sep[256] = {$/;"	v
http_is_spht	src/proto_http.c	/^const char http_is_spht[256] = {$/;"	v
http_is_token	src/proto_http.c	/^const char http_is_token[256] = {$/;"	v
http_is_ver_token	src/proto_http.c	/^const char http_is_ver_token[256] = {$/;"	v
http_method_desc	src/proto_http.c	/^struct http_method_desc {$/;"	s	file:
http_methods	src/proto_http.c	/^const struct http_method_desc http_methods[26][3] = {$/;"	v	typeref:struct:http_method_desc
http_msg_analyzer	src/proto_http.c	/^void http_msg_analyzer(struct http_msg *msg, struct hdr_idx *idx)$/;"	f
http_parse_chunk_size	src/proto_http.c	/^int http_parse_chunk_size(struct http_msg *msg)$/;"	f
http_parse_connection_header	src/proto_http.c	/^void http_parse_connection_header(struct http_txn *txn, struct http_msg *msg, int to_del)$/;"	f
http_parse_reqline	src/proto_http.c	/^const char *http_parse_reqline(struct http_msg *msg,$/;"	f
http_parse_stsline	src/proto_http.c	/^const char *http_parse_stsline(struct http_msg *msg,$/;"	f
http_process_req_common	src/proto_http.c	/^int http_process_req_common(struct session *s, struct buffer *req, int an_bit, struct proxy *px)$/;"	f
http_process_req_stat_post	src/proto_http.c	/^int http_process_req_stat_post(struct stream_interface *si, struct http_txn *txn, struct buffer *req)$/;"	f
http_process_request	src/proto_http.c	/^int http_process_request(struct session *s, struct buffer *req, int an_bit)$/;"	f
http_process_request_body	src/proto_http.c	/^int http_process_request_body(struct session *s, struct buffer *req, int an_bit)$/;"	f
http_process_res_common	src/proto_http.c	/^int http_process_res_common(struct session *t, struct buffer *rep, int an_bit, struct proxy *px)$/;"	f
http_process_tarpit	src/proto_http.c	/^int http_process_tarpit(struct session *s, struct buffer *req, int an_bit)$/;"	f
http_remove_header2	src/proto_http.c	/^int http_remove_header2(struct http_msg *msg, struct hdr_idx *idx, struct hdr_ctx *ctx)$/;"	f
http_request_forward_body	src/proto_http.c	/^int http_request_forward_body(struct session *s, struct buffer *req, int an_bit)$/;"	f
http_reset_txn	src/proto_http.c	/^void http_reset_txn(struct session *s)$/;"	f
http_response_forward_body	src/proto_http.c	/^int http_response_forward_body(struct session *s, struct buffer *res, int an_bit)$/;"	f
http_resync_states	src/proto_http.c	/^int http_resync_states(struct session *s)$/;"	f
http_return_srv_error	src/proto_http.c	/^void http_return_srv_error(struct session *s, struct stream_interface *si)$/;"	f
http_send_name_header	src/proto_http.c	/^int http_send_name_header(struct http_txn *txn, struct proxy* be, const char* srv_name) {$/;"	f
http_server_error	src/proto_http.c	/^static void http_server_error(struct session *t, struct stream_interface *si,$/;"	f	file:
http_silent_debug	src/proto_http.c	/^static void http_silent_debug(int line, struct session *s)$/;"	f	file:
http_silent_debug	src/proto_http.c	420;"	d	file:
http_skip_chunk_crlf	src/proto_http.c	/^int http_skip_chunk_crlf(struct http_msg *msg)$/;"	f
http_sync_req_state	src/proto_http.c	/^int http_sync_req_state(struct session *s)$/;"	f
http_sync_res_state	src/proto_http.c	/^int http_sync_res_state(struct session *s)$/;"	f
http_upgrade_v09_to_v10	src/proto_http.c	/^static int http_upgrade_v09_to_v10(struct http_txn *txn)$/;"	f	file:
http_wait_for_request	src/proto_http.c	/^int http_wait_for_request(struct session *s, struct buffer *req, int an_bit)$/;"	f
http_wait_for_response	src/proto_http.c	/^int http_wait_for_response(struct session *s, struct buffer *rep, int an_bit)$/;"	f
init_proto_http	src/proto_http.c	/^void init_proto_http()$/;"	f
is_param_delimiter	src/proto_http.c	/^static inline int is_param_delimiter(char c)$/;"	f	file:
len	src/proto_http.c	/^	int len;$/;"	m	struct:http_method_desc	file:
manage_client_side_appsession	src/proto_http.c	/^void manage_client_side_appsession(struct session *t, const char *buf, int len) {$/;"	f
manage_client_side_cookies	src/proto_http.c	/^void manage_client_side_cookies(struct session *t, struct buffer *req)$/;"	f
manage_server_side_cookies	src/proto_http.c	/^void manage_server_side_cookies(struct session *t, struct buffer *res)$/;"	f
meth	src/proto_http.c	/^	http_meth_t meth;$/;"	m	struct:http_method_desc	file:
parse_http_req_cond	src/proto_http.c	/^struct http_req_rule *parse_http_req_cond(const char **args, const char *file, int linenum, struct proxy *proxy)$/;"	f
perform_http_redirect	src/proto_http.c	/^void perform_http_redirect(struct session *s, struct stream_interface *si)$/;"	f
pool2_capture	src/proto_http.c	/^struct pool_head *pool2_capture;$/;"	v	typeref:struct:pool_head
pool2_requri	src/proto_http.c	/^struct pool_head *pool2_requri;$/;"	v	typeref:struct:pool_head
pool2_uniqueid	src/proto_http.c	/^struct pool_head *pool2_uniqueid;$/;"	v	typeref:struct:pool_head
sample_fetch_keywords	src/proto_http.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {{ },{$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_fetch_cookie	src/proto_http.c	/^smp_fetch_cookie(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_cookie_val	src/proto_http.c	/^smp_fetch_cookie_val(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_hdr	src/proto_http.c	/^smp_fetch_hdr(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_hdr_cnt	src/proto_http.c	/^smp_fetch_hdr_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_hdr_ip	src/proto_http.c	/^smp_fetch_hdr_ip(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_hdr_val	src/proto_http.c	/^smp_fetch_hdr_val(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_url_param	src/proto_http.c	/^smp_fetch_url_param(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
stat_status_codes	src/proto_http.c	/^const char *stat_status_codes[STAT_STATUS_SIZE] = {$/;"	v
stats_check_uri	src/proto_http.c	/^int stats_check_uri(struct stream_interface *si, struct http_txn *txn, struct proxy *backend)$/;"	f
text	src/proto_http.c	/^	const char text[8];$/;"	m	struct:http_method_desc	file:
url_encode_map	src/proto_http.c	/^fd_set url_encode_map[(sizeof(fd_set) > (256\/8)) ? 1 : ((256\/8) \/ sizeof(fd_set))];$/;"	v
val_hdr	src/proto_http.c	/^static int val_hdr(struct arg *arg, char **err_msg)$/;"	f	file:
__tcp_protocol_init	src/proto_tcp.c	/^static void __tcp_protocol_init(void)$/;"	f	file:
acl_fetch_rdp_cookie_cnt	src/proto_tcp.c	/^acl_fetch_rdp_cookie_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_kws	src/proto_tcp.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
cfg_kws	src/proto_tcp.c	/^static struct cfg_kw_list cfg_kws = {{ },{$/;"	v	typeref:struct:cfg_kw_list	file:
proto_tcpv4	src/proto_tcp.c	/^static struct protocol proto_tcpv4 = {$/;"	v	typeref:struct:protocol	file:
proto_tcpv6	src/proto_tcp.c	/^static struct protocol proto_tcpv6 = {$/;"	v	typeref:struct:protocol	file:
sample_fetch_keywords	src/proto_tcp.c	/^static struct sample_fetch_kw_list sample_fetch_keywords = {{ },{$/;"	v	typeref:struct:sample_fetch_kw_list	file:
smp_fetch_dport	src/proto_tcp.c	/^smp_fetch_dport(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_dst	src/proto_tcp.c	/^smp_fetch_dst(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_payload	src/proto_tcp.c	/^smp_fetch_payload(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_payload_lv	src/proto_tcp.c	/^smp_fetch_payload_lv(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_rdp_cookie	src/proto_tcp.c	/^smp_fetch_rdp_cookie(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f
smp_fetch_sport	src/proto_tcp.c	/^smp_fetch_sport(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
smp_fetch_src	src/proto_tcp.c	/^smp_fetch_src(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
tcp_bind_listener	src/proto_tcp.c	/^int tcp_bind_listener(struct listener *listener, char *errmsg, int errlen)$/;"	f
tcp_bind_listeners	src/proto_tcp.c	/^static int tcp_bind_listeners(struct protocol *proto, char *errmsg, int errlen)$/;"	f	file:
tcp_bind_socket	src/proto_tcp.c	/^int tcp_bind_socket(int fd, int flags, struct sockaddr_storage *local, struct sockaddr_storage *remote)$/;"	f
tcp_connect_read	src/proto_tcp.c	/^static int tcp_connect_read(int fd)$/;"	f	file:
tcp_connect_server	src/proto_tcp.c	/^int tcp_connect_server(struct stream_interface *si)$/;"	f
tcp_connect_write	src/proto_tcp.c	/^static int tcp_connect_write(int fd)$/;"	f	file:
tcp_exec_req_rules	src/proto_tcp.c	/^int tcp_exec_req_rules(struct session *s)$/;"	f
tcp_get_dst	src/proto_tcp.c	/^int tcp_get_dst(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
tcp_get_src	src/proto_tcp.c	/^int tcp_get_src(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
tcp_inspect_request	src/proto_tcp.c	/^int tcp_inspect_request(struct session *s, struct buffer *req, int an_bit)$/;"	f
tcp_inspect_response	src/proto_tcp.c	/^int tcp_inspect_response(struct session *s, struct buffer *rep, int an_bit)$/;"	f
tcp_parse_request_rule	src/proto_tcp.c	/^static int tcp_parse_request_rule(char **args, int arg, int section_type,$/;"	f	file:
tcp_parse_response_rule	src/proto_tcp.c	/^static int tcp_parse_response_rule(char **args, int arg, int section_type,$/;"	f	file:
tcp_parse_tcp_rep	src/proto_tcp.c	/^static int tcp_parse_tcp_rep(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
tcp_parse_tcp_req	src/proto_tcp.c	/^static int tcp_parse_tcp_req(char **args, int section_type, struct proxy *curpx,$/;"	f	file:
tcpv4_add_listener	src/proto_tcp.c	/^void tcpv4_add_listener(struct listener *listener)$/;"	f
tcpv6_add_listener	src/proto_tcp.c	/^void tcpv6_add_listener(struct listener *listener)$/;"	f
val_payload	src/proto_tcp.c	/^static int val_payload(struct arg *arg, char **err_msg)$/;"	f	file:
val_payload_lv	src/proto_tcp.c	/^static int val_payload_lv(struct arg *arg, char **err_msg)$/;"	f	file:
__uxst_protocol_init	src/proto_uxst.c	/^static void __uxst_protocol_init(void)$/;"	f	file:
destroy_uxst_socket	src/proto_uxst.c	/^static void destroy_uxst_socket(const char *path)$/;"	f	file:
proto_unix	src/proto_uxst.c	/^static struct protocol proto_unix = {$/;"	v	typeref:struct:protocol	file:
uxst_add_listener	src/proto_uxst.c	/^void uxst_add_listener(struct listener *listener)$/;"	f
uxst_bind_listener	src/proto_uxst.c	/^static int uxst_bind_listener(struct listener *listener, char *errmsg, int errlen)$/;"	f	file:
uxst_bind_listeners	src/proto_uxst.c	/^static int uxst_bind_listeners(struct protocol *proto, char *errmsg, int errlen)$/;"	f	file:
uxst_get_dst	src/proto_uxst.c	/^int uxst_get_dst(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
uxst_get_src	src/proto_uxst.c	/^int uxst_get_src(int fd, struct sockaddr *sa, socklen_t salen, int dir)$/;"	f
uxst_unbind_listener	src/proto_uxst.c	/^static int uxst_unbind_listener(struct listener *listener)$/;"	f	file:
uxst_unbind_listeners	src/proto_uxst.c	/^static int uxst_unbind_listeners(struct protocol *proto)$/;"	f	file:
__protocols_init	src/protocols.c	/^static void __protocols_init(void)$/;"	f	file:
acl_fetch_dconn	src/protocols.c	/^acl_fetch_dconn(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_so_id	src/protocols.c	/^acl_fetch_so_id(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_kws	src/protocols.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
delete_listener	src/protocols.c	/^void delete_listener(struct listener *listener)$/;"	f
dequeue_all_listeners	src/protocols.c	/^void dequeue_all_listeners(struct list *list)$/;"	f
disable_all_listeners	src/protocols.c	/^int disable_all_listeners(struct protocol *proto)$/;"	f
disable_listener	src/protocols.c	/^void disable_listener(struct listener *listener)$/;"	f
enable_all_listeners	src/protocols.c	/^int enable_all_listeners(struct protocol *proto)$/;"	f
enable_listener	src/protocols.c	/^void enable_listener(struct listener *listener)$/;"	f
limit_listener	src/protocols.c	/^void limit_listener(struct listener *l, struct list *list)$/;"	f
listener_accept	src/protocols.c	/^int listener_accept(int fd)$/;"	f
listener_full	src/protocols.c	/^void listener_full(struct listener *l)$/;"	f
pause_listener	src/protocols.c	/^int pause_listener(struct listener *l)$/;"	f
protocol_bind_all	src/protocols.c	/^int protocol_bind_all(char *errmsg, int errlen)$/;"	f
protocol_by_family	src/protocols.c	/^struct protocol *protocol_by_family(int family)$/;"	f
protocol_disable_all	src/protocols.c	/^int protocol_disable_all(void)$/;"	f
protocol_enable_all	src/protocols.c	/^int protocol_enable_all(void)$/;"	f
protocol_register	src/protocols.c	/^void protocol_register(struct protocol *proto)$/;"	f
protocol_unbind_all	src/protocols.c	/^int protocol_unbind_all(void)$/;"	f
protocol_unregister	src/protocols.c	/^void protocol_unregister(struct protocol *proto)$/;"	f
protocols	src/protocols.c	/^static struct list protocols = LIST_HEAD_INIT(protocols);$/;"	v	typeref:struct:list	file:
resume_listener	src/protocols.c	/^int resume_listener(struct listener *l)$/;"	f
unbind_all_listeners	src/protocols.c	/^int unbind_all_listeners(struct protocol *proto)$/;"	f
unbind_listener	src/protocols.c	/^int unbind_listener(struct listener *listener)$/;"	f
__proxy_module_init	src/proxy.c	/^static void __proxy_module_init(void)$/;"	f	file:
cfg_kws	src/proxy.c	/^static struct cfg_kw_list cfg_kws = {{ },{$/;"	v	typeref:struct:cfg_kw_list	file:
error_snapshot_id	src/proxy.c	/^unsigned int error_snapshot_id = 0;     \/* global ID assigned to each error then incremented *\/$/;"	v
findproxy	src/proxy.c	/^struct proxy *findproxy(const char *name, int cap) {$/;"	f
findproxy_mode	src/proxy.c	/^struct proxy *findproxy_mode(const char *name, int mode, int cap) {$/;"	f
findserver	src/proxy.c	/^struct server *findserver(const struct proxy *px, const char *name) {$/;"	f
get_backend_server	src/proxy.c	/^int get_backend_server(const char *bk_name, const char *sv_name,$/;"	f
init_new_proxy	src/proxy.c	/^void init_new_proxy(struct proxy *p)$/;"	f
listeners	src/proxy.c	/^int listeners;	\/* # of proxy listeners, set by cfgparse *\/$/;"	v
manage_proxy	src/proxy.c	/^struct task *manage_proxy(struct task *t)$/;"	f
pause_proxies	src/proxy.c	/^void pause_proxies(void)$/;"	f
pause_proxy	src/proxy.c	/^int pause_proxy(struct proxy *p)$/;"	f
proxy	src/proxy.c	/^struct proxy *proxy  = NULL;	\/* list of all existing proxies *\/$/;"	v	typeref:struct:proxy
proxy_cap_str	src/proxy.c	/^const char *proxy_cap_str(int cap)$/;"	f
proxy_cfg_ensure_no_http	src/proxy.c	/^int proxy_cfg_ensure_no_http(struct proxy *curproxy)$/;"	f
proxy_mode_str	src/proxy.c	/^const char *proxy_mode_str(int mode) {$/;"	f
proxy_parse_rate_limit	src/proxy.c	/^static int proxy_parse_rate_limit(char **args, int section, struct proxy *proxy,$/;"	f	file:
proxy_parse_timeout	src/proxy.c	/^static int proxy_parse_timeout(char **args, int section, struct proxy *proxy,$/;"	f	file:
resume_proxies	src/proxy.c	/^void resume_proxies(void)$/;"	f
resume_proxy	src/proxy.c	/^int resume_proxy(struct proxy *p)$/;"	f
session_set_backend	src/proxy.c	/^int session_set_backend(struct session *s, struct proxy *be)$/;"	f
soft_stop	src/proxy.c	/^void soft_stop(void)$/;"	f
start_proxies	src/proxy.c	/^int start_proxies(int verbose)$/;"	f
stop_proxy	src/proxy.c	/^void stop_proxy(struct proxy *p)$/;"	f
used_proxy_id	src/proxy.c	/^struct eb_root used_proxy_id = EB_ROOT;	\/* list of proxy IDs in use *\/$/;"	v	typeref:struct:eb_root
init_pendconn	src/queue.c	/^int init_pendconn()$/;"	f
pendconn_add	src/queue.c	/^struct pendconn *pendconn_add(struct session *sess)$/;"	f
pendconn_free	src/queue.c	/^void pendconn_free(struct pendconn *p)$/;"	f
pendconn_get_next_sess	src/queue.c	/^struct session *pendconn_get_next_sess(struct server *srv, struct proxy *px)$/;"	f
pool2_pendconn	src/queue.c	/^struct pool_head *pool2_pendconn;$/;"	v	typeref:struct:pool_head
process_srv_queue	src/queue.c	/^void process_srv_queue(struct server *s)$/;"	f
srv_dynamic_maxconn	src/queue.c	/^unsigned int srv_dynamic_maxconn(const struct server *s)$/;"	f
__rb_erase_color	src/rbtree.c	/^static void __rb_erase_color(struct rb_node *node, struct rb_node *parent,$/;"	f	file:
__rb_rotate_left	src/rbtree.c	/^static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)$/;"	f	file:
__rb_rotate_right	src/rbtree.c	/^static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)$/;"	f	file:
rb_erase	src/rbtree.c	/^void rb_erase(struct rb_node *node, struct rb_root *root)$/;"	f
rb_first	src/rbtree.c	/^struct rb_node *rb_first(struct rb_root *root)$/;"	f
rb_insert_color	src/rbtree.c	/^void rb_insert_color(struct rb_node *node, struct rb_root *root)$/;"	f
rb_last	src/rbtree.c	/^struct rb_node *rb_last(struct rb_root *root)$/;"	f
rb_next	src/rbtree.c	/^struct rb_node *rb_next(struct rb_node *node)$/;"	f
rb_prev	src/rbtree.c	/^struct rb_node *rb_prev(struct rb_node *node)$/;"	f
rb_replace_node	src/rbtree.c	/^void rb_replace_node(struct rb_node *victim, struct rb_node *new,$/;"	f
chain_regex	src/regex.c	/^const char *chain_regex(struct hdr_exp **head, const regex_t *preg,$/;"	f
check_replace_string	src/regex.c	/^const char *check_replace_string(const char *str)$/;"	f
exp_replace	src/regex.c	/^int exp_replace(char *dst, char *src, const char *str, const regmatch_t *matches)$/;"	f
pmatch	src/regex.c	/^regmatch_t pmatch[MAX_MATCH];  \/* rm_so, rm_eo for regular expressions *\/$/;"	v
__sample_init	src/sample.c	/^static void __sample_init(void)$/;"	f	file:
c_datadup	src/sample.c	/^static int c_datadup(struct sample *smp)$/;"	f	file:
c_int2ip	src/sample.c	/^static int c_int2ip(struct sample *smp)$/;"	f	file:
c_int2str	src/sample.c	/^static int c_int2str(struct sample *smp)$/;"	f	file:
c_ip2int	src/sample.c	/^static int c_ip2int(struct sample *smp)$/;"	f	file:
c_ip2ipv6	src/sample.c	/^static int c_ip2ipv6(struct sample *smp)$/;"	f	file:
c_ip2str	src/sample.c	/^static int c_ip2str(struct sample *smp)$/;"	f	file:
c_ipv62str	src/sample.c	/^static int c_ipv62str(struct sample *smp)$/;"	f	file:
c_none	src/sample.c	/^static int c_none(struct sample *smp)$/;"	f	file:
c_str2int	src/sample.c	/^static int c_str2int(struct sample *smp)$/;"	f	file:
c_str2ip	src/sample.c	/^static int c_str2ip(struct sample *smp)$/;"	f	file:
c_str2ipv6	src/sample.c	/^static int c_str2ipv6(struct sample *smp)$/;"	f	file:
find_sample_conv	src/sample.c	/^struct sample_conv *find_sample_conv(const char *kw, int len)$/;"	f
find_sample_fetch	src/sample.c	/^struct sample_fetch *find_sample_fetch(const char *kw, int len)$/;"	f
get_trash_chunk	src/sample.c	/^static struct chunk *get_trash_chunk(void)$/;"	f	file:
sample_cast_fct	src/sample.c	/^typedef int (*sample_cast_fct)(struct sample *smp);$/;"	t	file:
sample_casts	src/sample.c	/^static sample_cast_fct sample_casts[SMP_TYPES][SMP_TYPES] = {$/;"	v	file:
sample_conv_ipmask	src/sample.c	/^static int sample_conv_ipmask(const struct arg *arg_p, struct sample *smp)$/;"	f	file:
sample_conv_kws	src/sample.c	/^static struct sample_conv_kw_list sample_conv_kws = {{ },{$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_conv_str2lower	src/sample.c	/^static int sample_conv_str2lower(const struct arg *arg_p, struct sample *smp)$/;"	f	file:
sample_conv_str2upper	src/sample.c	/^static int sample_conv_str2upper(const struct arg *arg_p, struct sample *smp)$/;"	f	file:
sample_convs	src/sample.c	/^static struct sample_conv_kw_list sample_convs = {$/;"	v	typeref:struct:sample_conv_kw_list	file:
sample_fetches	src/sample.c	/^static struct sample_fetch_kw_list sample_fetches = {$/;"	v	typeref:struct:sample_fetch_kw_list	file:
sample_parse_expr	src/sample.c	/^struct sample_expr *sample_parse_expr(char **str, int *idx, char *err, int err_size)$/;"	f
sample_process	src/sample.c	/^struct sample *sample_process(struct proxy *px, struct session *l4, void *l7,$/;"	f
sample_register_convs	src/sample.c	/^void sample_register_convs(struct sample_conv_kw_list *pckl)$/;"	f
sample_register_fetches	src/sample.c	/^void sample_register_fetches(struct sample_fetch_kw_list *pfkl)$/;"	f
sample_trash_buf	src/sample.c	/^static char *sample_trash_buf = sample_trash_buf1;$/;"	v	file:
sample_trash_buf1	src/sample.c	/^static char sample_trash_buf1[BUFSIZE];$/;"	v	file:
sample_trash_buf2	src/sample.c	/^static char sample_trash_buf2[BUFSIZE];$/;"	v	file:
temp_smp	src/sample.c	/^static struct sample temp_smp;$/;"	v	typeref:struct:sample	file:
trash_chunk	src/sample.c	/^static struct chunk trash_chunk;$/;"	v	typeref:struct:chunk	file:
srv_downtime	src/server.c	/^int srv_downtime(struct server *s) {$/;"	f
srv_getinter	src/server.c	/^int srv_getinter(struct server *s) {$/;"	f
UPDATE_ANALYSERS	src/session.c	1296;"	d	file:
__session_init	src/session.c	/^static void __session_init(void)$/;"	f	file:
acl_fetch_bytes_in_rate	src/session.c	/^acl_fetch_bytes_in_rate(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_bytes_out_rate	src/session.c	/^acl_fetch_bytes_out_rate(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_clr_gpc0	src/session.c	/^acl_fetch_clr_gpc0(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_conn_cnt	src/session.c	/^acl_fetch_conn_cnt(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_conn_cur	src/session.c	/^acl_fetch_conn_cur(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_conn_rate	src/session.c	/^acl_fetch_conn_rate(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_get_gpc0	src/session.c	/^acl_fetch_get_gpc0(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_http_err_cnt	src/session.c	/^acl_fetch_http_err_cnt(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_http_err_rate	src/session.c	/^acl_fetch_http_err_rate(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_http_req_cnt	src/session.c	/^acl_fetch_http_req_cnt(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_http_req_rate	src/session.c	/^acl_fetch_http_req_rate(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_inc_gpc0	src/session.c	/^acl_fetch_inc_gpc0(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_kbytes_in	src/session.c	/^acl_fetch_kbytes_in(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_kbytes_out	src/session.c	/^acl_fetch_kbytes_out(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_sc1_bytes_in_rate	src/session.c	/^acl_fetch_sc1_bytes_in_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_bytes_out_rate	src/session.c	/^acl_fetch_sc1_bytes_out_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_clr_gpc0	src/session.c	/^acl_fetch_sc1_clr_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_conn_cnt	src/session.c	/^acl_fetch_sc1_conn_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_conn_cur	src/session.c	/^acl_fetch_sc1_conn_cur(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_conn_rate	src/session.c	/^acl_fetch_sc1_conn_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_get_gpc0	src/session.c	/^acl_fetch_sc1_get_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_http_err_cnt	src/session.c	/^acl_fetch_sc1_http_err_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_http_err_rate	src/session.c	/^acl_fetch_sc1_http_err_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_http_req_cnt	src/session.c	/^acl_fetch_sc1_http_req_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_http_req_rate	src/session.c	/^acl_fetch_sc1_http_req_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_inc_gpc0	src/session.c	/^acl_fetch_sc1_inc_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_kbytes_in	src/session.c	/^acl_fetch_sc1_kbytes_in(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_kbytes_out	src/session.c	/^acl_fetch_sc1_kbytes_out(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_sess_cnt	src/session.c	/^acl_fetch_sc1_sess_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc1_sess_rate	src/session.c	/^acl_fetch_sc1_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_bytes_in_rate	src/session.c	/^acl_fetch_sc2_bytes_in_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_bytes_out_rate	src/session.c	/^acl_fetch_sc2_bytes_out_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_clr_gpc0	src/session.c	/^acl_fetch_sc2_clr_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_conn_cnt	src/session.c	/^acl_fetch_sc2_conn_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_conn_cur	src/session.c	/^acl_fetch_sc2_conn_cur(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_conn_rate	src/session.c	/^acl_fetch_sc2_conn_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_get_gpc0	src/session.c	/^acl_fetch_sc2_get_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_http_err_cnt	src/session.c	/^acl_fetch_sc2_http_err_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_http_err_rate	src/session.c	/^acl_fetch_sc2_http_err_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_http_req_cnt	src/session.c	/^acl_fetch_sc2_http_req_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_http_req_rate	src/session.c	/^acl_fetch_sc2_http_req_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_inc_gpc0	src/session.c	/^acl_fetch_sc2_inc_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_kbytes_in	src/session.c	/^acl_fetch_sc2_kbytes_in(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_kbytes_out	src/session.c	/^acl_fetch_sc2_kbytes_out(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_sess_cnt	src/session.c	/^acl_fetch_sc2_sess_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sc2_sess_rate	src/session.c	/^acl_fetch_sc2_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_sess_cnt	src/session.c	/^acl_fetch_sess_cnt(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_sess_rate	src/session.c	/^acl_fetch_sess_rate(struct stktable *table, struct sample *smp, struct stksess *ts)$/;"	f	file:
acl_fetch_src_bytes_in_rate	src/session.c	/^acl_fetch_src_bytes_in_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_bytes_out_rate	src/session.c	/^acl_fetch_src_bytes_out_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_clr_gpc0	src/session.c	/^acl_fetch_src_clr_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_conn_cnt	src/session.c	/^acl_fetch_src_conn_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_conn_cur	src/session.c	/^acl_fetch_src_conn_cur(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_conn_rate	src/session.c	/^acl_fetch_src_conn_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_get_gpc0	src/session.c	/^acl_fetch_src_get_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_http_err_cnt	src/session.c	/^acl_fetch_src_http_err_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_http_err_rate	src/session.c	/^acl_fetch_src_http_err_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_http_req_cnt	src/session.c	/^acl_fetch_src_http_req_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_http_req_rate	src/session.c	/^acl_fetch_src_http_req_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_inc_gpc0	src/session.c	/^acl_fetch_src_inc_gpc0(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_kbytes_in	src/session.c	/^acl_fetch_src_kbytes_in(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_kbytes_out	src/session.c	/^acl_fetch_src_kbytes_out(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_sess_cnt	src/session.c	/^acl_fetch_src_sess_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_sess_rate	src/session.c	/^acl_fetch_src_sess_rate(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_src_updt_conn_cnt	src/session.c	/^acl_fetch_src_updt_conn_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_table_avl	src/session.c	/^acl_fetch_table_avl(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_fetch_table_cnt	src/session.c	/^acl_fetch_table_cnt(struct proxy *px, struct session *l4, void *l7, unsigned int opt,$/;"	f	file:
acl_kws	src/session.c	/^static struct acl_kw_list acl_kws = {{ },{$/;"	v	typeref:struct:acl_kw_list	file:
default_srv_error	src/session.c	/^void default_srv_error(struct session *s, struct stream_interface *si)$/;"	f
init_session	src/session.c	/^int init_session()$/;"	f
parse_track_counters	src/session.c	/^int parse_track_counters(char **args, int *arg,$/;"	f
pool2_session	src/session.c	/^struct pool_head *pool2_session;$/;"	v	typeref:struct:pool_head
process_server_rules	src/session.c	/^static int process_server_rules(struct session *s, struct buffer *req, int an_bit)$/;"	f	file:
process_session	src/session.c	/^struct task *process_session(struct task *t)$/;"	f
process_sticking_rules	src/session.c	/^static int process_sticking_rules(struct session *s, struct buffer *req, int an_bit)$/;"	f	file:
process_store_rules	src/session.c	/^static int process_store_rules(struct session *s, struct buffer *rep, int an_bit)$/;"	f	file:
process_switching_rules	src/session.c	/^static int process_switching_rules(struct session *s, struct buffer *req, int an_bit)$/;"	f	file:
sess_change_server	src/session.c	/^void sess_change_server(struct session *sess, struct server *newsrv)$/;"	f
sess_establish	src/session.c	/^static void sess_establish(struct session *s, struct stream_interface *si)$/;"	f	file:
sess_prepare_conn_req	src/session.c	/^static void sess_prepare_conn_req(struct session *s, struct stream_interface *si)$/;"	f	file:
sess_set_term_flags	src/session.c	/^static void sess_set_term_flags(struct session *s)$/;"	f	file:
sess_update_st_cer	src/session.c	/^static int sess_update_st_cer(struct session *s, struct stream_interface *si)$/;"	f	file:
sess_update_st_con_tcp	src/session.c	/^static int sess_update_st_con_tcp(struct session *s, struct stream_interface *si)$/;"	f	file:
sess_update_stream_int	src/session.c	/^static void sess_update_stream_int(struct session *s, struct stream_interface *si)$/;"	f	file:
session_accept	src/session.c	/^int session_accept(struct listener *l, int cfd, struct sockaddr_storage *addr)$/;"	f
session_free	src/session.c	/^static void session_free(struct session *s)$/;"	f	file:
session_process_counters	src/session.c	/^void session_process_counters(struct session *s)$/;"	f
session_shutdown	src/session.c	/^void session_shutdown(struct session *session, int why)$/;"	f
sessions	src/session.c	/^struct list sessions;$/;"	v	typeref:struct:list
appsession_hash_destroy	src/sessionhash.c	/^void appsession_hash_destroy(struct appsession_hash *hash)$/;"	f
appsession_hash_dump	src/sessionhash.c	/^void appsession_hash_dump(struct appsession_hash *hash)$/;"	f
appsession_hash_f	src/sessionhash.c	/^unsigned int appsession_hash_f(char *ptr)$/;"	f
appsession_hash_init	src/sessionhash.c	/^int appsession_hash_init(struct appsession_hash *hash,$/;"	f
appsession_hash_insert	src/sessionhash.c	/^void appsession_hash_insert(struct appsession_hash *hash, appsess *session)$/;"	f
appsession_hash_lookup	src/sessionhash.c	/^appsess *appsession_hash_lookup(struct appsession_hash *hash, char *sessid)$/;"	f
appsession_hash_remove	src/sessionhash.c	/^void appsession_hash_remove(struct appsession_hash *hash, appsess *session)$/;"	f
__signal_process_queue	src/signal.c	/^void __signal_process_queue()$/;"	f
blocked_sig	src/signal.c	/^sigset_t blocked_sig;$/;"	v
deinit_signals	src/signal.c	/^void deinit_signals()$/;"	f
pool2_sig_handlers	src/signal.c	/^struct pool_head *pool2_sig_handlers = NULL;$/;"	v	typeref:struct:pool_head
signal_handler	src/signal.c	/^void signal_handler(int sig)$/;"	f
signal_init	src/signal.c	/^int signal_init()$/;"	f
signal_pending	src/signal.c	/^int signal_pending = 0; \/* non-zero if t least one signal remains unprocessed *\/$/;"	v
signal_queue	src/signal.c	/^int signal_queue[MAX_SIGNAL];                     \/* in-order queue of received signals *\/$/;"	v
signal_queue_len	src/signal.c	/^int signal_queue_len; \/* length of signal queue, <= MAX_SIGNAL (1 entry per signal max) *\/$/;"	v
signal_register_fct	src/signal.c	/^struct sig_handler *signal_register_fct(int sig, void (*fct)(struct sig_handler *), int arg)$/;"	f
signal_register_task	src/signal.c	/^struct sig_handler *signal_register_task(int sig, struct task *task, int reason)$/;"	f
signal_state	src/signal.c	/^struct signal_descriptor signal_state[MAX_SIGNAL];$/;"	v	typeref:struct:signal_descriptor
signal_unregister_handler	src/signal.c	/^void signal_unregister_handler(struct sig_handler *handler)$/;"	f
signal_unregister_target	src/signal.c	/^void signal_unregister_target(int sig, void *target)$/;"	f
MAX_SPLICE_AT_ONCE	src/sock_raw.c	65;"	d	file:
SPLICE_FULL_HINT	src/sock_raw.c	61;"	d	file:
_GNU_SOURCE	src/sock_raw.c	13;"	d	file:
sock_raw	src/sock_raw.c	/^struct sock_ops sock_raw = {$/;"	v	typeref:struct:sock_ops
sock_raw_chk_rcv	src/sock_raw.c	/^static void sock_raw_chk_rcv(struct stream_interface *si)$/;"	f	file:
sock_raw_chk_snd	src/sock_raw.c	/^static void sock_raw_chk_snd(struct stream_interface *si)$/;"	f	file:
sock_raw_data_finish	src/sock_raw.c	/^static void sock_raw_data_finish(struct stream_interface *si)$/;"	f	file:
sock_raw_read	src/sock_raw.c	/^static int sock_raw_read(int fd)$/;"	f	file:
sock_raw_shutr	src/sock_raw.c	/^static void sock_raw_shutr(struct stream_interface *si)$/;"	f	file:
sock_raw_shutw	src/sock_raw.c	/^static void sock_raw_shutw(struct stream_interface *si)$/;"	f	file:
sock_raw_splice_in	src/sock_raw.c	/^static int sock_raw_splice_in(struct buffer *b, struct stream_interface *si)$/;"	f	file:
sock_raw_write	src/sock_raw.c	/^static int sock_raw_write(int fd)$/;"	f	file:
sock_raw_write_loop	src/sock_raw.c	/^static int sock_raw_write_loop(struct stream_interface *si, struct buffer *b)$/;"	f	file:
addr_to_str	src/standard.c	/^int addr_to_str(struct sockaddr_storage *addr, char *str, int size)$/;"	f
buf2ip	src/standard.c	/^int buf2ip(const char *buf, size_t len, struct in_addr *dst)$/;"	f
date2str_log	src/standard.c	/^char *date2str_log(char *dst, struct tm *tm, struct timeval *date, size_t size)$/;"	f
encode_string	src/standard.c	/^char *encode_string(char *start, char *stop,$/;"	f
full_hash	src/standard.c	/^unsigned int full_hash(unsigned int a)$/;"	f
get_next_id	src/standard.c	/^unsigned int get_next_id(struct eb_root *root, unsigned int key)$/;"	f
get_std_op	src/standard.c	/^int get_std_op(const char *str)$/;"	f
gmt2str_log	src/standard.c	/^char *gmt2str_log(char *dst, struct tm *tm, size_t size)$/;"	f
hex2i	src/standard.c	/^int hex2i(int c)$/;"	f
hextab	src/standard.c	/^const char hextab[16] = "0123456789ABCDEF";$/;"	v
human_time	src/standard.c	/^char *human_time(int t, short hz_div) {$/;"	f
in_net_ipv4	src/standard.c	/^int in_net_ipv4(struct in_addr *addr, struct in_addr *mask, struct in_addr *net)$/;"	f
in_net_ipv6	src/standard.c	/^int in_net_ipv6(struct in6_addr *addr, struct in6_addr *mask, struct in6_addr *net)$/;"	f
inetaddr_host	src/standard.c	/^unsigned int inetaddr_host(const char *text)$/;"	f
inetaddr_host_lim	src/standard.c	/^unsigned int inetaddr_host_lim(const char *text, const char *stop)$/;"	f
inetaddr_host_lim_ret	src/standard.c	/^unsigned int inetaddr_host_lim_ret(char *text, char *stop, char **ret)$/;"	f
invalid_char	src/standard.c	/^const char *invalid_char(const char *name)$/;"	f
invalid_domainchar	src/standard.c	/^const char *invalid_domainchar(const char *name) {$/;"	f
ishex	src/standard.c	/^int ishex(char s)$/;"	f
itoa_str	src/standard.c	/^char itoa_str[10][171];$/;"	v
limit_r	src/standard.c	/^const char *limit_r(unsigned long n, char *buffer, int size, const char *alt)$/;"	f
lltoa	src/standard.c	/^char *lltoa(long long n, char *dst, size_t size)$/;"	f
ltoa_o	src/standard.c	/^char *ltoa_o(long int n, char *dst, size_t size)$/;"	f
memprintf	src/standard.c	/^char *memprintf(char **out, const char *format, ...)$/;"	f
monthname	src/standard.c	/^const char *monthname[12] = {$/;"	v
my_strndup	src/standard.c	/^char *my_strndup(const char *src, int n)$/;"	f
parse_size_err	src/standard.c	/^const char *parse_size_err(const char *text, unsigned *ret) {$/;"	f
parse_time_err	src/standard.c	/^const char *parse_time_err(const char *text, unsigned *ret, unsigned unit_flags)$/;"	f
quote_arg	src/standard.c	/^const char *quote_arg(const char *ptr)$/;"	f
read_uint	src/standard.c	/^unsigned int read_uint(const char **s, const char *end)$/;"	f
rfc4291_pfx	src/standard.c	/^const char rfc4291_pfx[] = { 0x00, 0x00, 0x00, 0x00,$/;"	v
str2ip	src/standard.c	/^struct sockaddr_storage *str2ip(const char *str)$/;"	f
str2mask	src/standard.c	/^int str2mask(const char *str, struct in_addr *mask)$/;"	f
str2net	src/standard.c	/^int str2net(const char *str, struct in_addr *addr, struct in_addr *mask)$/;"	f
str2sa	src/standard.c	/^struct sockaddr_storage *str2sa(const char *str)$/;"	f
str2sa_range	src/standard.c	/^struct sockaddr_storage *str2sa_range(const char *str, int *low, int *high)$/;"	f
str2sun	src/standard.c	/^struct sockaddr_un *str2sun(const char *str)$/;"	f
str2ui	src/standard.c	/^unsigned int str2ui(const char *s)$/;"	f
str2uic	src/standard.c	/^unsigned int str2uic(const char *s)$/;"	f
str62net	src/standard.c	/^int str62net(const char *str, struct in6_addr *addr, unsigned char *mask)$/;"	f
strl2ic	src/standard.c	/^int strl2ic(const char *s, int len)$/;"	f
strl2irc	src/standard.c	/^int strl2irc(const char *s, int len, int *ret)$/;"	f
strl2llrc	src/standard.c	/^int strl2llrc(const char *s, int len, long long *ret)$/;"	f
strl2ui	src/standard.c	/^unsigned int strl2ui(const char *s, int len)$/;"	f
strl2uic	src/standard.c	/^unsigned int strl2uic(const char *s, int len)$/;"	f
strlcpy2	src/standard.c	/^int strlcpy2(char *dst, const char *src, int size)$/;"	f
ulltoa	src/standard.c	/^char *ulltoa(unsigned long long n, char *dst, size_t size)$/;"	f
ulltoh_r	src/standard.c	/^const char *ulltoh_r(unsigned long long n, char *buffer, int size)$/;"	f
ultoa_o	src/standard.c	/^char *ultoa_o(unsigned long n, char *dst, size_t size)$/;"	f
ultoa_r	src/standard.c	/^char *ultoa_r(unsigned long n, char *buffer, int size)$/;"	f
url2ipv4	src/standard.c	/^int url2ipv4(const char *addr, struct in_addr *dst)$/;"	f
url2sa	src/standard.c	/^int url2sa(const char *url, int ulen, struct sockaddr_storage *addr)$/;"	f
url_decode	src/standard.c	/^int url_decode(char *string)$/;"	f
utoa_pad	src/standard.c	/^char *utoa_pad(unsigned int n, char *dst, size_t size)$/;"	f
v4tov6	src/standard.c	/^void v4tov6(struct in6_addr *sin6_addr, struct in_addr *sin_addr)$/;"	f
v6tov4	src/standard.c	/^int v6tov4(struct in_addr *sin_addr, struct in6_addr *sin6_addr)$/;"	f
word_match	src/standard.c	/^int word_match(const char *sample, int slen, const char *word, int wlen)$/;"	f
find_stktable	src/stick_table.c	/^struct proxy *find_stktable(const char *name)$/;"	f
k_int2int	src/stick_table.c	/^static void *k_int2int(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_int2ip	src/stick_table.c	/^static void *k_int2ip(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_int2str	src/stick_table.c	/^static void *k_int2str(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ip2int	src/stick_table.c	/^static void *k_ip2int(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ip2ip	src/stick_table.c	/^static void *k_ip2ip(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ip2ipv6	src/stick_table.c	/^static void *k_ip2ipv6(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ip2str	src/stick_table.c	/^static void *k_ip2str(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ipv62ipv6	src/stick_table.c	/^static void *k_ipv62ipv6(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_ipv62str	src/stick_table.c	/^static void *k_ipv62str(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_str2int	src/stick_table.c	/^static void *k_str2int(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_str2ip	src/stick_table.c	/^static void *k_str2ip(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_str2ipv6	src/stick_table.c	/^static void *k_str2ipv6(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
k_str2str	src/stick_table.c	/^static void *k_str2str(struct sample *smp, union stktable_key_data *kdata, size_t *len)$/;"	f	file:
process_table_expire	src/stick_table.c	/^static struct task *process_table_expire(struct task *task)$/;"	f	file:
sample_to_key	src/stick_table.c	/^static sample_to_key_fct sample_to_key[SMP_TYPES][STKTABLE_TYPES] = {$/;"	v	file:
sample_to_key_fct	src/stick_table.c	/^typedef void *(*sample_to_key_fct)(struct sample *smp, union stktable_key_data *kdata, size_t *len);$/;"	t	file:
static_table_key	src/stick_table.c	/^struct stktable_key static_table_key;$/;"	v	typeref:struct:stktable_key
stksess_free	src/stick_table.c	/^void stksess_free(struct stktable *t, struct stksess *ts)$/;"	f
stksess_init	src/stick_table.c	/^static struct stksess *stksess_init(struct stktable *t, struct stksess * ts)$/;"	f	file:
stksess_kill	src/stick_table.c	/^void stksess_kill(struct stktable *t, struct stksess *ts)$/;"	f
stksess_new	src/stick_table.c	/^struct stksess *stksess_new(struct stktable *t, struct stktable_key *key)$/;"	f
stksess_setkey	src/stick_table.c	/^void stksess_setkey(struct stktable *t, struct stksess *ts, struct stktable_key *key)$/;"	f
stktable_compatible_sample	src/stick_table.c	/^int stktable_compatible_sample(struct sample_expr *expr, unsigned long table_type)$/;"	f
stktable_data_types	src/stick_table.c	/^struct stktable_data_type stktable_data_types[STKTABLE_DATA_TYPES] = {$/;"	v	typeref:struct:stktable_data_type
stktable_fetch_key	src/stick_table.c	/^struct stktable_key *stktable_fetch_key(struct stktable *t, struct proxy *px, struct session *l4, void *l7,$/;"	f
stktable_get_data_type	src/stick_table.c	/^int stktable_get_data_type(char *name)$/;"	f
stktable_get_entry	src/stick_table.c	/^struct stksess *stktable_get_entry(struct stktable *table, struct stktable_key *key)$/;"	f
stktable_init	src/stick_table.c	/^int stktable_init(struct stktable *t)$/;"	f
stktable_lookup	src/stick_table.c	/^struct stksess *stktable_lookup(struct stktable *t, struct stksess *ts)$/;"	f
stktable_lookup_key	src/stick_table.c	/^struct stksess *stktable_lookup_key(struct stktable *t, struct stktable_key *key)$/;"	f
stktable_parse_type	src/stick_table.c	/^int stktable_parse_type(char **args, int *myidx, unsigned long *type, size_t *key_size)$/;"	f
stktable_store	src/stick_table.c	/^struct stksess *stktable_store(struct stktable *t, struct stksess *ts, int local)$/;"	f
stktable_touch	src/stick_table.c	/^struct stksess *stktable_touch(struct stktable *t, struct stksess *ts, int local)$/;"	f
stktable_trash_expired	src/stick_table.c	/^static int stktable_trash_expired(struct stktable *t)$/;"	f	file:
stktable_trash_oldest	src/stick_table.c	/^static int stktable_trash_oldest(struct stktable *t, int to_batch)$/;"	f	file:
stktable_types	src/stick_table.c	/^struct stktable_type stktable_types[STKTABLE_TYPES] =  {{ "ip", 0, 4 },$/;"	v	typeref:struct:stktable_type
stktable_update_key	src/stick_table.c	/^struct stksess *stktable_update_key(struct stktable *table, struct stktable_key *key)$/;"	f
stream_int_check_timeouts	src/stream_interface.c	/^int stream_int_check_timeouts(struct stream_interface *si)$/;"	f
stream_int_chk_rcv	src/stream_interface.c	/^static void stream_int_chk_rcv(struct stream_interface *si)$/;"	f	file:
stream_int_chk_snd	src/stream_interface.c	/^static void stream_int_chk_snd(struct stream_interface *si)$/;"	f	file:
stream_int_embedded	src/stream_interface.c	/^struct sock_ops stream_int_embedded = {$/;"	v	typeref:struct:sock_ops
stream_int_register_handler	src/stream_interface.c	/^struct task *stream_int_register_handler(struct stream_interface *si, struct si_applet *app)$/;"	f
stream_int_register_handler_task	src/stream_interface.c	/^struct task *stream_int_register_handler_task(struct stream_interface *si,$/;"	f
stream_int_report_error	src/stream_interface.c	/^void stream_int_report_error(struct stream_interface *si)$/;"	f
stream_int_retnclose	src/stream_interface.c	/^void stream_int_retnclose(struct stream_interface *si, const struct chunk *msg)$/;"	f
stream_int_shutr	src/stream_interface.c	/^static void stream_int_shutr(struct stream_interface *si)$/;"	f	file:
stream_int_shutw	src/stream_interface.c	/^static void stream_int_shutw(struct stream_interface *si)$/;"	f	file:
stream_int_task	src/stream_interface.c	/^struct sock_ops stream_int_task = {$/;"	v	typeref:struct:sock_ops
stream_int_unregister_handler	src/stream_interface.c	/^void stream_int_unregister_handler(struct stream_interface *si)$/;"	f
stream_int_update	src/stream_interface.c	/^static void stream_int_update(struct stream_interface *si)$/;"	f	file:
stream_int_update_embedded	src/stream_interface.c	/^static void stream_int_update_embedded(struct stream_interface *si)$/;"	f	file:
__task_queue	src/task.c	/^void __task_queue(struct task *task)$/;"	f
__task_wakeup	src/task.c	/^struct task *__task_wakeup(struct task *t)$/;"	f
init_task	src/task.c	/^int init_task()$/;"	f
last_timer	src/task.c	/^struct eb32_node *last_timer = NULL;  \/* optimization: last queued timer *\/$/;"	v	typeref:struct:eb32_node
nb_tasks	src/task.c	/^unsigned int nb_tasks = 0;$/;"	v
nb_tasks_cur	src/task.c	/^unsigned int nb_tasks_cur = 0;     \/* copy of the tasks count *\/$/;"	v
niced_tasks	src/task.c	/^unsigned int niced_tasks = 0;      \/* number of niced tasks in the run queue *\/$/;"	v
pool2_task	src/task.c	/^struct pool_head *pool2_task;$/;"	v	typeref:struct:pool_head
process_runnable_tasks	src/task.c	/^void process_runnable_tasks(int *next)$/;"	f
rqueue	src/task.c	/^static struct eb_root rqueue;      \/* tree constituting the run queue *\/$/;"	v	typeref:struct:eb_root	file:
rqueue_ticks	src/task.c	/^static unsigned int rqueue_ticks;  \/* insertion count *\/$/;"	v	file:
run_queue	src/task.c	/^unsigned int run_queue = 0;$/;"	v
run_queue_cur	src/task.c	/^unsigned int run_queue_cur = 0;    \/* copy of the run queue size *\/$/;"	v
timers	src/task.c	/^static struct eb_root timers;      \/* sorted timers tree *\/$/;"	v	typeref:struct:eb_root	file:
wake_expired_tasks	src/task.c	/^void wake_expired_tasks(int *next)$/;"	f
_tv_add	src/time.c	/^REGPRM3 struct timeval *_tv_add(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
_tv_add_ifset	src/time.c	/^REGPRM3 int _tv_add_ifset(struct timeval *tv, const struct timeval *from, const struct timeval *inc)$/;"	f
_tv_isgt	src/time.c	/^REGPRM2 int _tv_isgt(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_isle	src/time.c	/^REGPRM2 int _tv_isle(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_add	src/time.c	/^REGPRM3 struct timeval *_tv_ms_add(struct timeval *tv, const struct timeval *from, int ms)$/;"	f
_tv_ms_cmp	src/time.c	/^REGPRM2 int _tv_ms_cmp(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_cmp2	src/time.c	/^REGPRM2 int _tv_ms_cmp2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_elapsed	src/time.c	/^REGPRM2 unsigned long _tv_ms_elapsed(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_le2	src/time.c	/^REGPRM2 int _tv_ms_le2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_remain	src/time.c	/^REGPRM2 unsigned long _tv_ms_remain(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_ms_remain2	src/time.c	/^REGPRM2 unsigned long _tv_ms_remain2(const struct timeval *tv1, const struct timeval *tv2)$/;"	f
_tv_remain	src/time.c	/^REGPRM3 struct timeval *_tv_remain(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
_tv_remain2	src/time.c	/^REGPRM3 struct timeval *_tv_remain2(const struct timeval *tv1, const struct timeval *tv2, struct timeval *tv)$/;"	f
after_poll	src/time.c	/^struct timeval after_poll;      \/* system date after leaving poll() *\/$/;"	v	typeref:struct:timeval
before_poll	src/time.c	/^struct timeval before_poll;     \/* system date before calling poll() *\/$/;"	v	typeref:struct:timeval
curr_sec_ms	src/time.c	/^unsigned int   curr_sec_ms;      \/* millisecond of current second (0..999) *\/$/;"	v
curr_sec_ms_scaled	src/time.c	/^unsigned int   curr_sec_ms_scaled;  \/* millisecond of current second (0..2^32-1) *\/$/;"	v
date	src/time.c	/^struct timeval date;            \/* the real current date *\/$/;"	v	typeref:struct:timeval
idle_pct	src/time.c	/^unsigned int   idle_pct;        \/* idle to total ratio over last sample (percent) *\/$/;"	v
idle_time	src/time.c	/^unsigned int   idle_time;       \/* total idle time over current sample *\/$/;"	v
now	src/time.c	/^struct timeval now;             \/* internal date is a monotonic function of real clock *\/$/;"	v	typeref:struct:timeval
now_ms	src/time.c	/^unsigned int   now_ms;          \/* internal date in milliseconds (may wrap) *\/$/;"	v
samp_time	src/time.c	/^unsigned int   samp_time;       \/* total elapsed time over current sample *\/$/;"	v
start_date	src/time.c	/^struct timeval start_date;      \/* the process's start date *\/$/;"	v	typeref:struct:timeval
tv_update_date	src/time.c	/^REGPRM2 void tv_update_date(int max_wait, int interrupted)$/;"	f
__cyg_profile_func_enter	src/trace.c	/^void __cyg_profile_func_enter(void *to,  void *from)$/;"	f
__cyg_profile_func_exit	src/trace.c	/^void __cyg_profile_func_exit(void *to,  void *from)$/;"	f
disabled	src/trace.c	/^static int disabled;$/;"	v	file:
emit_hex	src/trace.c	/^static char *emit_hex(unsigned long h, char *out)$/;"	f	file:
fast_time	src/trace.c	/^static int fast_time;$/;"	v	file:
level	src/trace.c	/^static int level;$/;"	v	file:
line	src/trace.c	/^static char line[128]; \/* more than enough for a message (9+1+6+1+3+1+18+1+1+18+1+1) *\/$/;"	v	file:
log	src/trace.c	/^static FILE *log;$/;"	v	file:
make_line	src/trace.c	/^static void make_line(void *from, void *to, int level, char dir)$/;"	f	file:
now_ptr	src/trace.c	/^static struct timeval *now_ptr;$/;"	v	typeref:struct:timeval	file:
open_trace	src/trace.c	/^static int open_trace()$/;"	f	file:
rdtsc	src/trace.c	/^static inline unsigned long long rdtsc()$/;"	f	file:
trace_now	src/trace.c	/^static struct timeval trace_now;$/;"	v	typeref:struct:timeval	file:
ultoad2	src/trace.c	/^static char *ultoad2(unsigned int x, char *out, int min_pairs)$/;"	f	file:
use_tsc	src/trace.c	/^static int use_tsc;$/;"	v	file:
stats_add_auth	src/uri_auth.c	/^struct uri_auth *stats_add_auth(struct uri_auth **root, char *user)$/;"	f
stats_add_scope	src/uri_auth.c	/^struct uri_auth *stats_add_scope(struct uri_auth **root, char *scope)$/;"	f
stats_check_init_uri_auth	src/uri_auth.c	/^struct uri_auth *stats_check_init_uri_auth(struct uri_auth **root)$/;"	f
stats_set_desc	src/uri_auth.c	/^struct uri_auth *stats_set_desc(struct uri_auth **root, char *desc)$/;"	f
stats_set_flag	src/uri_auth.c	/^struct uri_auth *stats_set_flag(struct uri_auth **root, int flag)$/;"	f
stats_set_node	src/uri_auth.c	/^struct uri_auth *stats_set_node(struct uri_auth **root, char *name)$/;"	f
stats_set_realm	src/uri_auth.c	/^struct uri_auth *stats_set_realm(struct uri_auth **root, char *realm)$/;"	f
stats_set_refresh	src/uri_auth.c	/^struct uri_auth *stats_set_refresh(struct uri_auth **root, int interval)$/;"	f
stats_set_uri	src/uri_auth.c	/^struct uri_auth *stats_set_uri(struct uri_auth **root, char *uri)$/;"	f
dequeue_srv	tests/filltab25.c	/^static inline void dequeue_srv(struct srv *s) {$/;"	f	file:
get_next_server	tests/filltab25.c	/^struct srv *get_next_server() {$/;"	f
get_srv	tests/filltab25.c	/^void get_srv(struct srv *s) {$/;"	f
get_srv_down	tests/filltab25.c	/^static inline void get_srv_down(struct srv *s) {$/;"	f	file:
get_srv_init	tests/filltab25.c	/^static inline void get_srv_init(struct srv *s) {$/;"	f	file:
get_srv_next	tests/filltab25.c	/^static inline void get_srv_next(struct srv *s) {$/;"	f	file:
init_tree	tests/filltab25.c	/^struct eb_root *init_tree; \/* receives positions 0..sw-1 *\/$/;"	v	typeref:struct:eb_root
last	tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:
main	tests/filltab25.c	/^main(int argc, char **argv) {$/;"	f
next	tests/filltab25.c	/^	int next, last;$/;"	m	struct:srv	file:
next_tree	tests/filltab25.c	/^struct eb_root *next_tree; \/* receives positions >= 2sw *\/$/;"	v	typeref:struct:eb_root
node	tests/filltab25.c	/^	struct eb32_node node;$/;"	m	struct:srv	typeref:struct:srv::eb32_node	file:
nsrv	tests/filltab25.c	/^int nsrv;       \/* # of servers *\/$/;"	v
nsw	tests/filltab25.c	/^int nsw, sw;    \/* sum of weights *\/$/;"	v
num	tests/filltab25.c	/^	int num;$/;"	m	struct:srv	file:
p	tests/filltab25.c	/^int p;          \/* current position, between sw..2sw-1 *\/$/;"	v
put_srv	tests/filltab25.c	/^void put_srv(struct srv *s) {$/;"	f
queue_by_weight	tests/filltab25.c	/^void queue_by_weight(struct eb_root *root, struct srv *s) {$/;"	f
queue_by_weight_0	tests/filltab25.c	/^void queue_by_weight_0(struct eb_root *root, struct srv *s) {$/;"	f
rem	tests/filltab25.c	/^	int rem;$/;"	m	struct:srv	file:
srv	tests/filltab25.c	/^struct srv {$/;"	s	file:
srv	tests/filltab25.c	/^} *srv;$/;"	v	typeref:struct:srv
sw	tests/filltab25.c	/^int nsw, sw;    \/* sum of weights *\/$/;"	v
switch_trees	tests/filltab25.c	/^void switch_trees() {$/;"	f
tree	tests/filltab25.c	/^	struct eb_root *tree; \/\/ we want to know where the server is$/;"	m	struct:srv	typeref:struct:srv::eb_root	file:
tree_0	tests/filltab25.c	/^struct eb_root tree_0 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_1	tests/filltab25.c	/^struct eb_root tree_1 = EB_ROOT;$/;"	v	typeref:struct:eb_root
tree_2	tests/filltab25.c	/^struct eb_root tree_2 = EB_ROOT;$/;"	v	typeref:struct:eb_root
update_position	tests/filltab25.c	/^void update_position(struct srv *s) {$/;"	f
w	tests/filltab25.c	/^	int w; \/* weight *\/$/;"	m	struct:srv	file:
MAXLINE	tests/ip-hash.c	17;"	d	file:
NSERV	tests/ip-hash.c	16;"	d	file:
count_hash_results	tests/ip-hash.c	/^void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {$/;"	f
counts_bj6	tests/ip-hash.c	/^int counts_bj6[NSERV][NSERV];$/;"	v
counts_bj6x	tests/ip-hash.c	/^int counts_bj6x[NSERV][NSERV];$/;"	v
counts_bj7	tests/ip-hash.c	/^int counts_bj7[NSERV][NSERV];$/;"	v
counts_bj7x	tests/ip-hash.c	/^int counts_bj7x[NSERV][NSERV];$/;"	v
counts_id	tests/ip-hash.c	/^int counts_id[NSERV][NSERV];$/;"	v
counts_tw1	tests/ip-hash.c	/^int counts_tw1[NSERV][NSERV];$/;"	v
counts_tw2	tests/ip-hash.c	/^int counts_tw2[NSERV][NSERV];$/;"	v
counts_tw3	tests/ip-hash.c	/^int counts_tw3[NSERV][NSERV];$/;"	v
dump_hash_results	tests/ip-hash.c	/^void dump_hash_results(char *name, int counts[NSERV][NSERV]) {$/;"	f
hash_bj6	tests/ip-hash.c	/^uint32_t hash_bj6(uint32_t a)$/;"	f
hash_bj7	tests/ip-hash.c	/^uint32_t hash_bj7(uint32_t a)$/;"	f
hash_id	tests/ip-hash.c	/^uint32_t hash_id( uint32_t a)$/;"	f
hash_tw1	tests/ip-hash.c	/^uint32_t hash_tw1(uint32_t a)$/;"	f
hash_tw2	tests/ip-hash.c	/^uint32_t hash_tw2(uint32_t a)$/;"	f
hash_tw3	tests/ip-hash.c	/^uint32_t hash_tw3(uint32_t a)$/;"	f
main	tests/ip-hash.c	/^int main() {$/;"	f
main	tests/reset.c	/^int main(int argc, char **argv) {$/;"	f
main	tests/sessionhash_test.c	/^int main(int argc, char *argv[])$/;"	f
main	tests/test-arg.c	/^int main(int argc, char **argv)$/;"	f
main	tests/test.c	/^main() {$/;"	f
FNV_32_PRIME	tests/test_hashes.c	293;"	d	file:
Fnv32_t	tests/test_hashes.c	/^typedef unsigned long Fnv32_t;$/;"	t	file:
HAPROXY_BACKENDS	tests/test_hashes.c	31;"	d	file:
HASHSIZE	tests/test_hashes.c	449;"	d	file:
SuperFastHash	tests/test_hashes.c	/^uint32_t SuperFastHash (const char * data, int len) {$/;"	f
SuperFastHash2	tests/test_hashes.c	/^uint32_t SuperFastHash2 (const char * data, int len) {$/;"	f
bernstein	tests/test_hashes.c	/^ub4 bernstein(ub1 *key, ub4 len, ub4 level){$/;"	f
final	tests/test_hashes.c	389;"	d	file:
fnv_32a_str	tests/test_hashes.c	/^fnv_32a_str(char *str, Fnv32_t hval)$/;"	f
fnv_hash	tests/test_hashes.c	/^unsigned fnv_hash ( void *key, int len )$/;"	f
get16bits	tests/test_hashes.c	150;"	d	file:
get16bits	tests/test_hashes.c	153;"	d	file:
get16bits	tests/test_hashes.c	157;"	d	file:
haproxy_server_hash	tests/test_hashes.c	/^unsigned int haproxy_server_hash(const char *addr, int len){$/;"	f
haproxy_uri_hash	tests/test_hashes.c	/^unsigned long haproxy_uri_hash(char *uri, int uri_len){$/;"	f
hash_djbx33	tests/test_hashes.c	/^hash_djbx33($/;"	f	file:
hashpjw	tests/test_hashes.c	/^int hashpjw(const void *key) {$/;"	f
hashword	tests/test_hashes.c	/^uint32_t hashword($/;"	f
kr_hash	tests/test_hashes.c	/^unsigned kr_hash(char *s){$/;"	f
main	tests/test_hashes.c	/^int main(){$/;"	f
mix	tests/test_hashes.c	354;"	d	file:
oat_hash	tests/test_hashes.c	/^unsigned oat_hash ( void *key, int len )$/;"	f
rot	tests/test_hashes.c	308;"	d	file:
run_test	tests/test_hashes.c	510;"	d	file:
sax_hash	tests/test_hashes.c	/^unsigned sax_hash ( void *key, int len )$/;"	f
timeval_current	tests/test_hashes.c	/^static struct timeval timeval_current(void)$/;"	f	file:
timeval_elapsed	tests/test_hashes.c	/^static double timeval_elapsed(struct timeval *tv)$/;"	f	file:
ub1	tests/test_hashes.c	/^typedef  unsigned       char ub1;   \/* unsigned 1-byte quantities *\/$/;"	t	file:
ub4	tests/test_hashes.c	/^typedef  unsigned long  int  ub4;   \/* unsigned 4-byte quantities *\/$/;"	t	file:
wt_hash	tests/test_hashes.c	/^unsigned wt_hash ( void *key, int len )$/;"	f
main	tests/test_pools.c	/^int main(void)$/;"	f
pool_alloc	tests/test_pools.c	84;"	d	file:
pool_alloc_from	tests/test_pools.c	52;"	d	file:
pool_destroy	tests/test_pools.c	/^static inline void pool_destroy(void **pool)$/;"	f	file:
pool_free	tests/test_pools.c	103;"	d	file:
pool_free_to	tests/test_pools.c	72;"	d	file:
sizeof_talloc	tests/test_pools.c	124;"	d	file:
test_speed1	tests/test_pools.c	/^static bool test_speed1(void)$/;"	f	file:
timeval_current	tests/test_pools.c	/^static struct timeval timeval_current(void)$/;"	f	file:
timeval_elapsed	tests/test_pools.c	/^static double timeval_elapsed(struct timeval *tv)$/;"	f	file:
torture_assert	tests/test_pools.c	31;"	d	file:
torture_assert_str_equal	tests/test_pools.c	37;"	d	file:
main	tests/testinet.c	/^main() {$/;"	f
MAXLINE	tests/uri_hash.c	6;"	d	file:
NSERV	tests/uri_hash.c	5;"	d	file:
SuperFastHash	tests/uri_hash.c	/^uint32_t SuperFastHash (const char * data, int len) {$/;"	f
SuperFastHash2	tests/uri_hash.c	/^uint32_t SuperFastHash2 (const char * data, int len) {$/;"	f
count_hash_results	tests/uri_hash.c	/^void count_hash_results(unsigned long hash, int counts[NSERV][NSERV]) {$/;"	f
counts_SuperFastHash	tests/uri_hash.c	/^int counts_SuperFastHash[NSERV][NSERV];$/;"	v
counts_SuperFastHash2	tests/uri_hash.c	/^int counts_SuperFastHash2[NSERV][NSERV];$/;"	v
counts_gd1	tests/uri_hash.c	/^int counts_gd1[NSERV][NSERV];$/;"	v
counts_gd2	tests/uri_hash.c	/^int counts_gd2[NSERV][NSERV];$/;"	v
counts_gd3	tests/uri_hash.c	/^int counts_gd3[NSERV][NSERV];$/;"	v
counts_gd4	tests/uri_hash.c	/^int counts_gd4[NSERV][NSERV];$/;"	v
counts_gd5	tests/uri_hash.c	/^int counts_gd5[NSERV][NSERV];$/;"	v
counts_gd6	tests/uri_hash.c	/^int counts_gd6[NSERV][NSERV];$/;"	v
counts_srv	tests/uri_hash.c	/^int counts_srv[NSERV][NSERV];$/;"	v
counts_wt1	tests/uri_hash.c	/^int counts_wt1[NSERV][NSERV];$/;"	v
counts_wt2	tests/uri_hash.c	/^int counts_wt2[NSERV][NSERV];$/;"	v
dump_hash_results	tests/uri_hash.c	/^void dump_hash_results(char *name, int counts[NSERV][NSERV]) {$/;"	f
get16bits	tests/uri_hash.c	184;"	d	file:
get16bits	tests/uri_hash.c	187;"	d	file:
get16bits	tests/uri_hash.c	191;"	d	file:
haproxy_server_hash	tests/uri_hash.c	/^unsigned int haproxy_server_hash(const char *addr, int len){$/;"	f
hash_gd1	tests/uri_hash.c	/^static unsigned long hash_gd1(char *uri)$/;"	f	file:
hash_gd2	tests/uri_hash.c	/^static unsigned long hash_gd2(char *uri)$/;"	f	file:
hash_gd3	tests/uri_hash.c	/^static unsigned long hash_gd3(char *uri)$/;"	f	file:
hash_gd4	tests/uri_hash.c	/^static unsigned long hash_gd4(char *uri)$/;"	f	file:
hash_gd5	tests/uri_hash.c	/^static unsigned long hash_gd5(char *uri)$/;"	f	file:
hash_gd6	tests/uri_hash.c	/^static unsigned long hash_gd6(char *uri)$/;"	f	file:
hash_wt1	tests/uri_hash.c	/^static unsigned long hash_wt1(int hsize, char *string) {$/;"	f	file:
hash_wt2	tests/uri_hash.c	/^int hash_wt2(const char *src, int len) {$/;"	f
line	tests/uri_hash.c	/^char line[MAXLINE];$/;"	v
main	tests/uri_hash.c	/^int main() {$/;"	f
rev32	tests/uri_hash.c	/^static unsigned int rev32(unsigned int c) {$/;"	f	file:
shl32	tests/uri_hash.c	/^static inline u_int32_t shl32(u_int32_t i, int count) {$/;"	f	file:
shr32	tests/uri_hash.c	/^static inline u_int32_t shr32(u_int32_t i, int count) {$/;"	f	file:
u_int32_t	tests/uri_hash.c	/^typedef unsigned int u_int32_t;$/;"	t	file:
